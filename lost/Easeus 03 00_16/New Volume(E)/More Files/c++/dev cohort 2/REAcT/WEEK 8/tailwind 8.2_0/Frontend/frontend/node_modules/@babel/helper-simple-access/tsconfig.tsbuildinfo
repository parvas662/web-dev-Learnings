C yC AC cC zC" }, G: { "1": "5C 6C 7C 8C 9C AD BD CD DD ED FD GD HD ID JD OC PC CC KD DC QC RC SC TC UC LD EC VC WC XC YC ZC aC FC bC", "2": "E MC 0C dC 1C 2C 3C 4C" }, H: { "1": "MD" }, I: { "1": "I RD SD", "2": "GC J ND OD PD QD dC" }, J: { "2": "D A" }, K: { "1": "H", "2": "A B C AC cC BC" }, L: { "1": "I" }, M: { "1": "9B" }, N: { "2": "A B" }, O: { "1": "CC" }, P: { "1": "0 1 2 3 J y z TD UD VD WD XD NC YD ZD aD bD cD DC EC FC dD" }, Q: { "1": "eD" }, R: { "1": "fD" }, S: { "1": "gD hD" } }, B: 4, C: "CSS Feature Queries", D: true };
  }
});

// node_modules/autoprefixer/lib/brackets.js
var require_brackets = __commonJS({
  "node_modules/autoprefixer/lib/brackets.js"(exports2, module2) {
    function last(array) {
      return array[array.length - 1];
    }
    var brackets = {
      /**
       * Parse string to nodes tree
       */
      parse(str) {
        let current = [""];
        let stack = [current];
        for (let sym of str) {
          if (sym === "(") {
            current = [""];
            last(stack).push(current);
            stack.push(current);
            continue;
          }
          if (sym === ")") {
            stack.pop();
            current = last(stack);
            current.push("");
            continue;
          }
          current[current.length - 1] += sym;
        }
        return stack[0];
      },
      /**
       * Generate output string by nodes tree
       */
      stringify(ast) {
        let result = "";
        for (let i of ast) {
          if (typeof i === "object") {
            result += `(${brackets.stringify(i)})`;
            continue;
          }
          result += i;
        }
        return result;
      }
    };
    module2.exports = brackets;
  }
});

// node_modules/autoprefixer/lib/supports.js
var require_supports = __commonJS({
  "node_modules/autoprefixer/lib/supports.js"(exports2, module2) {
    var featureQueries = require_css_featurequeries();
    var feature = require_feature();
    var { parse } = require_postcss();
    var Browsers = require_browsers3();
    var brackets = require_brackets();
    var Value = require_value();
    var utils = require_utils();
    var data = feature(featureQueries);
    var supported = [];
    for (let browser in data.stats) {
      let versions = data.stats[browser];
      for (let version in versions) {
        let support = versions[version];
        if (/y/.test(support)) {
          supported.push(browser + " " + version);
        }
      }
    }
    var Supports = class {
      constructor(Prefixes, all) {
        this.Prefixes = Prefixes;
        this.all = all;
      }
      /**
       * Add prefixes
       */
      add(nodes, all) {
        return nodes.map((i) => {
          if (this.isProp(i)) {
            let prefixed = this.prefixed(i[0]);
            if (prefixed.length > 1) {
              return this.convert(prefixed);
            }
            return i;
          }
          if (typeof i === "object") {
            return this.add(i, all);
          }
          return i;
        });
      }
      /**
       * Clean brackets with one child
       */
      cleanBrackets(nodes) {
        return nodes.map((i) => {
          if (typeof i !== "object") {
            return i;
          }
          if (i.length === 1 && typeof i[0] === "object") {
            return this.cleanBrackets(i[0]);
          }
          return this.cleanBrackets(i);
        });
      }
      /**
       * Add " or " between properties and convert it to brackets format
       */
      convert(progress) {
        let result = [""];
        for (let i of progress) {
          result.push([`${i.prop}: ${i.value}`]);
          result.push(" or ");
        }
        result[result.length - 1] = "";
        return result;
      }
      /**
       * Check global options
       */
      disabled(node) {
        if (!this.all.options.grid) {
          if (node.prop === "display" && node.value.includes("grid")) {
            return true;
          }
          if (node.prop.includes("grid") || node.prop === "justify-items") {
            return true;
          }
        }
        if (this.all.options.flexbox === false) {
          if (node.prop === "display" && node.value.includes("flex")) {
            return true;
          }
          let other = ["order", "justify-content", "align-items", "align-content"];
          if (node.prop.includes("flex") || other.includes(node.prop)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Return true if prefixed property has no unprefixed
       */
      isHack(all, unprefixed) {
        let check = new RegExp(`(\\(|\\s)${utils.escapeRegexp(unprefixed)}:`);
        return !check.test(all);
      }
      /**
       * Return true if brackets node is "not" word
       */
      isNot(node) {
        return typeof node === "string" && /not\s*/i.test(node);
      }
      /**
       * Return true if brackets node is "or" word
       */
      isOr(node) {
        return typeof node === "string" && /\s*or\s*/i.test(node);
      }
      /**
       * Return true if brackets node is (prop: value)
       */
      isProp(node) {
        return typeof node === "object" && node.length === 1 && typeof node[0] === "string";
      }
      /**
       * Compress value functions into a string nodes
       */
      normalize(nodes) {
        if (typeof nodes !== "object") {
          return nodes;
        }
        nodes = nodes.filter((i) => i !== "");
        if (typeof nodes[0] === "string") {
          let firstNode = nodes[0].trim();
          if (firstNode.includes(":") || firstNode === "selector" || firstNode === "not selector") {
            return [brackets.stringify(nodes)];
          }
        }
        return nodes.map((i) => this.normalize(i));
      }
      /**
       * Parse string into declaration property and value
       */
      parse(str) {
        let parts = str.split(":");
        let prop = parts[0];
        let value = parts[1];
        if (!value) value = "";
        return [prop.trim(), value.trim()];
      }
      /**
       * Return array of Declaration with all necessary prefixes
       */
      prefixed(str) {
        let rule = this.virtual(str);
        if (this.disabled(rule.first)) {
          return rule.nodes;
        }
        let result = { warn: () => null };
        let prefixer = this.prefixer().add[rule.first.prop];
        prefixer && prefixer.process && prefixer.process(rule.first, result);
        for (let decl of rule.nodes) {
          for (let value of this.prefixer().values("add", rule.first.prop)) {
            value.process(decl);
          }
          Value.save(this.all, decl);
        }
        return rule.nodes;
      }
      /**
       * Return prefixer only with @supports supported browsers
       */
      prefixer() {
        if (this.prefixerCache) {
          return this.prefixerCache;
        }
        let filtered = this.all.browsers.selected.filter((i) => {
          return supported.includes(i);
        });
        let browsers = new Browsers(
          this.all.browsers.data,
          filtered,
          this.all.options
        );
        this.prefixerCache = new this.Prefixes(
          this.all.data,
          browsers,
          this.all.options
        );
        return this.prefixerCache;
      }
      /**
       * Add prefixed declaration
       */
      process(rule) {
        let ast = brackets.parse(rule.params);
        ast = this.normalize(ast);
        ast = this.remove(ast, rule.params);
        ast = this.add(ast, rule.params);
        ast = this.cleanBrackets(ast);
        rule.params = brackets.stringify(ast);
      }
      /**
       * Remove all unnecessary prefixes
       */
      remove(nodes, all) {
        let i = 0;
        while (i < nodes.length) {
          if (!this.isNot(nodes[i - 1]) && this.isProp(nodes[i]) && this.isOr(nodes[i + 1])) {
            if (this.toRemove(nodes[i][0], all)) {
              nodes.splice(i, 2);
              continue;
            }
            i += 2;
            continue;
          }
          if (typeof nodes[i] === "object") {
            nodes[i] = this.remove(nodes[i], all);
          }
          i += 1;
        }
        return nodes;
      }
      /**
       * Return true if we need to remove node
       */
      toRemove(str, all) {
        let [prop, value] = this.parse(str);
        let unprefixed = this.all.unprefixed(prop);
        let cleaner = this.all.cleaner();
        if (cleaner.remove[prop] && cleaner.remove[prop].remove && !this.isHack(all, unprefixed)) {
          return true;
        }
        for (let checker of cleaner.values("remove", unprefixed)) {
          if (checker.check(value)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Create virtual rule to process it by prefixer
       */
      virtual(str) {
        let [prop, value] = this.parse(str);
        let rule = parse("a{}").first;
        rule.append({ prop, raws: { before: "" }, value });
        return rule;
      }
    };
    module2.exports = Supports;
  }
});

// node_modules/autoprefixer/lib/old-selector.js
var require_old_selector = __commonJS({
  "node_modules/autoprefixer/lib/old-selector.js"(exports2, module2) {
    var OldSelector = class {
      constructor(selector, prefix) {
        this.prefix = prefix;
        this.prefixed = selector.prefixed(this.prefix);
        this.regexp = selector.regexp(this.prefix);
        this.prefixeds = selector.possible().map((x) => [selector.prefixed(x), selector.regexp(x)]);
        this.unprefixed = selector.name;
        this.nameRegexp = selector.regexp();
      }
      /**
       * Does rule contain an unnecessary prefixed selector
       */
      check(rule) {
        if (!rule.selector.includes(this.prefixed)) {
          return false;
        }
        if (!rule.selector.match(this.regexp)) {
          return false;
        }
        if (this.isHack(rule)) {
          return false;
        }
        return true;
      }
      /**
       * Is rule a hack without unprefixed version bottom
       */
      isHack(rule) {
        let index = rule.parent.index(rule) + 1;
        let rules = rule.parent.nodes;
        while (index < rules.length) {
          let before = rules[index].selector;
          if (!before) {
            return true;
          }
          if (before.includes(this.unprefixed) && before.match(this.nameRegexp)) {
            return false;
          }
          let some = false;
          for (let [string, regexp] of this.prefixeds) {
            if (before.includes(string) && before.match(regexp)) {
              some = true;
              break;
            }
          }
          if (!some) {
            return true;
          }
          index += 1;
        }
        return true;
      }
    };
    module2.exports = OldSelector;
  }
});

// node_modules/autoprefixer/lib/selector.js
var require_selector = __commonJS({
  "node_modules/autoprefixer/lib/selector.js"(exports2, module2) {
    var { list } = require_postcss();
    var OldSelector = require_old_selector();
    var Prefixer = require_prefixer();
    var Browsers = require_browsers3();
    var utils = require_utils();
    var Selector = class extends Prefixer {
      constructor(name, prefixes, all) {
        super(name, prefixes, all);
        this.regexpCache = /* @__PURE__ */ new Map();
      }
      /**
       * Clone and add prefixes for at-rule
       */
      add(rule, prefix) {
        let prefixeds = this.prefixeds(rule);
        if (this.already(rule, prefixeds, prefix)) {
          return;
        }
        let cloned = this.clone(rule, { selector: prefixeds[this.name][prefix] });
        rule.parent.insertBefore(rule, cloned);
      }
      /**
       * Is rule already prefixed before
       */
      already(rule, prefixeds, prefix) {
        let index = rule.parent.index(rule) - 1;
        while (index >= 0) {
          let before = rule.parent.nodes[index];
          if (before.type !== "rule") {
            return false;
          }
          let some = false;
          for (let key in prefixeds[this.name]) {
            let prefixed = prefixeds[this.name][key];
            if (before.selector === prefixed) {
              if (prefix === key) {
                return true;
              } else {
                some = true;
                break;
              }
            }
          }
          if (!some) {
            return false;
          }
          index -= 1;
        }
        return false;
      }
      /**
       * Is rule selectors need to be prefixed
       */
      check(rule) {
        if (rule.selector.includes(this.name)) {
          return !!rule.selector.match(this.regexp());
        }
        return false;
      }
      /**
       * Return function to fast find prefixed selector
       */
      old(prefix) {
        return new OldSelector(this, prefix);
      }
      /**
       * All possible prefixes
       */
      possible() {
        return Browsers.prefixes();
      }
      /**
       * Return prefixed version of selector
       */
      prefixed(prefix) {
        return this.name.replace(/^(\W*)/, `$1${prefix}`);
      }
      /**
       * Return all possible selector prefixes
       */
      prefixeds(rule) {
        if (rule._autoprefixerPrefixeds) {
          if (rule._autoprefixerPrefixeds[this.name]) {
            return rule._autoprefixerPrefixeds;
          }
        } else {
          rule._autoprefixerPrefixeds = {};
        }
        let prefixeds = {};
        if (rule.selector.includes(",")) {
          let ruleParts = list.comma(rule.selector);
          let toProcess = ruleParts.filter((el) => el.includes(this.name));
          for (let prefix of this.possible()) {
            prefixeds[prefix] = toProcess.map((el) => this.replace(el, prefix)).join(", ");
          }
        } else {
          for (let prefix of this.possible()) {
            prefixeds[prefix] = this.replace(rule.selector, prefix);
          }
        }
        rule._autoprefixerPrefixeds[this.name] = prefixeds;
        return rule._autoprefixerPrefixeds;
      }
      /**
       * Lazy loadRegExp for name
       */
      regexp(prefix) {
        if (!this.regexpCache.has(prefix)) {
          let name = prefix ? this.prefixed(prefix) : this.name;
          this.regexpCache.set(
            prefix,
            new RegExp(`(^|[^:"'=])${utils.escapeRegexp(name)}`, "gi")
          );
        }
        return this.regexpCache.get(prefix);
      }
      /**
       * Replace selectors by prefixed one
       */
      replace(selector, prefix) {
        return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`);
      }
    };
    module2.exports = Selector;
  }
});

// node_modules/autoprefixer/lib/at-rule.js
var require_at_rule2 = __commonJS({
  "node_modules/autoprefixer/lib/at-rule.js"(exports2, module2) {
    var Prefixer = require_prefixer();
    var AtRule = class extends Prefixer {
      /**
       * Clone and add prefixes for at-rule
       */
      add(rule, prefix) {
        let prefixed = prefix + rule.name;
        let already = rule.parent.some(
          (i) => i.name === prefixed && i.params === rule.params
        );
        if (already) {
          return void 0;
        }
        let cloned = this.clone(rule, { name: prefixed });
        return rule.parent.insertBefore(rule, cloned);
      }
      /**
       * Clone node with prefixes
       */
      process(node) {
        let parent = this.parentPrefix(node);
        for (let prefix of this.prefixes) {
          if (!parent || parent === prefix) {
            this.add(node, prefix);
          }
        }
      }
    };
    module2.exports = AtRule;
  }
});

// node_modules/autoprefixer/lib/hacks/fullscreen.js
var require_fullscreen = __commonJS({
  "node_modules/autoprefixer/lib/hacks/fullscreen.js"(exports2, module2) {
    var Selector = require_selector();
    var Fullscreen = class extends Selector {
      /**
       * Return different selectors depend on prefix
       */
      prefixed(prefix) {
        if (prefix === "-webkit-") {
          return ":-webkit-full-screen";
        }
        if (prefix === "-moz-") {
          return ":-moz-full-screen";
        }
        return `:${prefix}fullscreen`;
      }
    };
    Fullscreen.names = [":fullscreen"];
    module2.exports = Fullscreen;
  }
});

// node_modules/autoprefixer/lib/hacks/placeholder.js
var require_placeholder = __commonJS({
  "node_modules/autoprefixer/lib/hacks/placeholder.js"(exports2, module2) {
    var Selector = require_selector();
    var Placeholder = class extends Selector {
      /**
       * Add old mozilla to possible prefixes
       */
      possible() {
        return super.possible().concat(["-moz- old", "-ms- old"]);
      }
      /**
       * Return different selectors depend on prefix
       */
      prefixed(prefix) {
        if (prefix === "-webkit-") {
          return "::-webkit-input-placeholder";
        }
        if (prefix === "-ms-") {
          return "::-ms-input-placeholder";
        }
        if (prefix === "-ms- old") {
          return ":-ms-input-placeholder";
        }
        if (prefix === "-moz- old") {
          return ":-moz-placeholder";
        }
        return `::${prefix}placeholder`;
      }
    };
    Placeholder.names = ["::placeholder"];
    module2.exports = Placeholder;
  }
});

// node_modules/autoprefixer/lib/hacks/placeholder-shown.js
var require_placeholder_shown = __commonJS({
  "node_modules/autoprefixer/lib/hacks/placeholder-shown.js"(exports2, module2) {
    var Selector = require_selector();
    var PlaceholderShown = class extends Selector {
      /**
       * Return different selectors depend on prefix
       */
      prefixed(prefix) {
        if (prefix === "-ms-") {
          return ":-ms-input-placeholder";
        }
        return `:${prefix}placeholder-shown`;
      }
    };
    PlaceholderShown.names = [":placeholder-shown"];
    module2.exports = PlaceholderShown;
  }
});

// node_modules/autoprefixer/lib/hacks/file-selector-button.js
var require_file_selector_button = __commonJS({
  "node_modules/autoprefixer/lib/hacks/file-selector-button.js"(exports2, module2) {
    var Selector = require_selector();
    var utils = require_utils();
    var FileSelectorButton = class extends Selector {
      constructor(name, prefixes, all) {
        super(name, prefixes, all);
        if (this.prefixes) {
          this.prefixes = utils.uniq(this.prefixes.map(() => "-webkit-"));
        }
      }
      /**
       * Return different selectors depend on prefix
       */
      prefixed(prefix) {
        if (prefix === "-webkit-") {
          return "::-webkit-file-upload-button";
        }
        return `::${prefix}file-selector-button`;
      }
    };
    FileSelectorButton.names = ["::file-selector-button"];
    module2.exports = FileSelectorButton;
  }
});

// node_modules/autoprefixer/lib/hacks/flex-spec.js
var require_flex_spec = __commonJS({
  "node_modules/autoprefixer/lib/hacks/flex-spec.js"(exports2, module2) {
    module2.exports = function(prefix) {
      let spec;
      if (prefix === "-webkit- 2009" || prefix === "-moz-") {
        spec = 2009;
      } else if (prefix === "-ms-") {
        spec = 2012;
      } else if (prefix === "-webkit-") {
        spec = "final";
      }
      if (prefix === "-webkit- 2009") {
        prefix = "-webkit-";
      }
      return [spec, prefix];
    };
  }
});

// node_modules/autoprefixer/lib/hacks/flex.js
var require_flex = __commonJS({
  "node_modules/autoprefixer/lib/hacks/flex.js"(exports2, module2) {
    var list = require_postcss().list;
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration2();
    var Flex = class _Flex extends Declaration {
      /**
       * Return property name by final spec
       */
      normalize() {
        return "flex";
      }
      /**
       * Change property name for 2009 spec
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2009) {
          return prefix + "box-flex";
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Spec 2009 supports only first argument
       * Spec 2012 disallows unitless basis
       */
      set(decl, prefix) {
        let spec = flexSpec(prefix)[0];
        if (spec === 2009) {
          decl.value = list.space(decl.value)[0];
          decl.value = _Flex.oldValues[decl.value] || decl.value;
          return super.set(decl, prefix);
        }
        if (spec === 2012) {
          let components = list.space(decl.value);
          if (components.length === 3 && components[2] === "0") {
            decl.value = components.slice(0, 2).concat("0px").join(" ");
          }
        }
        return super.set(decl, prefix);
      }
    };
    Flex.names = ["flex", "box-flex"];
    Flex.oldValues = {
      auto: "1",
      none: "0"
    };
    module2.exports = Flex;
  }
});

// node_modules/autoprefixer/lib/hacks/order.js
var require_order = __commonJS({
  "node_modules/autoprefixer/lib/hacks/order.js"(exports2, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration2();
    var Order = class extends Declaration {
      /**
       * Return property name by final spec
       */
      normalize() {
        return "order";
      }
      /**
       * Change property name for 2009 and 2012 specs
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2009) {
          return prefix + "box-ordinal-group";
        }
        if (spec === 2012) {
          return prefix + "flex-order";
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Fix value for 2009 spec
       */
      set(decl, prefix) {
        let spec = flexSpec(prefix)[0];
        if (spec === 2009 && /\d/.test(decl.value)) {
          decl.value = (parseInt(decl.value) + 1).toString();
          return super.set(decl, prefix);
        }
        return super.set(decl, prefix);
      }
    };
    Order.names = ["order", "flex-order", "box-ordinal-group"];
    module2.exports = Order;
  }
});

// node_modules/autoprefixer/lib/hacks/filter.js
var require_filter = __commonJS({
  "node_modules/autoprefixer/lib/hacks/filter.js"(exports2, module2) {
    var Declaration = require_declaration2();
    var Filter = class extends Declaration {
      /**
       * Check is it Internet Explorer filter
       */
      check(decl) {
        let v = decl.value;
        return !v.toLowerCase().includes("alpha(") && !v.includes("DXImageTransform.Microsoft") && !v.includes("data:image/svg+xml");
      }
    };
    Filter.names = ["filter"];
    module2.exports = Filter;
  }
});

// node_modules/autoprefixer/lib/hacks/grid-end.js
var require_grid_end = __commonJS({
  "node_modules/autoprefixer/lib/hacks/grid-end.js"(exports2, module2) {
    var Declaration = require_declaration2();
    var { isPureNumber } = require_utils();
    var GridEnd = class extends Declaration {
      /**
       * Change repeating syntax for IE
       */
      insert(decl, prefix, prefixes, result) {
        if (prefix !== "-ms-") return super.insert(decl, prefix, prefixes);
        let clonedDecl = this.clone(decl);
        let startProp = decl.prop.replace(/end$/, "start");
        let spanProp = prefix + decl.prop.replace(/end$/, "span");
        if (decl.parent.some((i) => i.prop === spanProp)) {
          return void 0;
        }
        clonedDecl.prop = spanProp;
        if (decl.value.includes("span")) {
          clonedDecl.value = decl.value.replace(/span\s/i, "");
        } else {
          let startDecl;
          decl.parent.walkDecls(startProp, (d) => {
            startDecl = d;
          });
          if (startDecl) {
            if (isPureNumber(startDecl.value)) {
              let value = Number(decl.value) - Number(startDecl.value) + "";
              clonedDecl.value = value;
            } else {
              return void 0;
            }
          } else {
            decl.warn(
              result,
              `Can not prefix ${decl.prop} (${startProp} is not found)`
            );
          }
        }
        decl.cloneBefore(clonedDecl);
        return void 0;
      }
    };
    GridEnd.names = ["grid-row-end", "grid-column-end"];
    module2.exports = GridEnd;
  }
});

// node_modules/autoprefixer/lib/hacks/animation.js
var require_animation = __commonJS({
  "node_modules/autoprefixer/lib/hacks/animation.js"(exports2, module2) {
    var Declaration = require_declaration2();
    var Animation = class extends Declaration {
      /**
       * Donâ€™t add prefixes for modern values.
       */
      check(decl) {
        return !decl.value.split(/\s+/).some((i) => {
          let lower = i.toLowerCase();
          return lower === "reverse" || lower === "alternate-reverse";
        });
      }
    };
    Animation.names = ["animation", "animation-direction"];
    module2.exports = Animation;
  }
});

// node_modules/autoprefixer/lib/hacks/flex-flow.js
var require_flex_flow = __commonJS({
  "node_modules/autoprefixer/lib/hacks/flex-flow.js"(exports2, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration2();
    var FlexFlow = class extends Declaration {
      /**
       * Use two properties for 2009 spec
       */
      insert(decl, prefix, prefixes) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec !== 2009) {
          return super.insert(decl, prefix, prefixes);
        }
        let values = decl.value.split(/\s+/).filter((i) => i !== "wrap" && i !== "nowrap" && "wrap-reverse");
        if (values.length === 0) {
          return void 0;
        }
        let already = decl.parent.some(
          (i) => i.prop === prefix + "box-orient" || i.prop === prefix + "box-direction"
        );
        if (already) {
          return void 0;
        }
        let value = values[0];
        let orient = value.includes("row") ? "horizontal" : "vertical";
        let dir = value.includes("reverse") ? "reverse" : "normal";
        let cloned = this.clone(decl);
        cloned.prop = prefix + "box-orient";
        cloned.value = orient;
        if (this.needCascade(decl)) {
          cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
        }
        decl.parent.insertBefore(decl, cloned);
        cloned = this.clone(decl);
        cloned.prop = prefix + "box-direction";
        cloned.value = dir;
        if (this.needCascade(decl)) {
          cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
        }
        return decl.parent.insertBefore(decl, cloned);
      }
    };
    FlexFlow.names = ["flex-flow", "box-direction", "box-orient"];
    module2.exports = FlexFlow;
  }
});

// node_modules/autoprefixer/lib/hacks/flex-grow.js
var require_flex_grow = __commonJS({
  "node_modules/autoprefixer/lib/hacks/flex-grow.js"(exports2, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration2();
    var Flex = class extends Declaration {
      /**
       * Return property name by final spec
       */
      normalize() {
        return "flex";
      }
      /**
       * Return flex property for 2009 and 2012 specs
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2009) {
          return prefix + "box-flex";
        }
        if (spec === 2012) {
          return prefix + "flex-positive";
        }
        return super.prefixed(prop, prefix);
      }
    };
    Flex.names = ["flex-grow", "flex-positive"];
    module2.exports = Flex;
  }
});

// node_modules/autoprefixer/lib/hacks/flex-wrap.js
var require_flex_wrap = __commonJS({
  "node_modules/autoprefixer/lib/hacks/flex-wrap.js"(exports2, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration2();
    var FlexWrap = class extends Declaration {
      /**
       * Don't add prefix for 2009 spec
       */
      set(decl, prefix) {
        let spec = flexSpec(prefix)[0];
        if (spec !== 2009) {
          return super.set(decl, prefix);
        }
        return void 0;
      }
    };
    FlexWrap.names = ["flex-wrap"];
    module2.exports = FlexWrap;
  }
});

// node_modules/autoprefixer/lib/hacks/grid-area.js
var require_grid_area = __commonJS({
  "node_modules/autoprefixer/lib/hacks/grid-area.js"(exports2, module2) {
    var Declaration = require_declaration2();
    var utils = require_grid_utils();
    var GridArea = class extends Declaration {
      /**
       * Translate grid-area to separate -ms- prefixed properties
       */
      insert(decl, prefix, prefixes, result) {
        if (prefix !== "-ms-") return super.insert(decl, prefix, prefixes);
        let values = utils.parse(decl);
        let [rowStart, rowSpan] = utils.translate(values, 0, 2);
        let [columnStart, columnSpan] = utils.translate(values, 1, 3);
        [
          ["grid-row", rowStart],
          ["grid-row-span", rowSpan],
          ["grid-column", columnStart],
          ["grid-column-span", columnSpan]
        ].forEach(([prop, value]) => {
          utils.insertDecl(decl, prop, value);
        });
        utils.warnTemplateSelectorNotFound(decl, result);
        utils.warnIfGridRowColumnExists(decl, result);
        return void 0;
      }
    };
    GridArea.names = ["grid-area"];
    module2.exports = GridArea;
  }
});

// node_modules/autoprefixer/lib/hacks/place-self.js
var require_place_self = __commonJS({
  "node_modules/autoprefixer/lib/hacks/place-self.js"(exports2, module2) {
    var Declaration = require_declaration2();
    var utils = require_grid_utils();
    var PlaceSelf = class extends Declaration {
      /**
       * Translate place-self to separate -ms- prefixed properties
       */
      insert(decl, prefix, prefixes) {
        if (prefix !== "-ms-") return super.insert(decl, prefix, prefixes);
        if (decl.parent.some((i) => i.prop === "-ms-grid-row-align")) {
          return void 0;
        }
        let [[first, second]] = utils.parse(decl);
        if (second) {
          utils.insertDecl(decl, "grid-row-align", first);
          utils.insertDecl(decl, "grid-column-align", second);
        } else {
          utils.insertDecl(decl, "grid-row-align", first);
          utils.insertDecl(decl, "grid-column-align", first);
        }
        return void 0;
      }
    };
    PlaceSelf.names = ["place-self"];
    module2.exports = PlaceSelf;
  }
});

// node_modules/autoprefixer/lib/hacks/grid-start.js
var require_grid_start = __commonJS({
  "node_modules/autoprefixer/lib/hacks/grid-start.js"(exports2, module2) {
    var Declaration = require_declaration2();
    var GridStart = class extends Declaration {
      /**
       * Do not add prefix for unsupported value in IE
       */
      check(decl) {
        let value = decl.value;
        return !value.includes("/") && !value.includes("span");
      }
      /**
       * Return a final spec property
       */
      normalize(prop) {
        return prop.replace("-start", "");
      }
      /**
       * Change property name for IE
       */
      prefixed(prop, prefix) {
        let result = super.prefixed(prop, prefix);
        if (prefix === "-ms-") {
          result = result.replace("-start", "");
        }
        return result;
      }
    };
    GridStart.names = ["grid-row-start", "grid-column-start"];
    module2.exports = GridStart;
  }
});

// node_modules/autoprefixer/lib/hacks/align-self.js
var require_align_self = __commonJS({
  "node_modules/autoprefixer/lib/hacks/align-self.js"(exports2, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration2();
    var AlignSelf = class _AlignSelf extends Declaration {
      check(decl) {
        return decl.parent && !decl.parent.some((i) => {
          return i.prop && i.prop.startsWith("grid-");
        });
      }
      /**
       * Return property name by final spec
       */
      normalize() {
        return "align-self";
      }
      /**
       * Change property name for 2012 specs
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2012) {
          return prefix + "flex-item-align";
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Change value for 2012 spec and ignore prefix for 2009
       */
      set(decl, prefix) {
        let spec = flexSpec(prefix)[0];
        if (spec === 2012) {
          decl.value = _AlignSelf.oldValues[decl.value] || decl.value;
          return super.set(decl, prefix);
        }
        if (spec === "final") {
          return super.set(decl, prefix);
        }
        return void 0;
      }
    };
    AlignSelf.names = ["align-self", "flex-item-align"];
    AlignSelf.oldValues = {
      "flex-end": "end",
      "flex-start": "start"
    };
    module2.exports = AlignSelf;
  }
});

// node_modules/autoprefixer/lib/hacks/appearance.js
var require_appearance = __commonJS({
  "node_modules/autoprefixer/lib/hacks/appearance.js"(exports2, module2) {
    var Declaration = require_declaration2();
    var utils = require_utils();
    var Appearance = class extends Declaration {
      constructor(name, prefixes, all) {
        super(name, prefixes, all);
        if (this.prefixes) {
          this.prefixes = utils.uniq(
            this.prefixes.map((i) => {
              if (i === "-ms-") {
                return "-webkit-";
              }
              return i;
            })
          );
        }
      }
    };
    Appearance.names = ["appearance"];
    module2.exports = Appearance;
  }
});

// node_modules/autoprefixer/lib/hacks/flex-basis.js
var require_flex_basis = __commonJS({
  "node_modules/autoprefixer/lib/hacks/flex-basis.js"(exports2, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration2();
    var FlexBasis = class extends Declaration {
      /**
       * Return property name by final spec
       */
      normalize() {
        return "flex-basis";
      }
      /**
       * Return flex property for 2012 spec
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2012) {
          return prefix + "flex-preferred-size";
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Ignore 2009 spec and use flex property for 2012
       */
      set(decl, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2012 || spec === "final") {
          return super.set(decl, prefix);
        }
        return void 0;
      }
    };
    FlexBasis.names = ["flex-basis", "flex-preferred-size"];
    module2.exports = FlexBasis;
  }
});

// node_modules/autoprefixer/lib/hacks/mask-border.js
var require_mask_border = __commonJS({
  "node_modules/autoprefixer/lib/hacks/mask-border.js"(exports2, module2) {
    var Declaration = require_declaration2();
    var MaskBorder = class extends Declaration {
      /**
       * Return property name by final spec
       */
      normalize() {
        return this.name.replace("box-image", "border");
      }
      /**
       * Return flex property for 2012 spec
       */
      prefixed(prop, prefix) {
        let result = super.prefixed(prop, prefix);
        if (prefix === "-webkit-") {
          result = result.replace("border", "box-image");
        }
        return result;
      }
    };
    MaskBorder.names = [
      "mask-border",
      "mask-border-source",
      "mask-border-slice",
      "mask-border-width",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-box-image",
      "mask-box-image-source",
      "mask-box-image-slice",
      "mask-box-image-width",
      "mask-box-image-outset",
      "mask-box-image-repeat"
    ];
    module2.exports = MaskBorder;
  }
});

// node_modules/autoprefixer/lib/hacks/mask-composite.js
var require_mask_composite = __commonJS({
  "node_modules/autoprefixer/lib/hacks/mask-composite.js"(exports2, module2) {
    var Declaration = require_declaration2();
    var MaskComposite = class _MaskComposite extends Declaration {
      /**
       * Prefix mask-composite for webkit
       */
      insert(decl, prefix, prefixes) {
        let isCompositeProp = decl.prop === "mask-composite";
        let compositeValues;
        if (isCompositeProp) {
          compositeValues = decl.value.split(",");
        } else {
          compositeValues = decl.value.match(_MaskComposite.regexp) || [];
        }
        compositeValues = compositeValues.map((el) => el.trim()).filter((el) => el);
        let hasCompositeValues = compositeValues.length;
        let compositeDecl;
        if (hasCompositeValues) {
          compositeDecl = this.clone(decl);
          compositeDecl.value = compositeValues.map((value) => _MaskComposite.oldValues[value] || value).join(", ");
          if (compositeValues.includes("intersect")) {
            compositeDecl.value += ", xor";
          }
          compositeDecl.prop = prefix + "mask-composite";
        }
        if (isCompositeProp) {
          if (!hasCompositeValues) {
            return void 0;
          }
          if (this.needCascade(decl)) {
            compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix);
          }
          return decl.parent.insertBefore(decl, compositeDecl);
        }
        let cloned = this.clone(decl);
        cloned.prop = prefix + cloned.prop;
        if (hasCompositeValues) {
          cloned.value = cloned.value.replace(_MaskComposite.regexp, "");
        }
        if (this.needCascade(decl)) {
          cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
        }
        decl.parent.insertBefore(decl, cloned);
        if (!hasCompositeValues) {
          return decl;
        }
        if (this.needCascade(decl)) {
          compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix);
        }
        return decl.parent.insertBefore(decl, compositeDecl);
      }
    };
    MaskComposite.names = ["mask", "mask-composite"];
    MaskComposite.oldValues = {
      add: "source-over",
      exclude: "xor",
      intersect: "source-in",
      subtract: "source-out"
    };
    MaskComposite.regexp = new RegExp(
      `\\s+(${Object.keys(MaskComposite.oldValues).join(
        "|"
      )})\\b(?!\\))\\s*(?=[,])`,
      "ig"
    );
    module2.exports = MaskComposite;
  }
});

// node_modules/autoprefixer/lib/hacks/align-items.js
var require_align_items = __commonJS({
  "node_modules/autoprefixer/lib/hacks/align-items.js"(exports2, modul                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    'use strict';

module.exports = {
	abs: {
		url: 'https://262.ecma-international.org/11.0/#eqn-abs'
	},
	'Abstract Equality Comparison': {
		url: 'https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison'
	},
	'Abstract Relational Comparison': {
		url: 'https://262.ecma-international.org/11.0/#sec-abstract-relational-comparison'
	},
	AddEntriesFromIterable: {
		url: 'https://262.ecma-international.org/11.0/#sec-add-entries-from-iterable'
	},
	AddRestrictedFunctionProperties: {
		url: 'https://262.ecma-international.org/11.0/#sec-addrestrictedfunctionproperties'
	},
	AddWaiter: {
		url: 'https://262.ecma-international.org/11.0/#sec-addwaiter'
	},
	AdvanceStringIndex: {
		url: 'https://262.ecma-international.org/11.0/#sec-advancestringindex'
	},
	'agent-order': {
		url: 'https://262.ecma-international.org/11.0/#sec-agent-order'
	},
	AgentCanSuspend: {
		url: 'https://262.ecma-international.org/11.0/#sec-agentcansuspend'
	},
	AgentSignifier: {
		url: 'https://262.ecma-international.org/11.0/#sec-agentsignifier'
	},
	AllocateArrayBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-allocatearraybuffer'
	},
	AllocateSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-allocatesharedarraybuffer'
	},
	AllocateTypedArray: {
		url: 'https://262.ecma-international.org/11.0/#sec-allocatetypedarray'
	},
	AllocateTypedArrayBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-allocatetypedarraybuffer'
	},
	ArrayCreate: {
		url: 'https://262.ecma-international.org/11.0/#sec-arraycreate'
	},
	ArraySetLength: {
		url: 'https://262.ecma-international.org/11.0/#sec-arraysetlength'
	},
	ArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/11.0/#sec-arrayspeciescreate'
	},
	AsyncFromSyncIteratorContinuation: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncfromsynciteratorcontinuation'
	},
	AsyncFunctionStart: {
		url: 'https://262.ecma-international.org/11.0/#sec-async-functions-abstract-operations-async-function-start'
	},
	AsyncGeneratorEnqueue: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncgeneratorenqueue'
	},
	AsyncGeneratorReject: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncgeneratorreject'
	},
	AsyncGeneratorResolve: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncgeneratorresolve'
	},
	AsyncGeneratorResumeNext: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncgeneratorresumenext'
	},
	AsyncGeneratorStart: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncgeneratorstart'
	},
	AsyncGeneratorYield: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncgeneratoryield'
	},
	AsyncIteratorClose: {
		url: 'https://262.ecma-international.org/11.0/#sec-asynciteratorclose'
	},
	AtomicLoad: {
		url: 'https://262.ecma-international.org/11.0/#sec-atomicload'
	},
	AtomicReadModifyWrite: {
		url: 'https://262.ecma-international.org/11.0/#sec-atomicreadmodifywrite'
	},
	Await: {
		url: 'https://262.ecma-international.org/11.0/#await'
	},
	BackreferenceMatcher: {
		url: 'https://262.ecma-international.org/11.0/#sec-backreference-matcher'
	},
	'BigInt::add': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-add'
	},
	'BigInt::bitwiseAND': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-bitwiseAND'
	},
	'BigInt::bitwiseNOT': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-bitwiseNOT'
	},
	'BigInt::bitwiseOR': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-bitwiseOR'
	},
	'BigInt::bitwiseXOR': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-bitwiseXOR'
	},
	'BigInt::divide': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-divide'
	},
	'BigInt::equal': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-equal'
	},
	'BigInt::exponentiate': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-exponentiate'
	},
	'BigInt::leftShift': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-leftShift'
	},
	'BigInt::lessThan': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-lessThan'
	},
	'BigInt::multiply': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-multiply'
	},
	'BigInt::remainder': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-remainder'
	},
	'BigInt::sameValue': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-sameValue'
	},
	'BigInt::sameValueZero': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-sameValueZero'
	},
	'BigInt::signedRightShift': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-signedRightShift'
	},
	'BigInt::subtract': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-subtract'
	},
	'BigInt::toString': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-tostring'
	},
	'BigInt::unaryMinus': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-unaryMinus'
	},
	'BigInt::unsignedRightShift': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-unsignedRightShift'
	},
	BigIntBitwiseOp: {
		url: 'https://262.ecma-international.org/11.0/#sec-bigintbitwiseop'
	},
	BinaryAnd: {
		url: 'https://262.ecma-international.org/11.0/#sec-binaryand'
	},
	BinaryOr: {
		url: 'https://262.ecma-international.org/11.0/#sec-binaryor'
	},
	BinaryXor: {
		url: 'https://262.ecma-international.org/11.0/#sec-binaryxor'
	},
	BlockDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/11.0/#sec-blockdeclarationinstantiation'
	},
	BoundFunctionCreate: {
		url: 'https://262.ecma-international.org/11.0/#sec-boundfunctioncreate'
	},
	Call: {
		url: 'https://262.ecma-international.org/11.0/#sec-call'
	},
	Canonicalize: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-canonicalize-ch'
	},
	CanonicalNumericIndexString: {
		url: 'https://262.ecma-international.org/11.0/#sec-canonicalnumericindexstring'
	},
	CaseClauseIsSelected: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-caseclauseisselected'
	},
	CharacterRange: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-characterrange-abstract-operation'
	},
	CharacterRangeOrUnion: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-characterrangeorunion-abstract-operation'
	},
	CharacterSetMatcher: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-charactersetmatcher-abstract-operation'
	},
	CloneArrayBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-clonearraybuffer'
	},
	CodePointAt: {
		url: 'https://262.ecma-international.org/11.0/#sec-codepointat'
	},
	CompletePropertyDescriptor: {
		url: 'https://262.ecma-international.org/11.0/#sec-completepropertydescriptor'
	},
	Completion: {
		url: 'https://262.ecma-international.org/11.0/#sec-completion-record-specification-type'
	},
	CompletionRecord: {
		url: 'https://262.ecma-international.org/11.0/#sec-completion-record-specification-type'
	},
	ComposeWriteEventBytes: {
		url: 'https://262.ecma-international.org/11.0/#sec-composewriteeventbytes'
	},
	Construct: {
		url: 'https://262.ecma-international.org/11.0/#sec-construct'
	},
	CopyDataBlockBytes: {
		url: 'https://262.ecma-international.org/11.0/#sec-copydatablockbytes'
	},
	CopyDataProperties: {
		url: 'https://262.ecma-international.org/11.0/#sec-copydataproperties'
	},
	CreateArrayFromList: {
		url: 'https://262.ecma-international.org/11.0/#sec-createarrayfromlist'
	},
	CreateArrayIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createarrayiterator'
	},
	CreateAsyncFromSyncIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createasyncfromsynciterator'
	},
	CreateBuiltinFunction: {
		url: 'https://262.ecma-international.org/11.0/#sec-createbuiltinfunction'
	},
	CreateByteDataBlock: {
		url: 'https://262.ecma-international.org/11.0/#sec-createbytedatablock'
	},
	CreateDataProperty: {
		url: 'https://262.ecma-international.org/11.0/#sec-createdataproperty'
	},
	CreateDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/11.0/#sec-createdatapropertyorthrow'
	},
	CreateDynamicFunction: {
		url: 'https://262.ecma-international.org/11.0/#sec-createdynamicfunction'
	},
	CreateForInIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createforiniterator'
	},
	CreateHTML: {
		url: 'https://262.ecma-international.org/11.0/#sec-createhtml'
	},
	CreateIntrinsics: {
		url: 'https://262.ecma-international.org/11.0/#sec-createintrinsics'
	},
	CreateIterResultObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-createiterresultobject'
	},
	CreateListFromArrayLike: {
		url: 'https://262.ecma-international.org/11.0/#sec-createlistfromarraylike'
	},
	CreateListIteratorRecord: {
		url: 'https://262.ecma-international.org/11.0/#sec-createlistiteratorRecord'
	},
	CreateMapIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createmapiterator'
	},
	CreateMappedArgumentsObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-createmappedargumentsobject'
	},
	CreateMethodProperty: {
		url: 'https://262.ecma-international.org/11.0/#sec-createmethodproperty'
	},
	CreatePerIterationEnvironment: {
		url: 'https://262.ecma-international.org/11.0/#sec-createperiterationenvironment'
	},
	CreateRealm: {
		url: 'https://262.ecma-international.org/11.0/#sec-createrealm'
	},
	CreateRegExpStringIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createregexpstringiterator'
	},
	CreateResolvingFunctions: {
		url: 'https://262.ecma-international.org/11.0/#sec-createresolvingfunctions'
	},
	CreateSetIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createsetiterator'
	},
	CreateSharedByteDataBlock: {
		url: 'https://262.ecma-international.org/11.0/#sec-createsharedbytedatablock'
	},
	CreateStringIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createstringiterator'
	},
	CreateUnmappedArgumentsObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-createunmappedargumentsobject'
	},
	DateFromTime: {
		url: 'https://262.ecma-international.org/11.0/#sec-date-number'
	},
	DateString: {
		url: 'https://262.ecma-international.org/11.0/#sec-datestring'
	},
	Day: {
		url: 'https://262.ecma-international.org/11.0/#eqn-Day'
	},
	DayFromYear: {
		url: 'https://262.ecma-international.org/11.0/#eqn-DaysFromYear'
	},
	DaysInYear: {
		url: 'https://262.ecma-international.org/11.0/#eqn-DaysInYear'
	},
	DayWithinYear: {
		url: 'https://262.ecma-international.org/11.0/#eqn-DayWithinYear'
	},
	Decode: {
		url: 'https://262.ecma-international.org/11.0/#sec-decode'
	},
	DefinePropertyOrThrow: {
		url: 'https://262.ecma-international.org/11.0/#sec-definepropertyorthrow'
	},
	DeletePropertyOrThrow: {
		url: 'https://262.ecma-international.org/11.0/#sec-deletepropertyorthrow'
	},
	DetachArrayBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-detacharraybuffer'
	},
	Encode: {
		url: 'https://262.ecma-international.org/11.0/#sec-encode'
	},
	EnterCriticalSection: {
		url: 'https://262.ecma-international.org/11.0/#sec-entercriticalsection'
	},
	EnumerableOwnPropertyNames: {
		url: 'https://262.ecma-international.org/11.0/#sec-enumerableownpropertynames'
	},
	EnumerateObjectProperties: {
		url: 'https://262.ecma-international.org/11.0/#sec-enumerate-object-properties'
	},
	EscapeRegExpPattern: {
		url: 'https://262.ecma-international.org/11.0/#sec-escaperegexppattern'
	},
	EvalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/11.0/#sec-evaldeclarationinstantiation'
	},
	EvaluateCall: {
		url: 'https://262.ecma-international.org/11.0/#sec-evaluatecall'
	},
	EvaluateNew: {
		url: 'https://262.ecma-international.org/11.0/#sec-evaluatenew'
	},
	EvaluatePropertyAccessWithExpressionKey: {
		url: 'https://262.ecma-international.org/11.0/#sec-evaluate-property-access-with-expression-key'
	},
	EvaluatePropertyAccessWithIdentifierKey: {
		url: 'https://262.ecma-international.org/11.0/#sec-evaluate-property-access-with-identifier-key'
	},
	EventSet: {
		url: 'https://262.ecma-international.org/11.0/#sec-event-set'
	},
	ExecuteModule: {
		url: 'https://262.ecma-international.org/11.0/#sec-source-text-module-record-execute-module'
	},
	FinishDynamicImport: {
		url: 'https://262.ecma-international.org/11.0/#sec-finishdynamicimport'
	},
	FlattenIntoArray: {
		url: 'https://262.ecma-international.org/11.0/#sec-flattenintoarray'
	},
	floor: {
		url: 'https://262.ecma-international.org/11.0/#eqn-floor'
	},
	ForBodyEvaluation: {
		url: 'https://262.ecma-international.org/11.0/#sec-forbodyevaluation'
	},
	'ForIn/OfBodyEvaluation': {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset'
	},
	'ForIn/OfHeadEvaluation': {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-forinofheadevaluation'
	},
	FromPropertyDescriptor: {
		url: 'https://262.ecma-international.org/11.0/#sec-frompropertydescriptor'
	},
	FulfillPromise: {
		url: 'https://262.ecma-international.org/11.0/#sec-fulfillpromise'
	},
	FunctionDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/11.0/#sec-functiondeclarationinstantiation'
	},
	GeneratorResume: {
		url: 'https://262.ecma-international.org/11.0/#sec-generatorresume'
	},
	GeneratorResumeAbrupt: {
		url: 'https://262.ecma-international.org/11.0/#sec-generatorresumeabrupt'
	},
	GeneratorStart: {
		url: 'https://262.ecma-international.org/11.0/#sec-generatorstart'
	},
	GeneratorValidate: {
		url: 'https://262.ecma-international.org/11.0/#sec-generatorvalidate'
	},
	GeneratorYield: {
		url: 'https://262.ecma-international.org/11.0/#sec-generatoryield'
	},
	Get: {
		url: 'https://262.ecma-international.org/11.0/#sec-get-o-p'
	},
	GetActiveScriptOrModule: {
		url: 'https://262.ecma-international.org/11.0/#sec-getactivescriptormodule'
	},
	GetBase: {
		url: 'https://262.ecma-international.org/11.0/#sec-getbase'
	},
	GetFunctionRealm: {
		url: 'https://262.ecma-international.org/11.0/#sec-getfunctionrealm'
	},
	GetGeneratorKind: {
		url: 'https://262.ecma-international.org/11.0/#sec-getgeneratorkind'
	},
	GetGlobalObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-getglobalobject'
	},
	GetIdentifierReference: {
		url: 'https://262.ecma-international.org/11.0/#sec-getidentifierreference'
	},
	GetIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-getiterator'
	},
	GetMethod: {
		url: 'https://262.ecma-international.org/11.0/#sec-getmethod'
	},
	GetModifySetValueInBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-getmodifysetvalueinbuffer'
	},
	GetModuleNamespace: {
		url: 'https://262.ecma-international.org/11.0/#sec-getmodulenamespace'
	},
	GetNewTarget: {
		url: 'https://262.ecma-international.org/11.0/#sec-getnewtarget'
	},
	GetOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/11.0/#sec-getownpropertykeys'
	},
	GetPrototypeFromConstructor: {
		url: 'https://262.ecma-international.org/11.0/#sec-getprototypefromconstructor'
	},
	GetReferencedName: {
		url: 'https://262.ecma-international.org/11.0/#sec-getreferencedname'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/11.0/#sec-getsubstitution'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/11.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/11.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-getthisvalue'
	},
	GetV: {
		url: 'https://262.ecma-international.org/11.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-getvaluefrombuffer'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-getviewvalue'
	},
	GetWaiterList: {
		url: 'https://262.ecma-international.org/11.0/#sec-getwaiterlist'
	},
	GlobalDeclarationInstantiation: {
		url: 'https://262.ecma-international.or