ion evaluates to a string.
 */
function isStringType(node) {
    return astUtils.isStringLiteral(node) ||
        (
            node.type === "CallExpression" &&
            node.callee.type === "Identifier" &&
            node.callee.name === "String"
        );
}

/**
 * Checks whether a node is an empty string literal or not.
 * @param {ASTNode} node The node to check.
 * @returns {boolean} Whether or not the passed in node is an
 * empty string literal or not.
 */
function isEmptyString(node) {
    return astUtils.isStringLiteral(node) && (node.value === "" || (node.type === "TemplateLiteral" && node.quasis.length === 1 && node.quasis[0].value.cooked === ""));
}

/**
 * Checks whether or not a node is a concatenating with an empty string.
 * @param {ASTNode} node A BinaryExpression node to check.
 * @returns {boolean} Whether or not the node is a concatenating with an empty string.
 */
function isConcatWithEmptyString(node) {
    return node.operator === "+" && (
        (isEmptyString(node.left) && !isStringType(node.right)) ||
        (isEmptyString(node.right) && !isStringType(node.left))
    );
}

/**
 * Checks whether or not a node is appended with an empty string.
 * @param {ASTNode} node An AssignmentExpression node to check.
 * @returns {boolean} Whether or not the node is appended with an empty string.
 */
function isAppendEmptyString(node) {
    return node.operator === "+=" && isEmptyString(node.right);
}

/**
 * Returns the operand that is not an empty string from a flagged BinaryExpression.
 * @param {ASTNode} node The flagged BinaryExpression node to check.
 * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.
 */
function getNonEmptyOperand(node) {
    return isEmptyString(node.left) ? node.right : node.left;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        hasSuggestions: true,
        type: "suggestion",

        docs: {
            description: "Disallow shorthand type conversions",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/no-implicit-coercion"
        },

        fixable: "code",

        schema: [{
            type: "object",
            properties: {
                boolean: {
                    type: "boolean"
                },
                number: {
                    type: "boolean"
                },
                string: {
                    type: "boolean"
                },
                disallowTemplateShorthand: {
                    type: "boolean"
                },
                allow: {
                    type: "array",
                    items: {
                        enum: ALLOWABLE_OPERATORS
                    },
                    uniqueItems: true
                }
            },
            additionalProperties: false
        }],

        defaultOptions: [{
            allow: [],
            boolean: true,
            disallowTemplateShorthand: false,
            number: true,
            string: true
        }],

        messages: {
            implicitCoercion: "Unexpected implicit coercion encountered. Use `{{recommendation}}` instead.",
            useRecommendation: "Use `{{recommendation}}` instead."
        }
    },

    create(context) {
        const [options] = context.options;
        const sourceCode = context.sourceCode;

        /**
         * Reports an error and autofixes the node
         * @param {ASTNode} node An ast node to report the error on.
         * @param {string} recommendation The recommended code for the issue
         * @param {bool} shouldSuggest Whether this report should offer a suggestion
         * @param {bool} shouldFix Whether this report should fix the node
         * @returns {void}
         */
        function report(node, recommendation, shouldSuggest, shouldFix) {

            /**
             * Fix function
             * @param {RuleFixer} fixer The fixer to fix.
             * @returns {Fix} The fix object.
             */
            function fix(fixer) {
                const tokenBefore = sourceCode.getTokenBefore(node);

                if (
                    tokenBefore?.range[1] === node.range[0] &&
                    !astUtils.canTokensBeAdjacent(tokenBefore, re