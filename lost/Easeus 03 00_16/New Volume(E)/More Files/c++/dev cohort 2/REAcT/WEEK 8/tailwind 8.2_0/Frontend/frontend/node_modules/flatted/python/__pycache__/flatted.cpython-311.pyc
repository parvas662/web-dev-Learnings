  {
                                messageId: "escapeBackslash",
                                fix(fixer) {
                                    return fixer.insertTextBeforeRange(range, "\\");
                                }
                            }
                        ]
                ]
            });
        }

        /**
         * Checks if the escape character in given string slice is unnecessary.
         * @private
         * @param {ASTNode} node node to validate.
         * @param {string} match string slice to validate.
         * @returns {void}
         */
        function validateString(node, match) {
            const isTemplateElement = node.type === "TemplateElement";
            const escapedChar = match[0][1];
            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);
            let isQuoteEscape;

            if (isTemplateElement) {
                isQuoteEscape = escapedChar === "`";

                if (escapedChar === "$") {

                    // Warn if `\$` is not followed by `{`
                    isUnnecessaryEscape = match.input[match.index + 2] !== "{";
                } else if (escapedChar === "{") {

                    /*
                     * Warn if `\{` is not preceded by `$`. If preceded by `$`, escaping
                     * is necessary and the rule should not warn. If preceded by `/$`, the rule
                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.
                     */
                    isUnnecessaryEscape = match.input[match.index - 1] !== "$";
                }
            } else {
                isQuoteEscape = escapedChar === node.raw[0];
            }

            if (isUnnecessaryEscape && !isQuoteEscape) {
                report(node, match.index, match[0].slice(1));
            }
        }

        /**
         * Checks if the escape character in given regexp is unnecessary.
         * @private
         * @param {ASTNode} node node to validate.
         * @returns {void}
         */
        function validateRegExp(node) {
            const { pattern, flags } = node.regex;
            let patternNode;
            const unicode = flags.includes("u");
            const unicodeSets = flags.includes("v");

            try {
                patternNode = parser.parsePattern(pattern, 0, pattern.length, { unicode, unicodeSets });
            } catch {

                // Ignore regular expressions with syntax errors
                return;
            }

            /** @type {(CharacterClass | ExpressionCharacterClass)[]} */
            const characterClassStack = [];

            visitRegExpAST(patternNode, {
                onCharacterClassEnter: characterClassNode => characterClassStack.unshift(characterClassNode),
                onCharacterClassLeave: () => characterClassStack.shift(),
                onExpressionCharacterClassEnter: characterClassNode => characterClassStack.unshift(characterClassNode),
                onExpressionCharacterClassLeave: () => characterClassStack.shift(),
                onCharacterEnter(characterNode) {
                    if (!characterNode.raw.startsWith("\\")) {

                        // It's not an escaped character.
                        return;
                    }

                    const escapedChar = characterNode.raw.slice(1);

                    if (escapedChar !== String.fromCodePoint(characterNode.value)) {

                        // It's a valid escape.
                        return;
                    }
                    let allowedEscapes;

                    if (characterClassStack.length) {
                        allowedEscapes = unicodeSets ? REGEX_CLASSSET_CHARACTER_ESCAPES : REGEX_GENERAL_ESCAPES;
                    } else {
                        allowedEscapes = REGEX_NON_CHARCLASS_ESCAPES;
                    }
                    if (allowedEscapes.has(escapedChar)) {
                        return;
                    }

                    const reportedIndex = characterNode.start + 1;
                    let disableEscapeBackslashSuggest = false;

                    if (characterClassStack.length) {
                        const characterClassNode = characterClassStack[0];

                        if (escapedChar === "^") {

                            /*
                             * The '^' character is also a special case; it must always be escaped outside of character classes, but
                             * it only needs to be escaped in character classes if it's at the beginning of the character class. To
                             * account for this, consider it to be a valid escape character outside of character classes, and filter
                             * out '^' characters that appear at the start of a character class.
                             */
                            if (characterClassNode.start + 1 === characterNode.start) {

                                return;
                            }
                        }
                        if (!unicodeSets) {
                            if (escapedChar === "-") {

                                /*
                                 * The '-' character is a special case, because it's only valid to escape it if it's in a character
                                 * class, and is not at either edge of the character class. To account for this, don't consider '-'
                                 * characters to be valid in general, and filter out '-' characters that appear in the middle of a
                                 * character class.
                                 */
                                if (characterClassNode.start + 1 !== characterNode.start && characterNode.end !== characterClassNode.end - 1) {

                                    return;
                                }
                            }
                        } else { // unicodeSets mode
                            if (REGEX_CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR.has(escapedChar)) {

                                // Escaping is valid if it is a ClassSetReservedDoublePunctuator.
                                if (pattern[characterNode.end] === escapedChar) {
                                    return;
                                }
                                if (pattern[characterNode.start - 1] === escapedChar) {
                                    if (escapedChar !== "^") {
                                        return;
                                    }

                                    // If the previous character is a `negate` caret(`^`), escape to caret is unnecessary.

                                 