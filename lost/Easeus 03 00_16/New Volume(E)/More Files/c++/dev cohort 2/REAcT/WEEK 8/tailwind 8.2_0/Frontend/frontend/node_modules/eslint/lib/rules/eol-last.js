ween environments and sets of content files.
   *
   * In order to make the order stable, we need to remap the arbitrary variant offsets to
   * be in alphabetical order starting from the offset of the first arbitrary variant.
   */ recalculateVariantOffsets() {
        // Sort the variants by their name
        let variants = Array.from(this.variantOffsets.entries()).filter(([v])=>v.startsWith("[")).sort(([a], [z])=>fastCompare(a, z));
        // Sort the list of offsets
        // This is not necessarily a discrete range of numbers which is why
        // we're using sort instead of creating a range from min/max
        let newOffsets = variants.map(([, offset])=>offset).sort((a, z)=>(0, _bigSign.default)(a - z));
        // Create a map from the old offsets to the new offsets in the new sort order
        /** @type {[bigint, bigint][]} */ let mapping = variants.map(([, oldOffset], i)=>[
                oldOffset,
                newOffsets[i]
            ]);
        // Remove any variants that will not move letting us skip
        // remapping if everything happens to be in order
        return mapping.filter(([a, z])=>a !== z);
    }
    /**
   * @template T
   * @param {[RuleOffset, T][]} list
   * @returns {[RuleOffset, T][]}
   */ remapArbitraryVariantOffsets(list) {
        let mapping = this.recalculateVariantOffsets();
        // No arbitrary variants? Nothing to do.
        // Everyhing already in order? Nothing to do.
        if (mapping.length === 0) {
            return list;
        }
        // Remap every variant offset in the list
        return list.map((item)=>{
            let [offset, rule] = item;
            offset = {
                ...offset,
                variants: (0, _remapbitfield.remapBitfield)(offset.variants, mapping)
            };
            return [
                offset,
                rule
            ];
        });
    }
    /**
   * @template T
   * @param {[RuleOffset, T][]} list
   * @returns {[RuleOffset, T][]}
   */ sortArbitraryProperties(list) {
        // Collect all known arbitrary properties
        let known = new Set();
        for (let [offset] of list){
            if (offset.arbitrary === 1n) {
                known.add(offset.property);
            }
        }
        // No arbitrary properties? Nothing to do.
        if (known.size === 0) {
            return list;
        }
        // Sort the properties alphabetically
        let properties = Array.from(known).sort();
        // Create a map from the property name to its offset
        let offsets = new Map();
        let offset = 1n;
        for (let property of properties){
            offsets.set(property, offset++);
        }
        // Apply the sorted offsets to the list
        return list.map((item)=>{
            let [offset, rule] = item;
            var _offsets_get;
            offset = {
                ...offset,
                propertyOffset: (_offsets_get = offsets.get(offset.property)) !== null && _offsets_get !== void 0 ? _offsets_get : 0n
            };
            return [
                offset,
                rule
            ];
        });
    }
    /**
   * @template T
   * @param {[RuleOffset, T][]} list
   * @returns {[RuleOffset, T][]}
   */ sort(list) {
        // Sort arbitrary variants so they're in alphabetical order
        list = this.remapArbitraryVariantOffsets(list);
        // Sort arbitrary properties so they're in alphabetical order
        list = this.sortArbitraryProperties(list);
        return list.sort(([a], [b])=>(0, _bigSign.default)(this.compare(a, b)));
    }
}
/**
 *
 * @param {bigint[]} nums
 * @returns {bigint|null}
 */ function max(nums) {
    let max = null;
    for (const num of nums){
        max = max !== null && max !== void 0 ? max : num;
        max = max > num ? max : num;
    }
    return max;
}
/**
 * A fast ASCII order string comparison function.
 *
 * Using `.sort()` without a custom compare function is faster
 * But you can only use that if you're sorting an array of
 * only strings. If you're sorting str