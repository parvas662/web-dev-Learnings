previous rule name ends, and ends where the next rule name starts.
             *
             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment
             *                                    ^^^^^^^^^^^^^^
             *
             * We want to remove only the content between the two commas, and also one of the commas.
             *
             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment
             *                                     ^^^^^^^^^^^
             */
            removalStart = matchStart + firstIndexOfComma;
            removalEnd = matchStart + lastIndexOfComma;

        } else {

            /*
             * This is either the first element or the last element.
             *
             * If this is the first element, matched range starts where the first rule name starts
             * and ends where the second rule name starts. This is exactly the range we want
             * to remove so that the second rule name will start where the first one was starting
             * and thus preserve the original formatting.
             *
             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment
             *                            ^^^^^^^^^^^
             *
             * Similarly, if this is the last element, we've already matched the range we want to
             * remove. The previous rule name will end where the last one was ending, relative
             * to the content on the right side.
             *
             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment
             *                                               ^^^^^^^^^^^^^
             */
            removalStart = matchStart;
            removalEnd = matchEnd;
        }

        return {
            description: `'${ruleId}'`,
            fix: {
                range: [
                    removalStart,
                    removalEnd
                ],
                text: ""
            },
            unprocessedDirective: directive.unprocessedDirective
        };
    });
}

/**
 * Creates a description of deleting an entire unused disable directive.
 * @param {Directive[]} directives Unused directives to be removed.
 * @param {Token} node The backing Comment token.
 * @param {SourceCode} sourceCode The source code object for the file being linted.
 * @returns {{ description, fix, unprocessedDirective }} Details for later creation of an output problem.
 */
function createDirectiveRemoval(directives, node, sourceCode) {
    const range = sourceCode.getRange(node);
    const ruleIds = directives.filter(directive => directive.ruleId).map(directive => `'${directive.ruleId}'`);

    return {
        description: ruleIds.length <= 2
            ? ruleIds.join(" or ")
            : `${ruleIds.slice(0, ruleIds.length - 1).join(", ")}, or ${ruleIds.at(-1)}`,
        fix: {
            range,
            text: " "
        },
        unprocessedDirective: directives[0].unprocessedDirective
    };
}

/**
 * Parses details from directives to create output Problems.
 * @param {Iterable<Directive>} allDirectives Unused directives to be removed.
 * @param {SourceCode} sourceCode The source code object for the file being linted.
 * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.
 */
function processUnusedDirectives(allDirectives, sourceCode) {
    const directiveGroups = groupByParentDirective(allDirectives);

    return directiveGroups.flatMap(
        directives => {
            const { parentDirective } = directives[0].unprocessedDirective;
            const remainingRuleIds = new Set(parentDirective.ruleIds);

            for (const directive of directives) {
                remainingRuleIds.delete(directive.ruleId);
            }

            return remainingRuleIds.size
                ? createIndividualDirectivesRemoval(directives, parentDirective, sourceCode)
                : [createDirectiveRemoval(directives, parentDirective.node, sourceCode)];
        }
    );
}

/**
 * Collect eslint-enable comments that are removing suppressions by eslint-disable comments.
 * @param {Directive[]} directives The directives to check.
 * @returns {Set<Directive>} The used eslint-enable comments
 */
function collectUsedEnableDirectives(directives) {

    /**
     * A Map of `eslint-enable` keyed by ruleIds that may be marked as used.
     * If `eslint-enable` does not have a ruleId, the key will be `null`.
     * @type {Map<string|null, Directive>}
     */
    const enabledRules = new Map();

    /**
     * A Set of `eslint-enable` marked as used.
     * It is also the return value of `collectUsedEnableDirectives` function.
     * @type {Set<Directive>}
     */
    const usedEnableDirectives = new Set();

    /*
     * Checks the directives backwards to see if the encountered `eslint-enable` is used by the previous `eslint-disable`,
     * and if so, stores the `eslint-enable` in `usedEnableDirectives`.
     */
    for (let index = directives.length - 1; index >= 0; index--) {
        const directive = directives[index];

        if (directive.type === "disable") {
            if (enabledRules.size === 0) {
                continue;
            }
            if (directive.ruleId === null) {

                // If encounter `eslint-disable` without ruleId,
                // mark all `eslint-enable` currently held in enabledRules as used.
                // e.g.
                //    /* eslint-disable */ <- current directive
                //    /* eslint-enable rule-id1 */ <- used
                //    /* eslint-enable rule-id2 */ <- used
                //    /* eslint-enable */ <- used
                for (const enableDirective of enabledRules.values()) {
                    usedEnableDirectives.add(enableDirective);
                }
                enabledRules.clear();
            } else {
                const enableDirective = enabledRules.get(directive.ruleId);

                if (enableDirective) {

                    // If encounter `eslint-disable` with ruleId, and there is an `eslint-enable` with the same ruleId in enabledRules,
                    // mark `eslint-enable` with ruleId as used.
                    // e.g.
                    //    /* eslint-disable rule-id */ <- current directive
                    //    /* eslint-enable rule-id