);
}

// Parses element name in any form - namespaced, member
// or single identifier.
function jsxParseElementName() {
  const firstTokenIndex = _base.state.tokens.length;
  jsxParseNamespacedName(_index.IdentifierRole.Access);
  let hadDot = false;
  while (_index.match.call(void 0, _types.TokenType.dot)) {
    hadDot = true;
    nextJSXTagToken();
    jsxParseIdentifier();
  }
  // For tags like <div> with a lowercase letter and no dots, the name is
  // actually *not* an identifier access, since it's referring to a built-in
  // tag name. Remove the identifier role in this case so that it's not
  // accidentally transformed by the imports transform when preserving JSX.
  if (!hadDot) {
    const firstToken = _base.state.tokens[firstTokenIndex];
    const firstChar = _base.input.charCodeAt(firstToken.start);
    if (firstChar >= _charcodes.charCodes.lowercaseA && firstChar <= _charcodes.charCodes.lowercaseZ) {
      firstToken.identifierRole = null;
    }
  }
}

// Parses any type of JSX attribute value.
function jsxParseAttributeValue() {
  switch (_base.state.type) {
    case _types.TokenType.braceL:
      _index.next.call(void 0, );
      _expression.parseExpression.call(void 0, );
      nextJSXTagToken();
      return;

    case _types.TokenType.jsxTagStart:
      jsxParseElement();
      nextJSXTagToken();
      return;

    case _types.TokenType.string:
      nextJSXTagToken();
      return;

    default:
      _util.unexpected.call(void 0, "JSX value should be either an expression or a quoted JSX text");
  }
}

// Parse JSX spread child, after already processing the {
// Does not parse the closing }
function jsxParseSpreadChild() {
  _util.expect.call(void 0, _types.TokenType.ellipsis);
  _expression.parseExpression.call(void 0, );
}

// Parses JSX opening tag starting after "<".
// Returns true if the tag was self-closing.
// Does not parse the last token.
function jsxParseOpeningElement(initialTokenIndex) {
  if (_index.match.call(void 0, _types.TokenType.jsxTagEnd)) {
    // This is an open-fragment.
    return false;
  }
  jsxParseElementName();
  if (_base.isTypeScriptEnabled) {
    _typescript.tsTryParseJSXTypeArgument.call(void 0, );
  }
  let hasSeenPropSpread = false;
  while (!_index.match.call(void 0, _types.TokenType.slash) && !_index.match.call(void 0, _types.TokenType.jsxTagEnd) && !_base.state.error) {
    if (_index.eat.call(void 0, _types.TokenType.braceL)) {
      hasSeenPropSpread = true;
      _util.expect.call(void 0, _types.TokenType.ellipsis);
      _expression.parseMaybeAssign.call(void 0, );
      // }
      nextJSXTagToken();
      continue;
    }
    if (
      hasSeenPropSpread &&
 