Fragment\";\n  openingFragment: JSXOpeningFragment;\n  closingFragment: JSXClosingFragment;\n  children: Array<\n    JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment\n  >;\n}\n\nexport interface JSXOpeningFragment extends BaseNode {\n  type: \"JSXOpeningFragment\";\n}\n\nexport interface JSXClosingFragment extends BaseNode {\n  type: \"JSXClosingFragment\";\n}\n\nexport interface Noop extends BaseNode {\n  type: \"Noop\";\n}\n\nexport interface Placeholder extends BaseNode {\n  type: \"Placeholder\";\n  expectedNode:\n    | \"Identifier\"\n    | \"StringLiteral\"\n    | \"Expression\"\n    | \"Statement\"\n    | \"Declaration\"\n    | \"BlockStatement\"\n    | \"ClassBody\"\n    | \"Pattern\";\n  name: Identifier;\n  decorators?: Array<Decorator> | null;\n  optional?: boolean | null;\n  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n}\n\nexport interface V8IntrinsicIdentifier extends BaseNode {\n  type: \"V8IntrinsicIdentifier\";\n  name: string;\n}\n\nexport interface ArgumentPlaceholder extends BaseNode {\n  type: \"ArgumentPlaceholder\";\n}\n\nexport interface BindExpression extends BaseNode {\n  type: \"BindExpression\";\n  object: Expression;\n  callee: Expression;\n}\n\nexport interface ImportAttribute extends BaseNode {\n  type: \"ImportAttribute\";\n  key: Identifier | StringLiteral;\n  value: StringLiteral;\n}\n\nexport interface Decorator extends BaseNode {\n  type: \"Decorator\";\n  expression: Expression;\n}\n\nexport interface DoExpression extends BaseNode {\n  type: \"DoExpression\";\n  body: BlockStatement;\n  async: boolean;\n}\n\nexport interface ExportDefaultSpecifier extends BaseNode {\n  type: \"ExportDefaultSpecifier\";\n  exported: Identifier;\n}\n\nexport interface RecordExpression extends BaseNode {\n  type: \"RecordExpression\";\n  properties: Array<ObjectProperty | SpreadElement>;\n}\n\nexport interface TupleExpression extends BaseNode {\n  type: \"TupleExpression\";\n  elements: Array<Expression | SpreadElement>;\n}\n\nexport interface DecimalLiteral extends BaseNode {\n  type: \"DecimalLiteral\";\n  value: string;\n}\n\nexport interface ModuleExpression extends BaseNode {\n  type: \"ModuleExpression\";\n  body: Program;\n}\n\nexport interface TopicReference extends BaseNode {\n  type: \"TopicReference\";\n}\n\nexport interface PipelineTopicExpression extends BaseNode {\n  type: \"PipelineTopicExpression\";\n  expression: Expression;\n}\n\nexport interface PipelineBareFunction extends BaseNode {\n  type: \"PipelineBareFunction\";\n  callee: Expression;\n}\n\nexport interface PipelinePrimaryTopicReference extends BaseNode {\n  type: \"PipelinePrimaryTopicReference\";\n}\n\nexport interface TSParameterProperty extends BaseNode {\n  type: \"TSParameterProperty\";\n  parameter: Identifier | AssignmentPattern;\n  accessibility?: \"public\" | \"private\" | \"protected\" | null;\n  decorators?: Array<Decorator> | null;\n  override?: boolean | null;\n  readonly?: boolean | null;\n}\n\nexport interface TSDeclareFunction extends BaseNode {\n  type: \"TSDeclareFunction\";\n  id?: Identifier | null;\n  typeParameters?: TSTypeParameterDeclaration | Noop | null;\n  params: Array<Identifier | Pattern | RestElement>;\n  returnType?: TSTypeAnnotation | Noop | null;\n  async?: boolean;\n  declare?: boolean | null;\n  generator?: boolean;\n}\n\nexport interface TSDeclareMethod extends BaseNode {\n  type: \"TSDeclareMethod\";\n  decorators?: Array<Decorator> | null;\n  key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression;\n  typeParameters?: TSTypeParameterDeclaration | Noop | null;\n  params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;\n  returnType?: TSTypeAnnotation | Noop | null;\n  abstract?: boolean | null;\n  access?: \"public\" | \"private\" | \"protected\" | null;\n  accessibility?: \"public\" | \"private\" | \"protected\" | null;\n  async?: boolean;\n  computed?: boolean;\n  generator?: boolean;\n  kind?: \"get\" | \"set\" | \"method\" | \"constructor\";\n  optional?: boolean | null;\n  override?: boolean;\n  st'use strict';

var hasOwn = require('hasown');
var inspect = require('object-inspect');
var supportsDescriptors = require('define-properties').supportsDescriptors;
var v = require('es-value-fixtures');

var forEach = require('for-each');
var availableFlags = require('available-regexp-flags');
var regexProperties = require('available-regexp-flags/properties');

var sortedFlags = availableFlags.slice().sort(function (a, b) { return a.localeCompare(b); }).join('');

var getRegexLiteral = function (stringRegex) {
	try {
		// eslint-disable-next-line no-new-func
		return Function('return ' + stringRegex + ';')();
	} catch (e) { /**/ }
	return null;
};

module.exports = function runTests(flags, t) {
	forEach(v.primitives, function (nonObject) {
		t['throws'](
			function () { flags(nonObject); },
			TypeError,
			'throws when called with a non-object receiver: ' + inspect(nonObject)
		);
	});

	t.equal(flags(/a/g), 'g', 'flags(/a/g) !== "g"');
	t.equal(flags(/a/gmi), 'gim', 'flags(/a/gmi) !== "gim"');
	t.equal(flags(new RegExp('a', 'gmi')), 'gim', 'flags(new RegExp("a", "gmi")) !== "gim"');
	t.equal(flags(/a/), '', 'flags(/a/) !== ""');
	t.equal(flags(new RegExp('a')), '', 'flags(new RegExp("a")) !== ""');

	forEach(availableFlags, function (flag) {
		var property = regexProperties[flag];
		t.test(property + ' flag', function (st) {
			st.equal(flags(getRegexLiteral('/a/' + flag)), flag, 'flags(/a/' + flag + ') !== ' + inspect(flag));
			st.equal(flags(new RegExp('a', flag)), flag, 'flags(new RegExp("a", ' + inspect(flag) + ')) !== ' + inspect(flag));
			st.end();
		});
	});

	t.test('sorting', function (st) {
		st.equal(flags(/a/gim), 'gim', 'flags(/a/gim) !== "gim"');
		st.equal(flags(/a/mig), 'gim', 'flags(/a/mig) !== "gim"');
		st.equal(flags(/a/mgi), 'gim', 'flags(/a/mgi) !== "gim"');
		if (hasOwn(RegExp.prototype, 'sticky')) {
			st.equal(flags(getRegexLiteral('/a/gyim')), 'gimy', 'flags(/a/gyim) !== "gimy"');
		}
		if (hasOwn(RegExp.prototype, 'unicode')) {
			st.equal(flags(getRegexLiteral('/a/ugmi')), 'gimu', 'flags(/a/ugmi) !== "gimu"');
		}
		if (hasOwn(RegExp.prototype, 'dotAll')) {
			st.equal(flags(getRegexLiteral('/a/sgmi')), 'gims', 'flags(/a/sgmi) !== "gims"');
		}

		var randomFlags = availableFlags.slice().sort(function () { return Math.random() > 0.5 ? 1 : -1; }).join('').replace('v', '');
		st.equal(
			flags(getRegexLiteral('/a/' + randomFlags)),
			sortedFlags.replace('v', ''),
			'random: flags(/a/' + randomFlags + ') === ' + inspect(sortedFlags)
		);

		st.end();
	});

	t.test('basic examples', function (st) {
		st.equal(flags(/a/g), 'g', '(/a/g).flags !== "g"');
		st.equal(flags(/a/gmi), 'gim', '(/a/gmi).flags !== "gim"');
		st.equal(flags(new RegExp('a', 'gmi')), 'gim', 'new RegExp("a", "gmi").flags !== "gim"');
		st.equal(flags(/a/), '', '(/a/).flags !== ""');
		st.equal(flags(new RegExp('a')), '', 'new RegExp("a").flags !== ""');

		st.end();
	});

	t.test('generic flags', function (st) {
		st.equal(flags({}), '');
		st.equal(flags({ ignoreCase: true }), 'i');
		st.equal(flags({ dotAll: 1, global: 0, sticky: 1, unicode: 1 }), 'suy');
		st.equal(flags({ __proto__: { multiline: true } }), 'm');

		var obj = {};
		forEach(availableFlags, function (flag) {
			if (flag !== 'v') {
				obj[regexProperties[flag]] = true;
			}
		});
		st.equal(flags(obj), sortedFlags.replace('v', ''), 'an object with every available flag: ' + sortedFlags);

		st.end();
	});

	t.test('getters', { skip: !supportsDescriptors }, function (st) {
		/* eslint getter-return: 0 */
		var calls = '';
		var re = {};
		Object.defineProperty(re, 'hasIndices', {
			get: function () {
				calls += 'd';
			}
		});
		Object.defineProperty(re, 'global', {
			get: function () {
				calls += 'g';
			}
		});
		Object.defineProperty(re, 'ignoreCase', {
			get: function () {
				calls += 'i';
			}
		});
		Object.defineProperty(re, 'multiline', {
			get: function () {
				calls += 'm';
			}
		});
		