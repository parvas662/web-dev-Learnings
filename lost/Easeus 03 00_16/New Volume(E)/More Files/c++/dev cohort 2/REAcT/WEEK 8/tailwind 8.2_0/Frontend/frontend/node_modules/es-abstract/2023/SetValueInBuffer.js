ath = joinPath.joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);
                if (exclude && exclude(entry.name, path))
                    continue;
                this.walkDirectory(this.state, path, path, depth - 1, this.walk);
            }
            else if (entry.isSymbolicLink() && this.resolveSymlink) {
                let path = joinPath.joinPathWithBasePath(entry.name, directoryPath);
                this.resolveSymlink(path, this.state, (stat, resolvedPath) => {
                    if (stat.isDirectory()) {
                        resolvedPath = (0, utils_1.normalizePath)(resolvedPath, this.state.options);
                        if (exclude && exclude(entry.name, resolvedPath))
                            return;
                        this.walkDirectory(this.state, resolvedPath, useRealPaths ? resolvedPath : path + pathSeparator, depth - 1, this.walk);
                    }
                    else {
                        resolvedPath = useRealPaths ? resolvedPath : path;
                        const filename = (0, path_1$1.basename)(resolvedPath);
                        const directoryPath = (0, utils_1.normalizePath)((0, path_1$1.dirname)(resolvedPath), this.state.options);
                        resolvedPath = this.joinPath(filename, directoryPath);
                        this.pushFile(resolvedPath, files, this.state.counts, filters);
                    }
                });
            }
        }
        this.groupFiles(this.state.groups, directoryPath, files);
    };
}
walker.Walker = Walker;

Object.defineProperty(async, "__esModule", { value: true });
async.callback = async.promise = void 0;
const walker_1$1 = walker;
function promise(root, options) {
    return new Promise((resolve, reject) => {
        callback(root, options, (err, output) => {
            if (err)
                return reject(err);
            resolve(output);
        });
    });
}
async.promise = promise;
function callback(root, options, callback) {
    let walker = new walker_1$1.Walker(root, options, callback);
    walker.start();
}
async.callback = callback;

var sync$2 = {};

Object.defineProperty(sync$2, "__esModule", { value: true });
sync$2.sync = void 0;
const walker_1 = walker;
function sync$1(root, options) {
    const walker = new walker_1.Walker(root, options);
    return walker.start();
}
sync$2.sync = sync$1;

Object.defineProperty(apiBuilder, "__esModule", { value: true });
apiBuilder.APIBuilder = void 0;
const async_1 = async;
const sync_1 = sync$2;
class APIBuilder {
    root;
    options;
    constructor(root, options) {
        this.root = root;
        this.options = options;
    }
    withPromise() {
        return (0, async_1.promise)(this.root, this.options);
    }
    withCallback(cb) {
        (0, async_1.callback)(this.root, this.options, cb);
    }
    sync() {
        return (0, sync_1.sync)(this.root, this.options);
    }
}
apiBuilder.APIBuilder = APIBuilder;

Object.defineProperty(builder, "__esModule", { value: true });
builder.Builder = void 0;
const path_1 = require$$0$2;
const api_builder_1 = apiBuilder;
var pm = null;
/* c8 ignore next 6 */
try {
    require.resolve("picomatch");
    pm = picomatch_1$1;
}
catch (_e) {
    // do nothing
}
class Builder {
    globCache = {};
    options = {
        maxDepth: Infinity,
        suppressErrors: true,
        pathSeparator: path_1.sep,
        filters: [],
    };
    globFunction;
    constructor(options) {
        this.options = { ...this.options, ...options };
        this.globFunction = this.options.globFunction;
    }
    group() {
        this.options.group = true;
        return this;
    }
    withPathSeparator(separator) {
        this.options.pathSeparator = separator;
        return this;
    }
    withBasePath() {
        this.options.includeBasePath = true;
        return this;
    }
    withRelativePaths() {
        this.options.relativePaths = true;
        return this;
    }
    withDirs() {
        this.options.includeDirs = true;
        return this;
    }
    withMaxDepth(depth) {
        this.options.maxDepth = depth;
        return this;
