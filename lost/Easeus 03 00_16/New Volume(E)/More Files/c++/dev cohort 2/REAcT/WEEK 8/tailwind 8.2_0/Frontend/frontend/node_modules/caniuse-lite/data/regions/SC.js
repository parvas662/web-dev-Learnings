y(node.right, node.operator.slice(0, -1));
            }

            return false;

        case "SequenceExpression":
            return isConstant(scope, node.expressions.at(-1), inBooleanPosition);
        case "SpreadElement":
            return isConstant(scope, node.argument, inBooleanPosition);
        case "CallExpression":
            if (node.callee.type === "Identifier" && node.callee.name === "Boolean") {
                if (node.arguments.length === 0 || isConstant(scope, node.arguments[0], true)) {
                    return isReferenceToGlobalVariable(scope, node.callee);
                }
            }
            return false;
        case "Identifier":
            return node.name === "undefined" && isReferenceToGlobalVariable(scope, node);

                // no default
    }
    return false;
}

/**
 * Checks whether a node is an ExpressionStatement at the top level of a file or function body.
 * A top-level ExpressionStatement node is a directive if it contains a single unparenthesized
 * string literal and if it occurs either as the first sibling or immediately after another
 * directive.
 * @param {ASTNode} node The node to check.
 * @returns {boolean} Whether or not the node is an ExpressionStatement at the top level of a
 * file or function body.
 */
function isTopLevelExpressionStatement(node) {
    if (node.type !== "ExpressionStatement") {
        return false;
    }
    const parent = node.parent;

    return parent.type === "Program" || (parent.type === "BlockStatement" && isFunction(parent.parent));

}

/**
 * Check whether the given node is a part of a directive prologue or not.
 * @param {ASTNode} node The node to check.
 * @returns {boolean} `true` if the node is a part of directive prologue.
 */
function isDirective(node) {
    return node.type === "ExpressionStatement" && typeof node.directive === "string";
}

/**
 * Tests if a node appears at the beginning of an ancestor ExpressionStatement node.
 * @param {ASTNode} node The node to check.
 * @returns {boolean} Whether the node appears at the beginning of an ancestor ExpressionStatement node.
 */
function isStartOfExpressionStatement(node) {
    const start = node.range[0];
    let ancestor = node;

    while ((ancestor = ancestor.parent) && ancestor.range[0] === start) {
        if (ancestor.type === "ExpressionStatement") {
            return true;
        }
    }
    return false;
}

/**
 * Determines whether an opening parenthesis `(`, bracket `[` or backtick ``` ` ``` needs to be preceded by a semicolon.
 * This opening parenthesis or bracket should be at the start of an `ExpressionStatement`, a `MethodDefinition` or at
 * the start of the body of an `ArrowFunctionExpression`.
 * @type {(sourceCode: SourceCode, node: ASTNode) => boolean}
 * @param {SourceCode} sourceCode The source code object.
 * @param {ASTNode} node A node at the position where an opening parenthesis or bracket will be inserted.
 * @returns {boolean} Whether a semicolon is required before the opening parenthesis or bracket.
 */
let needsPrecedingSemicolon;

{
    const BREAK_OR_CONTINUE = new Set(["BreakStatement", "ContinueStatement"]);

    // Declaration types that cannot be continued by a punctuator when ending with a string Literal that is a direct child.
    const DECLARATIONS = new Set(["ExportAllDeclaration", "ExportNamedDeclaration", "ImportDeclaration"]);

    const IDENTIFIER_OR_KEYWORD = new Set(["Identifier", "Keyword"]);

    // Keywords that can immediately precede an ExpressionStatement node, mapped to the their node types.
    const NODE_TYPES_BY_KEYWORD = {
        __proto__: null,
        break: "BreakStatement",
        continue: "ContinueStatement",
        debugger: "DebuggerStatement",
        do: "DoWhileStatement",
        else: "IfStatement",
        return: "ReturnStatement",
        yield: "YieldExpression"
    };

    /*
     * Before an opening parenthesis, postfix `++` and `--` always trigger ASI;
     * the tokens `:`, `;`, `{` and `=>` don't expect a semicolon, as that would count as an empty statement.
     */
    const PUNCTUATORS = new Set([":", ";", "{", "=>", "++", "--"]);

    /*
     * Statements that can contain an `ExpressionStatement` after a closing parenthesis.
     * DoWhileStatement is an exception in that it always triggers ASI after the closing parenthesis.
     */
    const STATEMENTS = new Set([
        "DoWhileStatement",
        "ForInStatement",
        "ForOfStatement",
        "ForStatement",
        "IfStatement",
        "WhileStatement",
        "WithStatement"
    ]);

    needsPrecedingSemicolon =
    function(sourceCode, node) {
        const prevToken = sourceCode.getTokenBefore(node);

        if (!prevToken || prevToken.type === "Punctuator" && PUNCTUATORS.has(prevToken.value)) {
            return false;
        }

        const prevNode = sourceCode.getNodeByRangeIndex(prevToken.range[0]);

        if (isClosingParenToken(prevToken)) {
            return !STATEMENTS.has(prevNode.type);
        }

        if (isClosingBraceToken(prevToken)) {
            return (
                prevNode.type === "BlockStatement" && prevNode.parent.type === "FunctionExpression" && prevNode.parent.parent.type !== "MethodDefinition" ||
                prevNode.type === "ClassBody" && prevNode.parent.type === "ClassExpression" ||
                prevNode.type === "ObjectExpression"
            );
        }

        if (IDENTIFIER_OR_KEYWORD.has(prevToken.type)) {
            if (BREAK_OR_CONTINUE.has(prevNode.parent.type)) {
                return false;
            }

            const keyword = prevToken.value;
            const nodeType = NODE_TYPES_BY_KEYWORD[keyword];

            return prevNode.type !== nodeType;
        }

        if (prevToken.type === "Stri