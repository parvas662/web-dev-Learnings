string,
    messages?: boolean;
    sourceCode?: boolean;
    processCode?: (code: string, schema: object) => string;
    cache?: object;
    logger?: CustomLogger | false;
    nullable?: boolean;
    serialize?: ((schema: object | boolean) => any) | false;
  }

  type FormatValidator = string | RegExp | ((data: string) => boolean | PromiseLike<any>);
  type NumberFormatValidator = ((data: number) => boolean | PromiseLike<any>);

  interface NumberFormatDefinition {
    type: "number",
    validate: NumberFormatValidator;
    compare?: (data1: number, data2: number) => number;
    async?: boolean;
  }

  interface StringFormatDefinition {
    type?: "string",
    validate: FormatValidator;
    compare?: (data1: string, data2: string) => number;
    async?: boolean;
  }

  type FormatDefinition = NumberFormatDefinition | StringFormatDefinition;

  interface KeywordDefinition {
    type?: string | Array<string>;
    async?: boolean;
    $data?: boolean;
    errors?: boolean | string;
    metaSchema?: object;
    // schema: false makes validate not to expect schema (ValidateFunction)
    schema?: boolean;
    statements?: boolean;
    dependencies?: Array<string>;
    modifying?: boolean;
    valid?: boolean;
    // one and only one of the following properties should be present
    validate?: SchemaValidateFunction | ValidateFunction;
    compile?: (schema: any, parentSchema: object, it: CompilationContext) => ValidateFunction;
    macro?: (schema: any, parentSchema: object, it: CompilationContext) => object | boolean;
    inline?: (it: CompilationContext, keyword: string, schema: any, parentSchema: object) => string;
  }

  interface CompilationContext {
    level: number;
    dataLevel: number;
    dataPathArr: string[];
    schema: any;
    schemaPath: string;
    baseId: