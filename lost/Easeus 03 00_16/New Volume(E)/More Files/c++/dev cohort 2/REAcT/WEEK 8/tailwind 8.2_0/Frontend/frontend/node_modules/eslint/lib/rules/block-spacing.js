ts = 1;
	(function (exports) {

		const {sep} = require$$0$1;
		const {platform} = process;
		const os = require$$2$1;

		exports.EV_ALL = 'all';
		exports.EV_READY = 'ready';
		exports.EV_ADD = 'add';
		exports.EV_CHANGE = 'change';
		exports.EV_ADD_DIR = 'addDir';
		exports.EV_UNLINK = 'unlink';
		exports.EV_UNLINK_DIR = 'unlinkDir';
		exports.EV_RAW = 'raw';
		exports.EV_ERROR = 'error';

		exports.STR_DATA = 'data';
		exports.STR_END = 'end';
		exports.STR_CLOSE = 'close';

		exports.FSEVENT_CREATED = 'created';
		exports.FSEVENT_MODIFIED = 'modified';
		exports.FSEVENT_DELETED = 'deleted';
		exports.FSEVENT_MOVED = 'moved';
		exports.FSEVENT_CLONED = 'cloned';
		exports.FSEVENT_UNKNOWN = 'unknown';
		exports.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;
		exports.FSEVENT_TYPE_FILE = 'file';
		exports.FSEVENT_TYPE_DIRECTORY = 'directory';
		exports.FSEVENT_TYPE_SYMLINK = 'symlink';

		exports.KEY_LISTENERS = 'listeners';
		exports.KEY_ERR = 'errHandlers';
		exports.KEY_RAW = 'rawEmitters';
		exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];

		exports.DOT_SLASH = `.${sep}`;

		exports.BACK_SLASH_RE = /\\/g;
		exports.DOUBLE_SLASH_RE = /\/\//;
		exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
		exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
		exports.REPLACER_RE = /^\.[/\\]/;

		exports.SLASH = '/';
		exports.SLASH_SLASH = '//';
		exports.BRACE_START = '{';
		exports.BANG = '!';
		exports.ONE_DOT = '.';
		exports.TWO_DOTS = '..';
		exports.STAR = '*';
		exports.GLOBSTAR = '**';
		exports.ROOT_GLOBSTAR = '/**/*';
		exports.SLASH_GLOBSTAR = '/**';
		exports.DIR_SUFFIX = 'Dir';
		exports.ANYMATCH_OPTS = {dot: true};
		exports.STRING_TYPE = 'string';
		exports.FUNCTION_TYPE = 'function';
		exports.EMPTY_STR = '';
		exports.EMPTY_FN = () => {};
		exports.IDENTITY_FN = val => val;

		exports.isWindows = platform === 'win32';
		exports.isMacos = platform === 'darwin';
		exports.isLinux = platform === 'linux';
		exports.isIBMi = os.type() === 'OS400'; 
	} (constants));
	return constants;
}

var nodefsHandler;
var hasRequiredNodefsHandler;

function requireNodefsHandler () {
	if (hasRequiredNodefsHandler) return nodefsHandler;
	hasRequiredNodefsHandler = 1;

	const fs = require$$0$2;
	const sysPath = require$$0$1;
	const { promisify } = require$$2;
	const isBinaryPath = /*@__PURE__*/ requireIsBinaryPath();
	const {
	  isWindows,
	  isLinux,
	  EMPTY_FN,
	  EMPTY_STR,
	  KEY_LISTENERS,
	  KEY_ERR,
	  KEY_RAW,
	  HANDLER_KEYS,
	  EV_CHANGE,
	  EV_ADD,
	  EV_ADD_DIR,
	  EV_ERROR,
	  STR_DATA,
	  STR_END,
	  BRACE_START,
	  STAR
	} = /*@__PURE__*/ requireConstants();

	const THROTTLE_MODE_WATCH = 'watch';

	const open = promisify(fs.open);
	const stat = promisify(fs.stat);
	const lstat = promisify(fs.lstat);
	const close = promisify(fs.close);
	const fsrealpath = promisify(fs.realpath);

	const statMethods = { lstat, stat };

	// TODO: emit errors properly. Example: EMFILE on Macos.
	const foreach = (val, fn) => {
	  if (val instanceof Set) {
	    val.forEach(fn);
	  } else {
	    fn(val);
	  }
	};

	const addAndConvert = (main, prop, item) => {
	  let container = main[prop];
	  if (!(container instanceof Set)) {
	    main[prop] = container = new Set([container]);
	  }
	  container.add(item);
	};

	const clearItem = cont => key => {
	  const set = cont[key];
	  if (set instanceof Set) {
	    set.clear();
	  } else {
	    delete cont[key];
	  }
	};

	const delFromSet = (main, prop, item) => {
	  const container = main[prop];
	  if (container instanceof Set) {
	    container.delete(item);
	  } else if (container === item) {
	    delete main[prop];
	  }
	};

	const isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;

	/**
	 * @typedef {String} Path
	 */

	// fs_watch helpers

	// object to hold per-process fs_watch instances
	// (may be shared across chokidar FSWatcher instances)

	/**
	 * @typedef {Object} FsWatchContainer
	 * @property {Set} listeners
	 * @property {Set} errHandlers
	 * @property {Set} rawEmitters
	 * @property {fs.FSWatcher=} watcher
	 * @property {Boolean=} watcherUnusable
	 */

	/**
	 * @type {Map<String,FsWatchContainer>}
	 */
	const FsWatchInstances = new Map();

	/**
	 * Instantiates the fs_watch interface
	 * @param {String} path to be watched
	 * @param {Object} options to be passed to fs_watch
	 * @param {Function} listener main event handler
	 * @param {Function} errHandler emits info about errors
	 * @param {Function} emitRaw emits raw event data
	 * @returns {fs.FSWatcher} new fsevents instance
	 */
	function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
	  const handleEvent = (rawEvent, evPath) => {
	    listener(path);
	    emitRaw(rawEvent, evPath, {watchedPath: path});

	    // emit based on events occurring for files from a directory's watcher in
	    // case the file's watcher misses it (and rely on throttling to de-dupe)
	    if (evPath && path !== evPath) {
	      fsWatchBroadcast(
	        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)
	      );
	    }
	  };
	  try {
	    return fs.watch(path, options, handleEvent);
	  } catch (error) {
	    errHandler(error);
	  }
	}

	/**
	 * Helper for passing fs_watch event data to a collection of listeners
	 * @param {Path} fullPath absolute path bound to fs_watch instance
	 * @param {String} type listener type
	 * @param {*=} val1 arguments to be passed to listeners
	 * @param {*=} val2
	 * @param {*=} val3
	 */
	const fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
	  const cont = FsWatchInstances.get(fullPath);
	  if (!cont) return;
	  foreach(cont[type], (listener) => {
	    listener(val1, val2, val3);
	  });
	};

	/**
	 * Instantiates the fs_watch interface or binds listeners
	 * to an existing one covering the same file system entry
	 * @param {String} path
	 * @param {String} fullPath absolute path
	 * @param {Object} options to be passed to fs_watch
	 * @param {Ob