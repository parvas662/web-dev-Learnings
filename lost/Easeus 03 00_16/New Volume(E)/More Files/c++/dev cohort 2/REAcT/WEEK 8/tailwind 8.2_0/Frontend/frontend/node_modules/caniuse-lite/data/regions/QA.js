emplate literal without expressions.
     */
    isStaticTemplateLiteral(node) {
        return node.type === "TemplateLiteral" && node.expressions.length === 0;
    },

    /**
     * Determines whether the existing curly braces around the single statement are necessary to preserve the semantics of the code.
     * The braces, which make the given block body, are necessary in either of the following situations:
     *
     * 1. The statement is a lexical declaration.
     * 2. Without the braces, an `if` within the statement would become associated with an `else` after the closing brace:
     *
     *     if (a) {
     *         if (b)
     *             foo();
     *     }
     *     else
     *         bar();
     *
     *     if (a)
     *         while (b)
     *             while (c) {
     *                 while (d)
     *                     if (e)
     *                         while(f)
     *                             foo();
     *            }
     *     else
     *         bar();
     * @param {ASTNode} node `BlockStatement` body with exactly one statement directly inside. The statement can have its own nested statements.
     * @param {SourceCode} sourceCode The source code
     * @returns {boolean} `true` if the braces are necessary - removing them (replacing the given `BlockStatement` body with its single statement content)
     * would change the semantics of the code or produce a syntax error.
     */
    areBracesNecessary(node, sourceCode) {

        /**
         * Determines if the given node is a lexical declaration (let, const, function, or class)
         * @param {ASTNode} nodeToCheck The node to check
         * @returns {boolean} True if the node is a lexical declaration
         * @private
         */
        function isLexicalDeclaration(nodeToCheck) {
            if (nodeToCheck.type === "VariableDeclaration") {
                return nodeToCheck.kind === "const" || nodeToCheck.kind === "let";
            }

            return nodeToCheck.type === "FunctionDeclaration" || nodeToCheck.type === "ClassDeclaration";
        }


        /**
         * Checks if the given token is an `else` token or not.
         * @param {Token} token The token to check.
         * @returns {boolean} `true` if the token is an `else` token.
         */
        function isElseKeywordToken(token) {
            return token.value === "else" && token.type === "Keyword";
        }

        /**
         * Determines whether the given node has an `else` keyword token as the first token after.
         * @param {ASTNode} nodeToCheck The node to check.
         * @returns {boolean} `true` if the node is followed by an `else` keyword token.
         */
        function isFollowedByElseKeyword(nodeToCheck) {
            const nextToken = sourceCode.getTokenAfter(nodeToCheck);

            return Boolean(nextToken) && isElseKeywordToken(nextToken);
        }

        /**
         * Determines whether the code represented by the given node contains an `if` statement
         * that would become associated with an `else` keyword directly appended to that code.
         *
         * Examples where it returns `true`:
         *
         *    if (a)
         *        foo();
         *
         *    if (a) {
         *        foo();
         *    }
         *
         *    if (a)
         *        foo();
         *    else if (b)
         *        bar();
         *
         *    while (a)
         *        if (b)
         *            if(c)
         *                foo();
         *            else
         *                bar();
         *
         * Examples where it returns `false`:
         *
         *    if (a)
         *        foo();
         *    else
         *        bar();
         *
         *    while (a) {
         *        if (b)
         *            if(c)
         *                foo();
         *            else
         *                bar();
         *    }
         *
         *    while (a)
         *        if (b) {
         *            if(c)
         *                foo();
         *        }
         *        else
         *            bar();
         * @param {ASTNode} nodeToCheck Node representing the code to check.
         * @returns {boolean} `true` if an `if` statement within the code would become as