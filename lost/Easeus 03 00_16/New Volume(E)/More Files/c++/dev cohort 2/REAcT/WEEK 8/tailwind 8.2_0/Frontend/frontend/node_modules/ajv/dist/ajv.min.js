ty instanceof Identifier)) {
                return;
            }
            const memberName = property.name;
            // side-effect only, when only chaining .catch or .finally
            if (callExpression.parent instanceof ExpressionStatement &&
                ['catch', 'finally'].includes(memberName)) {
                return parseAst_js.EMPTY_ARRAY;
            }
            if (memberName !== 'then')
                return;
            // Side-effect only: import('bar').then()
            if (callExpression.arguments.length === 0) {
                return parseAst_js.EMPTY_ARRAY;
            }
            const argument = callExpression.arguments[0];
            if (callExpression.arguments.length !== 1 ||
                !(argument instanceof ArrowFunctionExpression || argument instanceof FunctionExpression)) {
                return;
            }
            // Side-effect only: import('bar').then(() => {})
            if (argument.params.length === 0) {
                return parseAst_js.EMPTY_ARRAY;
            }
            const declaration = argument.params[0];
            if (argument.params.length === 1 && declaration instanceof ObjectPattern) {
                return getDeterministicObjectDestructure(declaration);
            }
            return;
        }
    }
    hasEffects() {
        return true;
    }
    include(context, includeChildrenRecursively) {
        if (!this.included) {
            this.included = true;
            this.scope.context.includeDynamicImport(this);
            this.scope.addAccessedDynamicImport(this);
        }
        this.source.include(context, includeChildrenRecursively);
    }
    initialise() {
        super.initialise();
        this.scope.context.addDynamicImport(this);
    }
    parseNode(esTreeNode) {
        this.sourceAstNode = esTreeNode.source;
        return super.parseNode(esTreeNode);
    }
    render(code, options) {
        const { snippets: { _, getDirectReturnFunction, getObject, getPropertyAccess } } = options;
        if (this.inlineNamespace) {
            const [left, right] = getDirectReturnFunction([], {
                functionReturn: true,
                lineBreakIndent: null,
                name: null
            });
            code.overwrite(this.start, this.end, `Promise.resolve().then(${left}${this.inlineNamespace.getName(getPropertyAccess)}${right})`);
            return;
        }
        if (this.mechanism) {
            code.overwrite(this.start, findFirstOccurrenceOutsideComment(code.original, '(', this.start + 6) + 1, this.mechanism.left);
            code.overwrite(this.end - 1, this.end, this.mechanism.right);
        }
        if (this.resolutionString) {
            code.overwrite(this.source.start, this.source.end, this.resolutionString);
            if (this.namespaceExportName) {
                const [left, right] = getDirectReturnFunction(['n'], {
                    functionReturn: true,
                    lineBreakIndent: null,
                    name: null
                });
                code.prependLeft(this.end, `.then(${left}n.${this.namespaceExportName}${right})`);
            }
        }
        else {
            this.source.render(code, options);
        }
        if (this.attributes !== true) {
            if (this.options) {
                code.overwrite(this.source.end, this.end - 1, '', { contentOnly: true });
            }
            if (this.attributes) {
                code.appendLeft(this.end - 1, `,${_}${getObject([['assert', this.attributes]], {
                    lineBreakIndent: null
                })}`);
            }
        }
    }
    setExternalResolution(exportMode, resolution, options, snippets, pluginDriver, accessedGlobalsByScope, resolutionString, namespaceExportName, attributes) {
        const { format } = options;
        this.inlineNamespace = null;
        this.resolution = resolution;
        this.resolutionString = resolutionString;
        this.namespaceExportName = namespaceExportName;
        this.attributes = attributes;
        const accessedGlobals = [...(accessedImportGlobals[format] || [])];
        let helper;
        ({ helper, mechanism: this.mechanism } = this.getDynamicImportMechanismAndHelper(resolution, exportMode, options, snippets, pluginDriver));
        if (helper) {
            accessedGlobals.push(helper);
        }
        if (accessedGlobals.length > 0) {
            this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);
        }
    }
    setInternalResolution(inlineNamespace) {
        this.inlineNamespace = inlineNamespace;
    }
    applyDeoptimizations() { }
    getDynamicImportMechanismAndHelper(resolution, exportMode, { compact, dynamicImportInCjs, format, generatedCode: { arrowFunctions }, interop }, { _, getDirectReturnFunction, getDirectReturnIifeLeft }, pluginDriver) {
        const mechanism = pluginDriver.hookFirstSync('renderDynamicImport', [
            {
                customResolution: typeof this.resolution === 'string' ? this.resolution : null,
                format,
                moduleId: this.scope.context.module.id,
                targetModuleId: this.resolution && typeof this.resolution !== 'string' ? this.resolution.id : null
            }
        ]);
        if (mechanism) {
            return { helper: null, mechanism };
        }
        const hasDynamicTarget = !this.resolution || typeof this.resolution === 'string';
        switch (format) {
            case 'cjs': {
                if (dynamicImportInCjs &&
                    (!resolution || typeof resolution === 'string' || resolution instanceof ExternalModule)) {
                    return { helper: null, mechanism: null };
                }
                const helper = getInteropHelper(resolution, exportMode, interop);
                let left = `require(`;
                let right = `)`;
                if (helper) {
                    left = `/*#__PURE__*/${helper}(${left}`;
                    right += ')';
                }
                const [functionLeft, functionRight] = getDirectReturnFunction([], {
                    functionReturn: true,
                    lineBreakIndent: null,
                    name: null
                });
                left = `Promise.resolve().then(${functionLeft}${left}`;
                right += `${functionRight})`;
                if (!arrowFunctions && hasDynamicTarget) {
                    left = getDirectReturnIifeLeft(['t'], `${left}t${right}`, {
                        needsArrowReturnParens: false,
                        needsWrappedFunction: true
                    });
                    right = ')';
                }
                return {
                    helper,
                    mechanism: { left, right }
                };
            }
            case 'amd': {
                const resolve = compact ? 'c' : 'resolve';
                const reject = compact ? 'e' : 'reject';
                const helper = getInteropHelper(resolution, exportMode, interop);
                const [resolveLeft, resolveRight] = getDirectReturnFunction(['m'], {
                    functionReturn: false,
                    lineBreakIndent: null,
                    name: null
                });
                const resolveNamespace = helper
                    ? `${resolveLeft}${resolve}(/*#__PURE__*/${helper}(m))${resolveRight}`
                    : resolve;
                const [handlerLeft, handlerRight] = getDirectReturnFunction([resolve, reject], {
                    functionReturn: false,
                    lineBreakIndent: null,
                    name: null
                });
                let left = `new Promise(${handlerLeft}require([`;
                let right = `],${_}${resolveNamespace},${_}${reject})${handlerRight})`;
                if (!arrowFunctions && hasDynamicTarget) {
                    left = getDirectReturnIifeLeft(['t'], `${left}t${right}`, {
                        needsArrowReturnParens: false,
                        needsWrappedFunction: true
                    });
                    right = ')';
                }
                return {
                    helper,
                    mechanism: { left, right }
                };
            }
            case 'system': {
                return {
                    helper: null,
                    mechanism: {
                        left: 'module.import(',
                        right: ')'
                    }
                };
            }
        }
        return { helper: null, mechanism: null };
    }
}
function getInteropHelper(resolution, exportMode, interop) {
    return exportMode === 'external'
        ? namespaceInteropHelpersByInteropType[interop(resolution instanceof ExternalModule ? resolution.id : null)]
        : exportMode === 'default'
            ? INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE
            : null;
}
const accessedImportGlobals = {
    amd: ['require'],
    cjs: ['require'],
    system: ['module']
};
function getDeterministicObjectDestructure(objectPattern) {
    const variables = [];
    for (const property of objectPattern.properties) {
        if (property.type === 'RestElement' || property.computed || property.key.type !== 'Identifier')
            return;
        variables.push(property.key.name);
    }
    return variables;
}

class ImportNamespaceSpecifier extends NodeBase {
    applyDeoptimizations() { }
}

class ImportSpecifier extends NodeBase {
    applyDeoptimizations() { }
}

class JSXIdentifier extends IdentifierBase {
    constructor() {
        super(...arguments);
        this.isNativeElement = false;
    }
    bind() {
        const type = this.getType();
        if (type === 0 /* IdentifierType.Reference */) {
            this.variable = this.scope.findVariable(this.name);
            this.variable.addReference(this);
        }
        else if (type === 1 /* IdentifierType.NativeElementName */) {
            this.isNativeElement = true;
        }
    }
    render(code, { snippets: { getPropertyAccess }, useOriginalName }) {
        if (this.variable) {
            const name = this.variable.getName(getPropertyAccess, useOriginalName);
            if (name !== this.name) {
                code.overwrite(this.start, this.end, name, {
                    contentOnly: true,
                    storeName: true
                });
            }
        }
        else if (this.isNativeElement &&
            this.scope.context.options.jsx.mode !== 'preserve') {
            code.update(this.start, this.end, JSON.stringify(this.name));
        }
    }
    getType() {
        switch (this.parent.type) {
            case 'JSXOpeningElement':
            case 'JSXClosingElement': {
                return this.name.startsWith(this.name.charAt(0).toUpperCase())
                    ? 0 /* IdentifierType.Reference */
                    : 1 /* IdentifierType.NativeElementName */;
            }
            case 'JSXMemberExpression': {
                return this.parent.object === this
                    ? 0 /* IdentifierType.Reference */
                    : 2 /* IdentifierType.Other */;
            }
            case 'JSXAttribute':
            case 'JSXNamespacedName': {
                return 2 /* IdentifierType.Other */;
            }
            default: {
                /* istanbul ignore next */
                throw new Error(`Unexpected parent node type for JSXIdentifier: ${this.parent.type}`);
            }
        }
    }
}

class JSXAttribute extends NodeBase {
    render(code, options, { jsxMode } = parseAst_js.BLANK) {
        super.render(code, options);
        if (['classic', 'automatic'].includes(jsxMode)) {
            const { name, value } = this;
            const key = name instanceof JSXIdentifier ? name.name : `${name.namespace.name}:${name.name.name}`;
            if (!(jsxMode === 'automatic' && key === 'key')) {
                const safeKey = stringifyObjectKeyIfNeeded(key);
                if (key !== safeKey) {
                    code.overwrite(name.start, name.end, safeKey, { contentOnly: true });
                }
                if (value) {
                    code.overwrite(name.end, value.start, ': ', { contentOnly: true });
                }
                else {
                    code.appendLeft(name.end, ': true');
                }
            }
        }
    }
}

class JSXClosingBase extends NodeBase {
    render(code, options) {
        const { mode } = this.scope.context.options.jsx;
        if (mode !== 'preserve') {
            code.overwrite(this.start, this.end, ')', { contentOnly: true });
        }
        else {
            super.render(code, options);
        }
    }
}

class JSXClosingElement extends JSXClosingBase {
}

class JSXClosingFragment extends JSXClosingBase {
}

class JSXSpreadAttribute extends NodeBase {
    render(code, options) {
        this.argument.render(code, options);
        const { mode } = this.scope.context.options.jsx;
        if (mode !== 'preserve') {
            code.overwrite(this.start, this.argument.start, '', { contentOnly: true });
            code.overwrite(this.argument.end, this.end, '', { contentOnly: true });
        }
    }
}

class JSXEmptyExpression extends NodeBase {
}

class JSXExpressionContainer extends NodeBase {
    render(code, options) {
        const { mode } = this.scope.context.options.jsx;
        if (mode !== 'preserve') {
            code.remove(this.start, this.expression.start);
            code.remove(this.expression.end, this.end);
        }
        this.expression.render(code, options);
    }
}

function getRenderedJsxChildren(children) {
    let renderedChildren = 0;
    for (const child of children) {
        if (!(child instanceof JSXExpressionContainer && child.expression instanceof JSXEmptyExpression)) {
            renderedChildren++;
        }
    }
    return renderedChildren;
}

function getAndIncludeFactoryVariable(factory, preserve, importSource, node) {
    const [baseName, nestedName] = factory.split('.');
    let factoryVariable;
    if (importSource) {
        factoryVariable = node.scope.context.getImportedJsxFactoryVariable(nestedName ? 'default' : baseName, node.start, importSource);
        if (preserve) {
            // This pretends we are accessing an included global variable of the same name
            const globalVariable = node.scope.findGlobal(baseName);
            globalVariable.include();
            // This excludes this variable from renaming
            factoryVariable.globalName = baseName;
        }
    }
    else {
        factoryVariable = node.scope.findGlobal(baseName);
    }
    node.scope.context.includeVariableInModule(factoryVariable);
    if (factoryVariable instanceof LocalVariable) {
        factoryVariable.consolidateInitializers();
        factoryVariable.addUsedPlace(node);
        node.scope.context.requestTreeshakingPass();
    }
    return factoryVariable;
}

class JSXElementBase extends NodeBase {
    constructor() {
        super(...arguments);
        this.factoryVariable = null;
        this.factory = null;
    }
    initialise() {
        super.initialise();
        const { importSource } = (this.jsxMode = this.getRenderingMode());
        if (importSource) {
            this.scope.context.addImportSource(importSource);
        }
    }
    include(context, includeChildrenRecursively) {
        if (!this.included) {
            const { factory, importSource, mode } = this.jsxMode;
            if (factory) {
                this.factory = factory;
                this.factoryVariable = getAndIncludeFactoryVariable(factory, mode === 'preserve', importSource, this);
            }
        }
        super.include(context, includeChildrenRecursively);
    }
    applyDeoptimizations() { }
    getRenderingMode() {
        const jsx = this.scope.context.options.jsx;
        const { mode, factory, importSource } = jsx;
        if (mode === 'automatic') {
            return {
                factory: getRenderedJsxChildren(this.children) > 1 ? 'jsxs' : 'jsx',
                importSource: jsx.jsxImportSource,
                mode
            };
        }
        return { factory, importSource, mode };
    }
    renderChildren(code, options, openingEnd) {
        const { children } = this;
        let hasMultipleChildren = false;
        let childrenEnd = openingEnd;
        let firstChild = null;
        for (const child of children) {
            if (child instanceof JSXExpressionContainer &&
                child.expression instanceof JSXEmptyExpression) {
                code.remove(childrenEnd, child.end);
            }
            else {
                code.appendLeft(childrenEnd, ', ');
                child.render(code, options);
                if (firstChild) {
                    hasMultipleChildren = true;
                }
                else {
                    firstChild = child;
                }
            }
            childrenEnd = child.end;
        }
        return { childrenEnd, firstChild, hasMultipleChildren };
    }
}

class JSXElement extends JSXElementBase {
    render(code, options) {
        switch (this.jsxMode.mode) {
            case 'classic': {
                this.renderClassicMode(code, options);
                break;
            }
            case 'automatic': {
                this.renderAutomaticMode(code, options);
                break;
            }
            default: {
                super.render(code, options);
            }
        }
    }
    getRenderingMode() {
        const jsx = this.scope.context.options.jsx;
        const { mode, factory, importSource } = jsx;
        if (mode === 'automatic') {
            // In the case there is a key after a spread attribute, we fall back to
            // classic mode, see https://github.com/facebook/react/issues/20031#issuecomment-710346866
            // for reasoning.
            let hasSpread = false;
            for (const attribute of this.openingElement.attributes) {
                if (attribute instanceof JSXSpreadAttribute) {
                    hasSpread = true;
                }
                else if (hasSpread && attribute.name.name === 'key') {
                    return { factory, importSource, mode: 'classic' };
                }
            }
        }
        return super.getRenderingMode();
    }
    renderClassicMode(code, options) {
        const { snippets: { getPropertyAccess }, useOriginalName } = options;
        const { closingElement, end, factory, factoryVariable, openingElement: { end: openingEnd, selfClosing } } = this;
        const [, ...nestedName] = factory.split('.');
        const { firstAttribute, hasAttributes, hasSpread, inObject, previousEnd } = this.renderAttributes(code, options, [factoryVariable.getName(getPropertyAccess, useOriginalName), ...nestedName].join('.'), false);
        this.wrapAttributes(code, inObject, hasAttributes, hasSpread, firstAttribute, 'null', previousEnd);
        this.renderChildren(code, options, openingEnd);
        if (selfClosing) {
            code.appendLeft(end, ')');
        }
        else {
            closingElement.render(code, options);
        }
    }
    renderAutomaticMode(code, options) {
        const { snippets: { getPropertyAccess }, useOriginalName } = options;
        const { closingElement, end, factoryVariable, openingElement: { end: openindEnd, selfClosing } } = this;
        let { firstAttribute, hasAttributes, hasSpread, inObject, keyAttribute, previousEnd } = this.renderAttributes(code, options, factoryVariable.getName(getPropertyAccess, useOriginalName), true);
        const { firstChild, hasMultipleChildren, childrenEnd } = this.renderChildren(code, options, openindEnd);
        if (firstChild) {
            code.prependRight(firstChild.start, `children: ${hasMultipleChildren ? '[' : ''}`);
            if (!inObject) {
                code.prependRight(firstChild.start, '{ ');
                inObject = true;
            }
            previousEnd = closingElement.start;
            if (hasMultipleChildren) {
                code.appendLeft(previousEnd, ']');
            }
        }
        this.wrapAttributes(code, inObject, hasAttributes || !!firstChild, hasSpread, firstAttribute || firstChild, '{}', childrenEnd);
        if (keyAttribute) {
            const { value } = keyAttribute;
            // This will appear to the left of the moved code...
            code.appendLeft(childrenEnd, ', ');
            if (value) {
                code.move(value.start, value.end, childrenEnd);
            }
            else {
                code.appendLeft(childrenEnd, 'true');
            }
        }
        if (selfClosing) {
            // Moving the key attribute will also move the parenthesis to the right position
            code.appendLeft(keyAttribute?.value?.end || end, ')');
        }
        else {
            closingElement.render(code, options);
        }
    }
    renderAttributes(code, options, factoryName, extractKeyAttribute) {
        const { jsxMode: { mode }, openingElement } = this;
        const { attributes, end: openingEnd, start: openingStart, name: { start: nameStart, end: nameEnd } } = openingElement;
        code.update(openingStart, nameStart, `/*#__PURE__*/${factoryName}(`);
        openingElement.render(code, options, { jsxMode: mode });
        let keyAttribute = null;
        let hasSpread = false;
        let inObject = false;
        let previousEnd = nameEnd;
        let hasAttributes = false;
        let firstAttribute = null;
        for (const attribute of attributes) {
            if (attribute instanceof JSXAttribute) {
                if (extractKeyAttribute && attribute.name.name === 'key') {
                    keyAttribute = attribute;
                    code.remove(previousEnd, attribute.value?.start || attribute.end);
                    continue;
                }
                code.appendLeft(previousEnd, ',');
                if (!inObject) {
                    code.prependRight(attribute.start, '{ ');
                    inObject = true;
                }
                hasAttributes = true;
            }
            else {
                if (inObject) {
                    if (hasAttributes) {
                        code.appendLeft(previousEnd, ' ');
                    }
                    code.appendLeft(previousEnd, '},');
                    inObject = false;
                }
                else {
                    code.appendLeft(previousEnd, ',');
                }
                hasSpread = true;
            }
            previousEnd = attribute.end;
            if (!firstAttribute) {
                firstAttribute = attribute;
            }
        }
        code.remove(attributes.at(-1)?.end || previousEnd, openingEnd);
        return { firstAttribute, hasAttributes, hasSpread, inObject, keyAttribute, previousEnd };
    }
    wrapAttributes(code, inObject, hasAttributes, hasSpread, firstAttribute, missingAttributesFallback, attributesEnd) {
        if (inObject) {
            code.appendLeft(attributesEnd, ' }');
        }
        if (hasSpread) {
            if (hasAttributes) {
                const { start } = firstAttribute;
                if (firstAttribute instanceof JSXSpreadAttribute) {
                    code.prependRight(start, '{}, ');
                }
                code.prependRight(start, 'Object.assign(');
                code.appendLeft(attributesEnd, ')');
            }
        }
        else if (!hasAttributes) {
            code.appendLeft(attributesEnd, `, ${missingAttributesFallback}`);
        }
    }
}

class JSXFragment extends JSXElementBase {
    render(code, options) {
        switch (this.jsxMode.mode) {
            case 'classic': {
                this.renderClassicMode(code, options);
                break;
            }
            case 'automatic': {
                this.renderAutomaticMode(code, options);
                break;
            }
            default: {
                super.render(code, options);
            }
        }
    }
    renderClassicMode(code, options) {
        const { snippets: { getPropertyAccess }, useOriginalName } = options;
        const { closingFragment, factory, factoryVariable, openingFragment, start } = this;
        const [, ...nestedName] = factory.split('.');
        openingFragment.render(code, options);
        code.prependRight(start, `/*#__PURE__*/${[
            factoryVariable.getName(getPropertyAccess, useOriginalName),
            ...nestedName
        ].join('.')}(`);
        code.appendLeft(openingFragment.end, ', null');
        this.renderChildren(code, options, openingFragment.end);
        closingFragment.render(code, options);
    }
    renderAutomaticMode(code, options) {
        const { snippets: { getPropertyAccess }, useOriginalName } = options;
        const { closingFragment, factoryVariable, openingFragment, start } = this;
        openingFragment.render(code, options);
        code.prependRight(start, `/*#__PURE__*/${factoryVariable.getName(getPropertyAccess, useOriginalName)}(`);
        const { firstChild, hasMultipleChildren, childrenEnd } = this.renderChildren(code, options, openingFragment.end);
        if (firstChild) {
            code.prependRight(firstChild.start, `{ children: ${hasMultipleChildren ? '[' : ''}`);
            if (hasMultipleChildren) {
                code.appendLeft(closingFragment.start, ']');
            }
            code.appendLeft(childrenEnd, ' }');
        }
        else {
            code.appendLeft(openingFragment.end, ', {}');
        }
        closingFragment.render(code, options);
    }
}

class JSXMemberExpression extends NodeBase {
}

class JSXNamespacedName extends NodeBase {
}

class JSXOpeningElement extends NodeBase {
    render(code, options, { jsxMode = this.scope.context.options.jsx.mode } = {}) {
        this.name.render(code, options);
        for (const attribute of this.attributes) {
            attribute.render(code, options, { jsxMode });
        }
    }
}

class JSXOpeningFragment extends NodeBase {
    constructor() {
        super(...arguments);
        this.fragment = null;
        this.fragmentVariable = null;
    }
    include(context, includeChildrenRecursively) {
        if (!this.included) {
            const jsx = this.scope.context.options.jsx;
            if (jsx.mode === 'automatic') {
                this.fragment = 'Fragment';
                this.fragmentVariable = getAndIncludeFactoryVariable('Fragment', false, jsx.jsxImportSource, this);
            }
            else {
                const { fragment, importSource, mode } = jsx;
                if (fragment != null) {
                    this.fragment = fragment;
                    this.fragmentVariable = getAndIncludeFactoryVariable(fragment, mode === 'preserve', importSource, this);
                }
            }
        }
        super.include(context, includeChildrenRecursively);
    }
    render(code, options) {
        const { mode } = this.scope.context.options.jsx;
        if (mode !== 'preserve') {
            const { snippets: { getPropertyAccess }, useOriginalName } = options;
            const [, ...nestedFragment] = this.fragment.split('.');
            const fragment = [
                this.fragmentVariable.getName(getPropertyAccess, useOriginalName),
                ...nestedFragment
            ].join('.');
            code.update(this.start, this.end, fragment);
        }
    }
}

class JSXSpreadChild extends NodeBase {
    render(code, options) {
        super.render(code, options);
        const { mode } = this.scope.context.options.jsx;
        if (mode !== 'preserve') {
            code.overwrite(this.start, this.expression.start, '...', { contentOnly: true });
            code.overwrite(this.expression.end, this.end, '', { contentOnly: true });
        }
    }
}

class JSXText extends NodeBase {
    render(code) {
        const { mode } = this.scope.context.options.jsx;
        if (mode !== 'preserve') {
            code.overwrite(this.start, this.end, JSON.stringify(this.value), {
                contentOnly: true
            });
        }
    }
}

class LabeledStatement extends NodeBase {
    hasEffects(context) {
        const { brokenFlow, includedLabels } = context;
        context.ignore.labels.add(this.label.name);
        context.includedLabels = new Set();
        let bodyHasEffects = false;
        if (this.body.hasEffects(context)) {
            bodyHasEffects = true;
        }
        else {
            context.ignore.labels.delete(this.label.name);
            if (context.includedLabels.has(this.label.name)) {
                context.includedLabels.delete(this.label.name);
                context.brokenFlow = brokenFlow;
            }
        }
        context.includedLabels = new Set([...includedLabels, ...context.includedLabels]);
        return bodyHasEffects;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        const { brokenFlow, includedLabels } = context;
        context.includedLabels = new Set();
        this.body.include(context, includeChildrenRecursively);
        if (includeChildrenRecursively || context.includedLabels.has(this.label.name)) {
            this.label.include();
            context.includedLabels.delete(this.label.name);
            context.brokenFlow = brokenFlow;
        }
        context.includedLabels = new Set([...includedLabels, ...context.includedLabels]);
    }
    render(code, options) {
        if (this.label.included) {
            this.label.render(code, options);
        }
        else {
            code.remove(this.start, findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, ':', this.label.end) + 1));
        }
        this.body.render(code, options);
    }
}

class LogicalExpression extends NodeBase {
    constructor() {
        super(...arguments);
        // We collect deoptimization information if usedBranch !== null
        this.expressionsToBeDeoptimized = [];
        this.usedBranch = null;
    }
    //private isBranchResolutionAnalysed = false;
    get isBranchResolutionAnalysed() {
        return isFlagSet(this.flags, 65536 /* Flag.isBranchResolutionAnalysed */);
    }
    set isBranchResolutionAnalysed(value) {
        this.flags = setFlag(this.flags, 65536 /* Flag.isBranchResolutionAnalysed */, value);
    }
    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {
        this.left.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);
        this.right.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);
    }
    deoptimizeCache() {
        if (this.usedBranch) {
            const unusedBranch = this.usedBranch === this.left ? this.right : this.left;
            this.usedBranch = null;
            unusedBranch.deoptimizePath(UNKNOWN_PATH);
            const { scope: { context }, expressionsToBeDeoptimized } = this;
            this.expressionsToBeDeoptimized = parseAst_js.EMPTY_ARRAY;
            for (const expression of expressionsToBeDeoptimized) {
                expression.deoptimizeCache();
            }
            // Request another pass because we need to ensure "include" runs again if
            // it is rendered
            context.requestTreeshakingPass();
        }
    }
    deoptimizePath(path) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch) {
            usedBranch.deoptimizePath(path);
        }
        else {
            this.left.deoptimizePath(path);
            this.right.deoptimizePath(path);
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch)
            return UnknownValue;
        this.expressionsToBeDeoptimized.push(origin);
        return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch)
            return [
                new MultiExpression([
                    this.left.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0],
                    this.right.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0]
                ]),
                false
            ];
        this.expressionsToBeDeoptimized.push(origin);
        return usedBranch.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
    }
    hasEffects(context) {
        if (this.left.hasEffects(context)) {
            return true;
        }
        if (this.getUsedBranch() !== this.left) {
            return this.right.hasEffects(context);
        }
        return false;
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch) {
            return (this.left.hasEffectsOnInteractionAtPath(path, interaction, context) ||
                this.right.hasEffectsOnInteractionAtPath(path, interaction, context));
        }
        return usedBranch.hasEffectsOnInteractionAtPath(path, interaction, context);
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        const usedBranch = this.getUsedBranch();
        if (includeChildrenRecursively ||
            (usedBranch === this.right && this.left.shouldBeIncluded(context)) ||
            !usedBranch) {
            this.left.include(context, includeChildrenRecursively);
            this.right.include(context, includeChildrenRecursively);
        }
        else {
            usedBranch.include(context, includeChildrenRecursively);
        }
    }
    removeAnnotations(code) {
        this.left.removeAnnotations(code);
    }
    render(code, options, { isCalleeOfRenderedParent, preventASI, renderedParentType, renderedSurroundingElement } = parseAst_js.BLANK) {
        if (!this.left.included || !this.right.included) {
            const operatorPos = findFirstOccurrenceOutsideComment(code.original, this.operator, this.left.end);
            if (this.right.included) {
                const removePos = findNonWhiteSpace(code.original, operatorPos + 2);
                code.remove(this.start, removePos);
                if (preventASI) {
                    removeLineBreaks(code, removePos, this.right.start);
                }
                this.left.removeAnnotations(code);
            }
            else {
                code.remove(findLastWhiteSpaceReverse(code.original, this.left.end, operatorPos), this.end);
            }
            this.getUsedBranch().render(code, options, {
                isCalleeOfRenderedParent,
                preventASI,
                renderedParentType: renderedParentType || this.parent.type,
                renderedSurroundingElement: renderedSurroundingElement || this.parent.type
            });
        }
        else {
            this.left.render(code, options, {
                preventASI,
                renderedSurroundingElement
            });
            this.right.render(code, options);
        }
    }
    getUsedBranch() {
        if (!this.isBranchResolutionAnalysed) {
            this.isBranchResolutionAnalysed = true;
            const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
            if (typeof leftValue === 'symbol') {
                return null;
            }
            else {
                this.usedBranch =
                    (this.operator === '||' && leftValue) ||
                        (this.operator === '&&' && !leftValue) ||
                        (this.operator === '??' && leftValue != null)
                        ? this.left
                        : this.right;
            }
        }
        return this.usedBranch;
    }
}

class NewExpression extends NodeBase {
    hasEffects(context) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        for (const argument of this.arguments) {
            if (argument.hasEffects(context))
                return true;
        }
        if (this.annotationPure) {
            return false;
        }
        return (this.callee.hasEffects(context) ||
            this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));
    }
    hasEffectsOnInteractionAtPath(path, { type }) {
        return path.length > 0 || type !== INTERACTION_ACCESSED;
    }
    include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        if (includeChildrenRecursively) {
            super.include(context, includeChildrenRecursively);
        }
        else {
            this.included = true;
            this.callee.include(context, false);
        }
        this.callee.includeCallArguments(context, this.arguments);
    }
    initialise() {
        super.initialise();
        this.interaction = {
            args: [null, ...this.arguments],
            type: INTERACTION_CALLED,
            withNew: true
        };
        if (this.annotations &&
            this.scope.context.options.treeshake.annotations) {
            this.annotationPure = this.annotations.some(comment => comment.type === 'pure');
        }
    }
    render(code, options) {
        this.callee.render(code, options);
        renderCallArguments(code, options, this);
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        this.callee.deoptimizeArgumentsOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);
        this.scope.context.requestTreeshakingPass();
    }
}

class ObjectExpression extends NodeBase {
    constructor() {
        super(...arguments);
        this.objectEntity = null;
    }
    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {
        this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);
    }
    deoptimizeCache() {
        this.getObjectEntity().deoptimizeAllProperties();
    }
    deoptimizePath(path) {
        this.getObjectEntity().deoptimizePath(path);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        return this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);
    }
    render(code, options, { renderedSurroundingElement } = parseAst_js.BLANK) {
        super.render(code, options);
        if (renderedSurroundingElement === parseAst_js.ExpressionStatement ||
            renderedSurroundingElement === parseAst_js.ArrowFunctionExpression) {
            code.appendRight(this.start, '(');
            code.prependLeft(this.end, ')');
        }
    }
    applyDeoptimizations() { }
    getObjectEntity() {
        if (this.objectEntity !== null) {
            return this.objectEntity;
        }
        let prototype = OBJECT_PROTOTYPE;
        const properties = [];
        for (const property of this.properties) {
            if (property instanceof SpreadElement) {
                properties.push({ key: UnknownKey, kind: 'init', property });
                continue;
            }
            let key;
            if (property.computed) {
                const keyValue = property.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
                if (typeof keyValue === 'symbol') {
                    properties.push({ key: UnknownKey, kind: property.kind, property });
                    continue;
                }
                else {
                    key = String(keyValue);
                }
            }
            else {
                key =
                    property.key instanceof Identifier
                        ? property.key.name
                        : String(property.key.value);
                if (key === '__proto__' && property.kind === 'init') {
                    prototype =
                        property.value instanceof Literal && property.value.value === null
                            ? null
                            : property.value;
                    continue;
                }
            }
            properties.push({ key, kind: property.kind, property });
        }
        return (this.objectEntity = new ObjectEntity(properties, prototype));
    }
}

class PanicError extends NodeBase {
    initialise() {
        const id = this.scope.context.module.id;
        // This simulates the current nested error structure. We could also just
        // replace it with a flat error.
        const parseError = parseAst_js.getRollupError(parseAst_js.logParseError(this.message));
        const moduleParseError = parseAst_js.logModuleParseError(parseError, id);
        return parseAst_js.error(moduleParseError);
    }
}

class ParseError extends NodeBase {
    initialise() {
        const pos = this.start;
        const id = this.scope.context.module.id;
        // This simulates the current nested error structure. We could also just
        // replace it with a flat error.
        const parseError = parseAst_js.getRollupError(parseAst_js.logParseError(this.message, pos));
        const moduleParseError = parseAst_js.logModuleParseError(parseError, id);
        this.scope.context.error(moduleParseError, pos);
    }
}

class PrivateIdentifier extends NodeBase {
}

class Program extends NodeBase {
    constructor() {
        super(...arguments);
        this.hasCachedEffect = null;
        this.hasLoggedEffect = false;
    }
    hasCachedEffects() {
        if (!this.included) {
            return false;
        }
        return this.hasCachedEffect === null
            ? (this.hasCachedEffect = this.hasEffects(createHasEffectsContext()))
            : this.hasCachedEffect;
    }
    hasEffects(context) {
        for (const node of this.body) {
            if (node.hasEffects(context)) {
                if (this.scope.context.options.experimentalLogSideEffects && !this.hasLoggedEffect) {
                    this.hasLoggedEffect = true;
                    const { code, log, module } = this.scope.context;
                    log(parseAst_js.LOGLEVEL_INFO, parseAst_js.logFirstSideEffect(code, module.id, parseAst_js.locate(code, node.start, { offsetLine: 1 })), node.start);
                }
                return (this.hasCachedEffect = true);
            }
        }
        return false;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        for (const node of this.body) {
            if (includeChildrenRecursively || node.shouldBeIncluded(context)) {
                node.include(context, includeChildrenRecursively);
            }
        }
    }
    initialise() {
        super.initialise();
        if (this.invalidAnnotations)
            for (const { start, end, type } of this.invalidAnnotations) {
                this.scope.context.magicString.remove(start, end);
                if (type === 'pure' || type === 'noSideEffects') {
                    this.scope.context.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logInvalidAnnotation(this.scope.context.code.slice(start, end), this.scope.context.module.id, type), start);
                }
            }
    }
    render(code, options) {
        let start = this.start;
        if (code.original.startsWith('#!')) {
            start = Math.min(code.original.indexOf('\n') + 1, this.end);
            code.remove(0, start);
        }
        if (this.body.length > 0) {
            // Keep all consecutive lines that start with a comment
            while (code.original[start] === '/' && /[*/]/.test(code.original[start + 1])) {
                const firstLineBreak = findFirstLineBreakOutsideComment(code.original.slice(start, this.body[0].start));
                if (firstLineBreak[0] === -1) {
                    break;
                }
                start += firstLineBreak[1];
            }
            renderStatementList(this.body, code, start, this.end, options);
        }
        else {
            super.render(code, options);
        }
    }
    applyDeoptimizations() { }
}

class Property extends MethodBase {
    constructor() {
        super(...arguments);
        this.declarationInit = null;
    }
    //declare method: boolean;
    get method() {
        return isFlagSet(this.flags, 262144 /* Flag.method */);
    }
    set method(value) {
        this.flags = setFlag(this.flags, 262144 /* Flag.method */, value);
    }
    //declare shorthand: boolean;
    get shorthand() {
        return isFlagSet(this.flags, 524288 /* Flag.shorthand */);
    }
    set shorthand(value) {
        this.flags = setFlag(this.flags, 524288 /* Flag.shorthand */, value);
    }
    declare(kind, init) {
        this.declarationInit = init;
        return this.value.declare(kind, UNKNOWN_EXPRESSION);
    }
    hasEffects(context) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        const propertyReadSideEffects = this.scope.context.options.treeshake.propertyReadSideEffects;
        return ((this.parent.type === 'ObjectPattern' && propertyReadSideEffects === 'always') ||
            this.key.hasEffects(context) ||
            this.value.hasEffects(context));
    }
    markDeclarationReached() {
        this.value.markDeclarationReached();
    }
    render(code, options) {
        if (!this.shorthand) {
            this.key.render(code, options);
        }
        this.value.render(code, options, { isShorthandProperty: this.shorthand });
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        if (this.declarationInit !== null) {
            this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);
            this.scope.context.requestTreeshakingPass();
        }
    }
}

class PropertyDefinition extends NodeBase {
    get computed() {
        return isFlagSet(this.flags, 1024 /* Flag.computed */);
    }
    set computed(value) {
        this.flags = setFlag(this.flags, 1024 /* Flag.computed */, value);
    }
    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {
        this.value?.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);
    }
    deoptimizePath(path) {
        this.value?.deoptimizePath(path);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        return this.value
            ? this.value.getLiteralValueAtPath(path, recursionTracker, origin)
            : UnknownValue;
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        return this.value
            ? this.value.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)
            : UNKNOWN_RETURN_EXPRESSION;
    }
    hasEffects(context) {
        return (this.key.hasEffects(context) ||
            (this.static && !!this.value?.hasEffects(context)) ||
            checkEffectForNodes(this.decorators, context));
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        return !this.value || this.value.hasEffectsOnInteractionAtPath(path, interaction, context);
    }
    applyDeoptimizations() { }
}

class ReturnStatement extends NodeBase {
    hasEffects(context) {
        if (!context.ignore.returnYield || this.argument?.hasEffects(context))
            return true;
        context.brokenFlow = true;
        return false;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        this.argument?.include(context, includeChildrenRecursively);
        context.brokenFlow = true;
    }
    initialise() {
        super.initialise();
        this.scope.addReturnExpression(this.argument || UNKNOWN_EXPRESSION);
    }
    render(code, options) {
        if (this.argument) {
            this.argument.render(code, options, { preventASI: true });
            if (this.argument.start === this.start + 6 /* 'return'.length */) {
                code.prependLeft(this.start + 6, ' ');
            }
        }
    }
}

class SequenceExpression extends NodeBase {
    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {
        this.expressions[this.expressions.length - 1].deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);
    }
    deoptimizePath(path) {
        this.expressions[this.expressions.length - 1].deoptimizePath(path);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(path, recursionTracker, origin);
    }
    hasEffects(context) {
        for (const expression of this.expressions) {
            if (expression.hasEffects(context))
                return true;
        }
        return false;
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        return this.expressions[this.expressions.length - 1].hasEffectsOnInteractionAtPath(path, interaction, context);
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        const lastExpression = this.expressions[this.expressions.length - 1];
        for (const expression of this.expressions) {
            if (includeChildrenRecursively ||
                (expression === lastExpression && !(this.parent instanceof ExpressionStatement)) ||
                expression.shouldBeIncluded(context))
                expression.include(context, includeChildrenRecursively);
        }
    }
    removeAnnotations(code) {
        this.expressions[0].removeAnnotations(code);
    }
    render(code, options, { renderedParentType, isCalleeOfRenderedParent, preventASI } = parseAst_js.BLANK) {
        let includedNodes = 0;
        let lastSeparatorPos = null;
        const lastNode = this.expressions[this.expressions.length - 1];
        for (const { node, separator, start, end } of getCommaSeparatedNodesWithBoundaries(this.expressions, code, this.start, this.end)) {
            if (!node.included) {
                treeshakeNode(node, code, start, end);
                continue;
            }
            includedNodes++;
            lastSeparatorPos = separator;
            if (includedNodes === 1 && preventASI) {
                removeLineBreaks(code, start, node.start);
            }
            if (includedNodes === 1) {
                const parentType = renderedParentType || this.parent.type;
                node.render(code, options, {
                    isCalleeOfRenderedParent: isCalleeOfRenderedParent && node === lastNode,
                    renderedParentType: parentType,
                    renderedSurroundingElement: parentType
                });
            }
            else {
                node.render(code, options);
            }
        }
        if (lastSeparatorPos) {
            code.remove(lastSeparatorPos, this.end);
        }
    }
}

class Super extends NodeBase {
    bind() {
        this.variable = this.scope.findVariable('this');
    }
    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {
        this.variable.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);
    }
    deoptimizePath(path) {
        this.variable.deoptimizePath(path);
    }
    include() {
        if (!this.included) {
            this.included = true;
            this.scope.context.includeVariableInModule(this.variable);
        }
    }
}

class SwitchCase extends NodeBase {
    hasEffects(context) {
        if (this.test?.hasEffects(context))
            return true;
        for (const node of this.consequent) {
            if (context.brokenFlow)
                break;
            if (node.hasEffects(context))
                return true;
        }
        return false;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        this.test?.include(context, includeChildrenRecursively);
        for (const node of this.consequent) {
            if (includeChildrenRecursively || node.shouldBeIncluded(context))
                node.include(context, includeChildrenRecursively);
        }
    }
    render(code, options, nodeRenderOptions) {
        if (this.consequent.length > 0) {
            if (this.test) {
                this.test.render(code, options);
            }
            const testEnd = this.test
                ? this.test.end
                : findFirstOccurrenceOutsideComment(code.original, 'default', this.start) + 7;
            const consequentStart = findFirstOccurrenceOutsideComment(code.original, ':', testEnd) + 1;
            renderStatementList(this.consequent, code, consequentStart, nodeRenderOptions.end, options);
        }
        else {
            super.render(code, options);
        }
    }
}
SwitchCase.prototype.needsBoundaries = true;

class SwitchStatement extends NodeBase {
    createScope(parentScope) {
        this.parentScope = parentScope;
        this.scope = new BlockScope(parentScope);
    }
    hasEffects(context) {
        if (this.discriminant.hasEffects(context))
            return true;
        const { brokenFlow, hasBreak, ignore } = context;
        const { breaks } = ignore;
        ignore.breaks = true;
        context.hasBreak = false;
        let onlyHasBrokenFlow = true;
        for (const switchCase of this.cases) {
            if (switchCase.hasEffects(context))
                return true;
            onlyHasBrokenFlow &&= context.brokenFlow && !context.hasBreak;
            context.hasBreak = false;
            context.brokenFlow = brokenFlow;
        }
        if (this.defaultCase !== null) {
            context.brokenFlow = onlyHasBrokenFlow;
        }
        ignore.breaks = breaks;
        context.hasBreak = hasBreak;
        return false;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        this.discriminant.include(context, includeChildrenRecursively);
        const { brokenFlow, hasBreak } = context;
        context.hasBreak = false;
        let onlyHasBrokenFlow = true;
        let isCaseIncluded = includeChildrenRecursively ||
            (this.defaultCase !== null && this.defaultCase < this.cases.length - 1);
        for (let caseIndex = this.cases.length - 1; caseIndex >= 0; caseIndex--) {
            const switchCase = this.cases[caseIndex];
            if (switchCase.included) {
                isCaseIncluded = true;
            }
            if (!isCaseIncluded) {
                const hasEffectsContext = createHasEffectsContext();
                hasEffectsContext.ignore.breaks = true;
                isCaseIncluded = switchCase.hasEffects(hasEffectsContext);
            }
            if (isCaseIncluded) {
                switchCase.include(context, includeChildrenRecursively);
                onlyHasBrokenFlow &&= context.brokenFlow && !context.hasBreak;
                context.hasBreak = false;
                context.brokenFlow = brokenFlow;
            }
            else {
                onlyHasBrokenFlow = brokenFlow;
            }
        }
        if (isCaseIncluded && this.defaultCase !== null) {
            context.brokenFlow = onlyHasBrokenFlow;
        }
        context.hasBreak = hasBreak;
    }
    initialise() {
        super.initialise();
        for (let caseIndex = 0; caseIndex < this.cases.length; caseIndex++) {
            if (this.cases[caseIndex].test === null) {
                this.defaultCase = caseIndex;
                return;
            }
        }
        this.defaultCase = null;
    }
    parseNode(esTreeNode) {
        this.discriminant = new (this.scope.context.getNodeConstructor(esTreeNode.discriminant.type))(this, this.parentScope).parseNode(esTreeNode.discriminant);
        return super.parseNode(esTreeNode);
    }
    render(code, options) {
        this.discriminant.render(code, options);
        if (this.cases.length > 0) {
            renderStatementList(this.cases, code, this.cases[0].start, this.end - 1, options);
        }
    }
}

class TaggedTemplateExpression extends CallExpressionBase {
    bind() {
        super.bind();
        if (this.tag.type === parseAst_js.Identifier) {
            const name = this.tag.name;
            const variable = this.scope.findVariable(name);
            if (variable.isNamespace) {
                this.scope.context.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logCannotCallNamespace(name), this.start);
            }
        }
    }
    hasEffects(context) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        for (const argument of this.quasi.expressions) {
            if (argument.hasEffects(context))
                return true;
        }
        return (this.tag.hasEffects(context) ||
            this.tag.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));
    }
    include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        if (includeChildrenRecursively) {
            super.include(context, includeChildrenRecursively);
        }
        else {
            this.included = true;
            this.tag.include(context, includeChildrenRecursively);
            this.quasi.include(context, includeChildrenRecursively);
        }
        this.tag.includeCallArguments(context, this.args);
        const [returnExpression] = this.getReturnExpression();
        if (!returnExpression.included) {
            returnExpression.include(context, false);
        }
    }
    initialise() {
        super.initialise();
        this.args = [UNKNOWN_EXPRESSION, ...this.quasi.expressions];
        this.interaction = {
            args: [
                this.tag instanceof MemberExpression && !this.tag.variable ? this.tag.object : null,
                ...this.args
            ],
            type: INTERACTION_CALLED,
            withNew: false
        };
    }
    render(code, options) {
        this.tag.render(code, options, { isCalleeOfRenderedParent: true });
        this.quasi.render(code, options);
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        this.tag.deoptimizeArgumentsOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);
        this.scope.context.requestTreeshakingPass();
    }
    getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {
        if (this.returnExpression === null) {
            this.returnExpression = UNKNOWN_RETURN_EXPRESSION;
            return (this.returnExpression = this.tag.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.interaction, recursionTracker, this));
        }
        return this.returnExpression;
    }
}

class TemplateElement extends NodeBase {
    get tail() {
        return isFlagSet(this.flags, 1048576 /* Flag.tail */);
    }
    set tail(value) {
        this.flags = setFlag(this.flags, 1048576 /* Flag.tail */, value);
    }
    // Do not try to bind value
    bind() { }
    hasEffects() {
        return false;
    }
    include() {
        this.included = true;
    }
    parseNode(esTreeNode) {
        this.value = esTreeNode.value;
        return super.parseNode(esTreeNode);
    }
    render() { }
}

class TemplateLiteral extends NodeBase {
    deoptimizeArgumentsOnInteractionAtPath() { }
    getLiteralValueAtPath(path) {
        if (path.length > 0 || this.quasis.length !== 1) {
            return UnknownValue;
        }
        return this.quasis[0].value.cooked;
    }
    getReturnExpressionWhenCalledAtPath(path) {
        if (path.length !== 1) {
            return UNKNOWN_RETURN_EXPRESSION;
        }
        return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        if (interaction.type === INTERACTION_ACCESSED) {
            return path.length > 1;
        }
        if (interaction.type === INTERACTION_CALLED && path.length === 1) {
            return hasMemberEffectWhenCalled(literalStringMembers, path[0], interaction, context);
        }
        return true;
    }
    render(code, options) {
        code.indentExclusionRanges.push([this.start, this.end]);
        super.render(code, options);
    }
}

class ModuleScope extends ChildScope {
    constructor(parent, context) {
        super(parent, context);
        this.variables.set('this', new LocalVariable('this', null, UNDEFINED_EXPRESSION, context, 'other'));
    }
    addDeclaration(identifier, context, init, kind) {
        if (this.context.module.importDescriptions.has(identifier.name)) {
            context.error(parseAst_js.logRedeclarationError(identifier.name), identifier.start);
        }
        return super.addDeclaration(identifier, context, init, kind);
    }
    addExportDefaultDeclaration(name, exportDefaultDeclaration, context) {
        const variable = new ExportDefaultVariable(name, exportDefaultDeclaration, context);
        this.variables.set('default', variable);
        return variable;
    }
    addNamespaceMemberAccess() { }
    deconflict(format, exportNamesByVariable, accessedGlobalsByScope) {
        // all module level variables are already deconflicted when deconflicting the chunk
        for (const scope of this.children)
            scope.deconflict(format, exportNamesByVariable, accessedGlobalsByScope);
    }
    findLexicalBoundary() {
        return this;
    }
    findVariable(name) {
        const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);
        if (knownVariable) {
            return knownVariable;
        }
        const variable = this.context.traceVariable(name) || this.parent.findVariable(name);
        if (variable instanceof GlobalVariable) {
            this.accessedOutsideVariables.set(name, variable);
        }
        return variable;
    }
}

class ThisExpression extends NodeBase {
    bind() {
        this.variable = this.scope.findVariable('this');
    }
    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {
        this.variable.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);
    }
    deoptimizePath(path) {
        this.variable.deoptimizePath(path);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        if (path.length === 0) {
            return interaction.type !== INTERACTION_ACCESSED;
        }
        return this.variable.hasEffectsOnInteractionAtPath(path, interaction, context);
    }
    include() {
        if (!this.included) {
            this.included = true;
            this.scope.context.includeVariableInModule(this.variable);
        }
    }
    initialise() {
        super.initialise();
        this.alias =
            this.scope.findLexicalBoundary() instanceof ModuleScope
                ? this.scope.context.moduleContext
                : null;
        if (this.alias === 'undefined') {
            this.scope.context.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logThisIsUndefined(), this.start);
        }
    }
    render(code) {
        if (this.alias !== null) {
            code.overwrite(this.start, this.end, this.alias, {
                contentOnly: false,
                storeName: true
            });
        }
    }
}

class ThrowStatement extends NodeBase {
    hasEffects() {
        return true;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        this.argument.include(context, includeChildrenRecursively);
        context.brokenFlow = true;
    }
    render(code, options) {
        this.argument.render(code, options, { preventASI: true });
        if (this.argument.start === this.start + 5 /* 'throw'.length */) {
            code.prependLeft(this.start + 5, ' ');
        }
    }
}

class TryStatement extends NodeBase {
    constructor() {
        super(...arguments);
        this.directlyIncluded = false;
        this.includedLabelsAfterBlock = null;
    }
    hasEffects(context) {
        return ((this.scope.context.options.treeshake.tryCatchDeoptimization
            ? this.block.body.length > 0
            : this.block.hasEffects(context)) || !!this.finalizer?.hasEffects(context));
    }
    include(context, includeChildrenRecursively) {
        const tryCatchDeoptimization = this.scope.context.options.treeshake?.tryCatchDeoptimization;
        const { brokenFlow, includedLabels } = context;
        if (!this.directlyIncluded || !tryCatchDeoptimization) {
            this.included = true;
            this.directlyIncluded = true;
            this.block.include(context, tryCatchDeoptimization ? INCLUDE_PARAMETERS : includeChildrenRecursively);
            if (includedLabels.size > 0) {
                this.includedLabelsAfterBlock = [...includedLabels];
            }
            context.brokenFlow = brokenFlow;
        }
        else if (this.includedLabelsAfterBlock) {
            for (const label of this.includedLabelsAfterBlock) {
                includedLabels.add(label);
            }
        }
        if (this.handler !== null) {
            this.handler.include(context, includeChildrenRecursively);
            context.brokenFlow = brokenFlow;
        }
        this.finalizer?.include(context, includeChildrenRecursively);
    }
}

const unaryOperators = {
    '!': value => !value,
    '+': value => +value,
    '-': value => -value,
    delete: () => UnknownValue,
    typeof: value => typeof value,
    void: () => undefined,
    '~': value => ~value
};
class UnaryExpression extends NodeBase {
    get prefix() {
        return isFlagSet(this.flags, 2097152 /* Flag.prefix */);
    }
    set prefix(value) {
        this.flags = setFlag(this.flags, 2097152 /* Flag.prefix */, value);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (path.length > 0)
            return UnknownValue;
        const argumentValue = this.argument.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (typeof argumentValue === 'symbol')
            return UnknownValue;
        return unaryOperators[this.operator](argumentValue);
    }
    hasEffects(context) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        if (this.operator === 'typeof' && this.argument instanceof Identifier)
            return false;
        return (this.argument.hasEffects(context) ||
            (this.operator === 'delete' &&
                this.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context)));
    }
    hasEffectsOnInteractionAtPath(path, { type }) {
        return type !== INTERACTION_ACCESSED || path.length > (this.operator === 'void' ? 0 : 1);
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        if (this.operator === 'delete') {
            this.argument.deoptimizePath(EMPTY_PATH);
            this.scope.context.requestTreeshakingPass();
        }
    }
}

class UpdateExpression extends NodeBase {
    hasEffects(context) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        return this.argument.hasEffectsAsAssignmentTarget(context, true);
    }
    hasEffectsOnInteractionAtPath(path, { type }) {
        return path.length > 1 || type !== INTERACTION_ACCESSED;
    }
    include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        this.included = true;
        this.argument.includeAsAssignmentTarget(context, includeChildrenRecursively, true);
    }
    initialise() {
        super.initialise();
        this.argument.setAssignedValue(UNKNOWN_EXPRESSION);
    }
    render(code, options) {
        const { exportNamesByVariable, format, snippets: { _ } } = options;
        this.argument.render(code, options);
        if (format === 'system') {
            const variable = this.argument.variable;
            const exportNames = exportNamesByVariable.get(variable);
            if (exportNames) {
                if (this.prefix) {
                    if (exportNames.length === 1) {
                        renderSystemExportExpression(variable, this.start, this.end, code, options);
                    }
                    else {
                        renderSystemExportSequenceAfterExpression(variable, this.start, this.end, this.parent.type !== parseAst_js.ExpressionStatement, code, options);
                    }
                }
                else {
                    const operator = this.operator[0];
                    renderSystemExportSequenceBeforeExpression(variable, this.start, this.end, this.parent.type !== parseAst_js.ExpressionStatement, code, options, `${_}${operator}${_}1`);
                }
            }
        }
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        this.argument.deoptimizePath(EMPTY_PATH);
        if (this.argument instanceof Identifier) {
            const variable = this.scope.findVariable(this.argument.name);
            variable.markReassigned();
        }
        this.scope.context.requestTreeshakingPass();
    }
}

function areAllDeclarationsIncludedAndNotExported(declarations, exportNamesByVariable) {
    for (const declarator of declarations) {
        if (!declarator.id.included)
            return false;
        if (declarator.id.type === parseAst_js.Identifier) {
            if (exportNamesByVariable.has(declarator.id.variable))
                return false;
        }
        else {
            const exportedVariables = [];
            declarator.id.addExportedVariables(exportedVariables, exportNamesByVariable);
            if (exportedVariables.length > 0)
                return false;
        }
    }
    return true;
}
class VariableDeclaration extends NodeBase {
    deoptimizePath() {
        for (const declarator of this.declarations) {
            declarator.deoptimizePath(EMPTY_PATH);
        }
    }
    hasEffectsOnInteractionAtPath() {
        return false;
    }
    include(context, includeChildrenRecursively, { asSingleStatement } = parseAst_js.BLANK) {
        this.included = true;
        for (const declarator of this.declarations) {
            if (includeChildrenRecursively || declarator.shouldBeIncluded(context))
                declarator.include(context, includeChildrenRecursively);
            const { id, init } = declarator;
            if (asSingleStatement) {
                id.include(context, includeChildrenRecursively);
            }
            if (init &&
                id.included &&
                !init.included &&
                (id instanceof ObjectPattern || id instanceof ArrayPattern)) {
                init.include(context, includeChildrenRecursively);
            }
        }
    }
    initialise() {
        super.initialise();
        this.isUsingDeclaration = this.kind === 'await using' || this.kind === 'using';
        for (const declarator of this.declarations) {
            declarator.declareDeclarator(this.kind, this.isUsingDeclaration);
        }
    }
    removeAnnotations(code) {
        this.declarations[0].removeAnnotations(code);
    }
    render(code, options, nodeRenderOptions = parseAst_js.BLANK) {
        if (this.isUsingDeclaration ||
            areAllDeclarationsIncludedAndNotExported(this.declarations, options.exportNamesByVariable)) {
            for (const declarator of this.declarations) {
                declarator.render(code, options);
            }
            if (!nodeRenderOptions.isNoStatement &&
                code.original.charCodeAt(this.end - 1) !== 59 /*";"*/) {
                code.appendLeft(this.end, ';');
            }
        }
        else {
            this.renderReplacedDeclarations(code, options);
        }
    }
    applyDeoptimizations() { }
    renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, systemPatternExports, options) {
        if (code.original.charCodeAt(this.end - 1) === 59 /*";"*/) {
            code.remove(this.end - 1, this.end);
        }
        separatorString += ';';
        if (lastSeparatorPos === null) {
            code.appendLeft(renderedContentEnd, separatorString);
        }
        else {
            if (code.original.charCodeAt(actualContentEnd - 1) === 10 /*"\n"*/ &&
                (code.original.charCodeAt(this.end) === 10 /*"\n"*/ ||
                    code.original.charCodeAt(this.end) === 13) /*"\r"*/) {
                actualContentEnd--;
                if (code.original.charCodeAt(actualContentEnd) === 13 /*"\r"*/) {
                    actualContentEnd--;
                }
            }
            if (actualContentEnd === lastSeparatorPos + 1) {
                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString);
            }
            else {
                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
                code.remove(actualContentEnd, renderedContentEnd);
            }
        }
        if (systemPatternExports.length > 0) {
            code.appendLeft(renderedContentEnd, ` ${getSystemExportStatement(systemPatternExports, options)};`);
        }
    }
    renderReplacedDeclarations(code, options) {
        const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.declarations, code, this.start + this.kind.length, this.end - (code.original.charCodeAt(this.end - 1) === 59 /*";"*/ ? 1 : 0));
        let actualContentEnd, renderedContentEnd;
        renderedContentEnd = findNonWhiteSpace(code.original, this.start + this.kind.length);
        let lastSeparatorPos = renderedContentEnd - 1;
        code.remove(this.start, lastSeparatorPos);
        let isInDeclaration = false;
        let hasRenderedContent = false;
        let separatorString = '', leadingString, nextSeparatorString;
        const aggregatedSystemExports = [];
        const singleSystemExport = gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports);
        for (const { node, start, separator, contentEnd, end } of separatedNodes) {
            if (!node.included) {
                code.remove(start, end);
                node.removeAnnotations(code);
                continue;
            }
            node.render(code, options);
            leadingString = '';
            nextSeparatorString = '';
            if (!node.id.included ||
                (node.id instanceof Identifier &&
                    isReassignedExportsMember(node.id.variable, options.exportNamesByVariable))) {
                if (hasRenderedContent) {
                    separatorString += ';';
                }
                isInDeclaration = false;
            }
            else {
                if (singleSystemExport && singleSystemExport === node.id.variable) {
                    const operatorPos = findFirstOccurrenceOutsideComment(code.original, '=', node.id.end);
                    renderSystemExportExpression(singleSystemExport, findNonWhiteSpace(code.original, operatorPos + 1), separator === null ? contentEnd : separator, code, options);
                }
                if (isInDeclaration) {
                    separatorString += ',';
                }
                else {
                    if (hasRenderedContent) {
                        separatorString += ';';
                    }
                    leadingString += `${this.kind} `;
                    isInDeclaration = true;
                }
            }
            if (renderedContentEnd === lastSeparatorPos + 1) {
                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString + leadingString);
            }
            else {
                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
                code.appendLeft(renderedContentEnd, leadingString);
            }
            actualContentEnd = contentEnd;
            renderedContentEnd = end;
            hasRenderedContent = true;
            lastSeparatorPos = separator;
            separatorString = nextSeparatorString;
        }
        this.renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, aggregatedSystemExports, options);
    }
}
function gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports) {
    let singleSystemExport = null;
    if (options.format === 'system') {
        for (const { node } of separatedNodes) {
            if (node.id instanceof Identifier &&
                node.init &&
                aggregatedSystemExports.length === 0 &&
                options.exportNamesByVariable.get(node.id.variable)?.length === 1) {
                singleSystemExport = node.id.variable;
                aggregatedSystemExports.push(singleSystemExport);
            }
            else {
                node.id.addExportedVariables(aggregatedSystemExports, options.exportNamesByVariable);
            }
        }
        if (aggregatedSystemExports.length > 1) {
            singleSystemExport = null;
        }
        else if (singleSystemExport) {
            aggregatedSystemExports.length = 0;
        }
    }
    return singleSystemExport;
}

class WhileStatement extends NodeBase {
    hasEffects(context) {
        if (this.test.hasEffects(context))
            return true;
        return hasLoopBodyEffects(context, this.body);
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        this.test.include(context, includeChildrenRecursively);
        includeLoopBody(context, this.body, includeChildrenRecursively);
    }
}

class YieldExpression extends NodeBase {
    hasEffects(context) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        return !(context.ignore.returnYield && !this.argument?.hasEffects(context));
    }
    render(code, options) {
        if (this.argument) {
            this.argument.render(code, options, { preventASI: true });
            if (this.argument.start === this.start + 5 /* 'yield'.length */) {
                code.prependLeft(this.start + 5, ' ');
            }
        }
    }
}

// This file is generated by scripts/generate-buffer-parsers.js.
// Do not edit this file directly.
function convertProgram(buffer, parent, parentScope) {
    return convertNode(parent, parentScope, 0, parseAst_js.getAstBuffer(buffer));
}
const nodeTypeStrings = [
    'PanicError',
    'ParseError',
    'ArrayExpression',
    'ArrayPattern',
    'ArrowFunctionExpression',
    'AssignmentExpression',
    'AssignmentPattern',
    'AwaitExpression',
    'BinaryExpression',
    'BlockStatement',
    'BreakStatement',
    'CallExpression',
    'CatchClause',
    'ChainExpression',
    'ClassBody',
    'ClassDeclaration',
    'ClassExpression',
    'ConditionalExpression',
    'ContinueStatement',
    'DebuggerStatement',
    'Decorator',
    'ExpressionStatement',
    'DoWhileStatement',
    'EmptyStatement',
    'ExportAllDeclaration',
    'ExportDefaultDeclaration',
    'ExportNamedDeclaration',
    'ExportSpecifier',
    'ExpressionStatement',
    'ForInStatement',
    'ForOfStatement',
    'ForStatement',
    'FunctionDeclaration',
    'FunctionExpression',
    'Identifier',
    'IfStatement',
    'ImportAttribute',
    'ImportDeclaration',
    'ImportDefaultSpecifier',
    'ImportExpression',
    'ImportNamespaceSpecifier',
    'ImportSpecifier',
    'JSXAttribute',
    'JSXClosingElement',
    'JSXClosingFragment',
    'JSXElement',
    'JSXEmptyExpression',
    'JSXExpressionContainer',
    'JSXFragment',
    'JSXIdentifier',
    'JSXMemberExpression',
    'JSXNamespacedName',
    'JSXOpeningElement',
    'JSXOpeningFragment',
    'JSXSpreadAttribute',
    'JSXSpreadChild',
    'JSXText',
    'LabeledStatement',
    'Literal',
    'Literal',
    'Literal',
    'Literal',
    'Literal',
    'Literal',
    'LogicalExpression',
    'MemberExpression',
    'MetaProperty',
    'MethodDefinition',
    'NewExpression',
    'ObjectExpression',
    'ObjectPattern',
    'PrivateIdentifier',
    'Program',
    'Property',
    'PropertyDefinition',
    'RestElement',
    'ReturnStatement',
    'SequenceExpression',
    'SpreadElement',
    'StaticBlock',
    'Super',
    'SwitchCase',
    'SwitchStatement',
    'TaggedTemplateExpression',
    'TemplateElement',
    'TemplateLiteral',
    'ThisExpression',
    'ThrowStatement',
    'TryStatement',
    'UnaryExpression',
    'UpdateExpression',
    'VariableDeclaration',
    'VariableDeclarator',
    'WhileStatement',
    'YieldExpression'
];
const nodeConstructors$1 = [
    PanicError,
    ParseError,
    ArrayExpression,
    ArrayPattern,
    ArrowFunctionExpression,
    AssignmentExpression,
    AssignmentPattern,
    AwaitExpression,
    BinaryExpression,
    BlockStatement,
    BreakStatement,
    CallExpression,
    CatchClause,
    ChainExpression,
    ClassBody,
    ClassDeclaration,
    ClassExpression,
    ConditionalExpression,
    ContinueStatement,
    DebuggerStatement,
    Decorator,
    ExpressionStatement,
    DoWhileStatement,
    EmptyStatement,
    ExportAllDeclaration,
    ExportDefaultDeclaration,
    ExportNamedDeclaration,
    ExportSpecifier,
    ExpressionStatement,
    ForInStatement,
    ForOfStatement,
    ForStatement,
    FunctionDeclaration,
    FunctionExpression,
    Identifier,
    IfStatement,
    ImportAttribute,
    ImportDeclaration,
    ImportDefaultSpecifier,
    ImportExpression,
    ImportNamespaceSpecifier,
    ImportSpecifier,
    JSXAttribute,
    JSXClosingElement,
    JSXClosingFragment,
    JSXElement,
    JSXEmptyExpression,
    JSXExpressionContainer,
    JSXFragment,
    JSXIdentifier,
    JSXMemberExpression,
    JSXNamespacedName,
    JSXOpeningElement,
    JSXOpeningFragment,
    JSXSpreadAttribute,
    JSXSpreadChild,
    JSXText,
    LabeledStatement,
    Literal,
    Literal,
    Literal,
    Literal,
    Literal,
    Literal,
    LogicalExpression,
    MemberExpression,
    MetaProperty,
    MethodDefinition,
    NewExpression,
    ObjectExpression,
    ObjectPattern,
    PrivateIdentifier,
    Program,
    Property,
    PropertyDefinition,
    RestElement,
    ReturnStatement,
    SequenceExpression,
    SpreadElement,
    StaticBlock,
    Super,
    SwitchCase,
    SwitchStatement,
    TaggedTemplateExpression,
    TemplateElement,
    TemplateLiteral,
    ThisExpression,
    ThrowStatement,
    TryStatement,
    UnaryExpression,
    UpdateExpression,
    VariableDeclaration,
    VariableDeclarator,
    WhileStatement,
    YieldExpression
];
const bufferParsers = [
    function panicError(node, position, buffer) {
        node.message = buffer.convertString(buffer[position]);
    },
    function parseError(node, position, buffer) {
        node.message = buffer.convertString(buffer[position]);
    },
    function arrayExpression(node, position, buffer) {
        const { scope } = node;
        node.elements = convertNodeList(node, scope, buffer[position], buffer);
    },
    function arrayPattern(node, position, buffer) {
        const { scope } = node;
        node.elements = convertNodeList(node, scope, buffer[position], buffer);
    },
    function arrowFunctionExpression(node, position, buffer) {
        const { scope } = node;
        const flags = buffer[position];
        node.async = (flags & 1) === 1;
        node.expression = (flags & 2) === 2;
        node.generator = (flags & 4) === 4;
        const annotations = (node.annotations = parseAst_js.convertAnnotations(buffer[position + 1], buffer));
        node.annotationNoSideEffects = annotations.some(comment => comment.type === 'noSideEffects');
        const parameters = (node.params = convertNodeList(node, scope, buffer[position + 2], buffer));
        scope.addParameterVariables(parameters.map(parameter => parameter.declare('parameter', UNKNOWN_EXPRESSION)), parameters[parameters.length - 1] instanceof RestElement);
        node.body = convertNode(node, scope.bodyScope, buffer[position + 3], buffer);
    },
    function assignmentExpression(node, position, buffer) {
        const { scope } = node;
        node.operator = parseAst_js.FIXED_STRINGS[buffer[position]];
        node.left = convertNode(node, scope, buffer[position + 1], buffer);
        node.right = convertNode(node, scope, buffer[position + 2], buffer);
    },
    function assignmentPattern(node, position, buffer) {
        const { scope } = node;
        node.left = convertNode(node, scope, buffer[position], buffer);
        node.right = convertNode(node, scope, buffer[position + 1], buffer);
    },
    function awaitExpression(node, position, buffer) {
        const { scope } = node;
        node.argument = convertNode(node, scope, buffer[position], buffer);
    },
    function binaryExpression(node, position, buffer) {
        const { scope } = node;
        node.operator = parseAst_js.FIXED_STRINGS[buffer[position]];
        node.left = convertNode(node, scope, buffer[position + 1], buffer);
        node.right = convertNode(node, scope, buffer[position + 2], buffer);
    },
    function blockStatement(node, position, buffer) {
        const { scope } = node;
        node.body = convertNodeList(node, scope, buffer[position], buffer);
    },
    function breakStatement(node, position, buffer) {
        const { scope } = node;
        const labelPosition = buffer[position];
        node.label = labelPosition === 0 ? null : convertNode(node, scope, labelPosition, buffer);
    },
    function callExpression(node, position, buffer) {
        const { scope } = node;
        const flags = buffer[position];
        node.optional = (flags & 1) === 1;
        node.annotations = parseAst_js.convertAnnotations(buffer[position + 1], buffer);
        node.callee = convertNode(node, scope, buffer[position + 2], buffer);
        node.arguments = convertNodeList(node, scope, buffer[position + 3], buffer);
    },
    function catchClause(node, position, buffer) {
        const { scope } = node;
        const parameterPosition = buffer[position];
        const parameter = (node.param =
            parameterPosition === 0 ? null : convertNode(node, scope, parameterPosition, buffer));
        parameter?.declare('parameter', UNKNOWN_EXPRESSION);
        node.body = convertNode(node, scope.bodyScope, buffer[position + 1], buffer);
    },
    function chainExpression(node, position, buffer) {
        const { scope } = node;
        node.expression = convertNode(node, scope, buffer[position], buffer);
    },
    function classBody(node, position, buffer) {
        const { scope } = node;
        const bodyPosition = buffer[position];
        if (bodyPosition) {
            const length = buffer[bodyPosition];
            const body = (node.body = new Array(length));
            for (let index = 0; index < length; index++) {
                const nodePosition = buffer[bodyPosition + 1 + index];
                body[index] = convertNode(node, (buffer[nodePosition + 3] & 1) === 0 ? scope.instanceScope : scope, nodePosition, buffer);
            }
        }
        else {
            node.body = [];
        }
    },
    function classDeclaration(node, position, buffer) {
        const { scope } = node;
        node.decorators = convertNodeList(node, scope, buffer[position], buffer);
        const idPosition = buffer[position + 1];
        node.id =
            idPosition === 0 ? null : convertNode(node, scope.parent, idPosition, buffer);
        const superClassPosition = buffer[position + 2];
        node.superClass =
            superClassPosition === 0 ? null : convertNode(node, scope, superClassPosition, buffer);
        node.body = convertNode(node, scope, buffer[position + 3], buffer);
    },
    function classExpression(node, position, buffer) {
        const { scope } = node;
        node.decorators = convertNodeList(node, scope, buffer[position], buffer);
        const idPosition = buffer[position + 1];
        node.id = idPosition === 0 ? null : convertNode(node, scope, idPosition, buffer);
        const superClassPosition = buffer[position + 2];
        node.superClass =
            superClassPosition === 0 ? null : convertNode(node, scope, superClassPosition, buffer);
        node.body = convertNode(node, scope, buffer[position + 3], buffer);
    },
    function conditionalExpression(node, position, buffer) {
        const { scope } = node;
        node.test = convertNode(node, scope, buffer[position], buffer);
        node.consequent = convertNode(node, scope, buffer[position + 1], buffer);
        node.alternate = convertNode(node, scope, buffer[position + 2], buffer);
    },
    function continueStatement(node, position, buffer) {
        const { scope } = node;
        const labelPosition = buffer[position];
        node.label = labelPosition === 0 ? null : convertNode(node, scope, labelPosition, buffer);
    },
    function debuggerStatement() { },
    function decorator(node, position, buffer) {
        const { scope } = node;
        node.expression = convertNode(node, scope, buffer[position], buffer);
    },
    function directive(node, position, buffer) {
        const { scope } = node;
        node.directive = buffer.convertString(buffer[position]);
        node.expression = convertNode(node, scope, buffer[position + 1], buffer);
    },
    function doWhileStatement(node, position, buffer) {
        const { scope } = node;
        node.body = convertNode(node, scope, buffer[position], buffer);
        node.test = convertNode(node, scope, buffer[position + 1], buffer);
    },
    function emptyStatement() { },
    function exportAllDeclaration(node, position, buffer) {
        const { scope } = node;
        const exportedPosition = buffer[position];
        node.exported =
            exportedPosition === 0 ? null : convertNode(node, scope, exportedPosition, buffer);
        node.source = convertNode(node, scope, buffer[position + 1], buffer);
        node.attributes = convertNodeList(node, scope, buffer[position + 2], buffer);
    },
    function exportDefaultDeclaration(node, position, buffer) {
        const { scope } = node;
        node.declaration = convertNode(node, scope, buffer[position], buffer);
    },
    function exportNamedDeclaration(node, position, buffer) {
        const { scope } = node;
        node.specifiers = convertNodeList(node, scope, buffer[position], buffer);
        const sourcePosition = buffer[position + 1];
        node.source = sourcePosition === 0 ? null : convertNode(node, scope, sourcePosition, buffer);
        node.attributes = convertNodeList(node, scope, buffer[position + 2], buffer);
        const declarationPosition = buffer[position + 3];
        node.declaration =
            declarationPosition === 0 ? null : convertNode(node, scope, declarationPosition, buffer);
    },
    function exportSpecifier(node, position, buffer) {
        const { scope } = node;
        node.local = convertNode(node, scope, buffer[position], buffer);
        const exportedPosition = buffer[position + 1];
        node.exported =
            exportedPosition === 0 ? node.local : convertNode(node, scope, exportedPosition, buffer);
    },
    function expressionStatement(node, position, buffer) {
        const { scope } = node;
        node.expression = convertNode(node, scope, buffer[position], buffer);
    },
    function forInStatement(node, position, buffer) {
        const { scope } = node;
        node.left = convertNode(node, scope, buffer[position], buffer);
        node.right = convertNode(node, scope, buffer[position + 1], buffer);
        node.body = convertNode(node, scope, buffer[position + 2], buffer);
    },
    function forOfStatement(node, position, buffer) {
        const { scope } = node;
        const flags = buffer[position];
        node.await = (flags & 1) === 1;
        node.left = convertNode(node, scope, buffer[position + 1], buffer);
        node.right = convertNode(node, scope, buffer[position + 2], buffer);
        node.body = convertNode(node, scope, buffer[position + 3], buffer);
    },
    function forStatement(node, position, buffer) {
        const { scope } = node;
        const initPosition = buffer[position];
        node.init = initPosition === 0 ? null : convertNode(node, scope, initPosition, buffer);
        const testPosition = buffer[position + 1];
        node.test = testPosition === 0 ? null : convertNode(node, scope, testPosition, buffer);
        const updatePosition = buffer[position + 2];
        node.update = updatePosition === 0 ? null : convertNode(node, scope, updatePosition, buffer);
        node.body = convertNode(node, scope, buffer[position + 3], buffer);
    },
    function functionDeclaration(node, position, buffer) {
        const { scope } = node;
        const flags = buffer[position];
        node.async = (flags & 1) === 1;
        node.generator = (flags & 2) === 2;
        const annotations = (node.annotations = parseAst_js.convertAnnotations(buffer[position + 1], buffer));
        node.annotationNoSideEffects = annotations.some(comment => comment.type === 'noSideEffects');
        const idPosition = buffer[position + 2];
        node.id =
            idPosition === 0 ? null : convertNode(node, scope.parent, idPosition, buffer);
        const parameters = (node.params = convertNodeList(node, scope, buffer[position + 3], buffer));
        scope.addParameterVariables(parameters.map(parameter => parameter.declare('parameter', UNKNOWN_EXPRESSION)), parameters[parameters.length - 1] instanceof RestElement);
        node.body = convertNode(node, scope.bodyScope, buffer[position + 4], buffer);
    },
    function functionExpression(node, position, buffer) {
        const { scope } = node;
        const flags = buffer[position];
        node.async = (flags & 1) === 1;
        node.generator = (flags & 2) === 2;
        const annotations = (node.annotations = parseAst_js.convertAnnotations(buffer[position + 1], buffer));
        node.annotationNoSideEffects = annotations.some(comment => comment.type === 'noSideEffects');
        const idPosition = buffer[position + 2];
        node.id = idPosition === 0 ? null : convertNode(node, node.idScope, idPosition, buffer);
        const parameters = (node.params = convertNodeList(node, scope, buffer[position + 3], buffer));
        scope.addParameterVariables(parameters.map(parameter => parameter.declare('parameter', UNKNOWN_EXPRESSION)), parameters[parameters.length - 1] instanceof RestElement);
        node.body = convertNode(node, scope.bodyScope, buffer[position + 4], buffer);
    },
    function identifier(node, position, buffer) {
        node.name = buffer.convertString(buffer[position]);
    },
    function ifStatement(node, position, buffer) {
        const { scope } = node;
        node.test = convertNode(node, scope, buffer[position], buffer);
        node.consequent = convertNode(node, (node.consequentScope = new TrackingScope(scope)), buffer[position + 1], buffer);
        const alternatePosition = buffer[position + 2];
        node.alternate =
            alternatePosition === 0
                ? null
                : convertNode(node, (node.alternateScope = new TrackingScope(scope)), alternatePosition, buffer);
    },
    function importAttribute(node, position, buffer) {
        const { scope } = node;
        node.key = convertNode(node, scope, buffer[position], buffer);
        node.value = convertNode(node, scope, buffer[position + 1], buffer);
    },
    function importDeclaration(node, position, buffer) {
        const { scope } = node;
        node.specifiers = convertNodeList(node, scope, buffer[position], buffer);
        node.source = convertNode(node, scope, buffer[position + 1], buffer);
        node.attributes = convertNodeList(node, scope, buffer[position + 2], buffer);
    },
    function importDefaultSpecifier(node, position, buffer) {
        const { scope } = node;
        node.local = convertNode(node, scope, buffer[position], buffer);
    },
    function importExpression(node, position, buffer) {
        const { scope } = node;
        node.source = convertNode(node, scope, buffer[position], buffer);
        node.sourceAstNode = parseAst_js.convertNode(buffer[position], buffer);
        const optionsPosition = buffer[position + 1];
        node.options = optionsPosition === 0 ? null : convertNode(node, scope, optionsPosition, buffer);
    },
    function importNamespaceSpecifier(node, position, buffer) {
        const { scope } = node;
        node.local = convertNode(node, scope, buffer[position], buffer);
    },
    function importSpecifier(node, position, buffer) {
        const { scope } = node;
        const importedPosition = buffer[position];
        node.local = convertNode(node, scope, buffer[position + 1], buffer);
        node.imported =
            importedPosition === 0 ? node.local : convertNode(node, scope, importedPosition, buffer);
    },
    function jsxAttribute(node, position, buffer) {
        const { scope } = node;
        node.name = convertNode(node, scope, buffer[position], buffer);
        const valuePosition = buffer[position + 1];
        node.value = valuePosition === 0 ? null : convertNode(node, scope, valuePosition, buffer);
    },
    function jsxClosingElement(node, position, buffer) {
        const { scope } = node;
        node.name = convertNode(node, scope, buffer[position], buffer);
    },
    function jsxClosingFragment() { },
    function jsxElement(node, position, buffer) {
        const { scope } = node;
        node.openingElement = convertNode(node, scope, buffer[position], buffer);
        node.children = convertNodeList(node, scope, buffer[position + 1], buffer);
        const closingElementPosition = buffer[position + 2];
        node.closingElement =
            closingElementPosition === 0
                ? null
                : convertNode(node, scope, closingElementPosition, buffer);
    },
    function jsxEmptyExpression() { },
    function jsxExpressionContainer(node, position, buffer) {
        const { scope } = node;
        node.expression = convertNode(node, scope, buffer[position], buffer);
    },
    function jsxFragment(node, position, buffer) {
        const { scope } = node;
        node.openingFragment = convertNode(node, scope, buffer[position], buffer);
        node.children = convertNodeList(node, scope, buffer[position + 1], buffer);
        node.closingFragment = convertNode(node, scope, buffer[position + 2], buffer);
    },
    function jsxIdentifier(node, position, buffer) {
        node.name = buffer.convertString(buffer[position]);
    },
    function jsxMemberExpression(node, position, buffer) {
        const { scope } = node;
        node.object = convertNode(node, scope, buffer[position], buffer);
        node.property = convertNode(node, scope, buffer[position + 1], buffer);
    },
    function jsxNamespacedName(node, position, buffer) {
        const { scope } = node;
        node.namespace = convertNode(node, scope, buffer[position], buffer);
        node.name = convertNode(node, scope, buffer[position + 1], buffer);
    },
    function jsxOpeningElement(node, position, buffer) {
        const { scope } = node;
        const flags = buffer[position];
        node.selfClosing = (flags & 1) === 1;
        node.name = convertNode(node, scope, buffer[position + 1], buffer);
        node.attributes = convertNodeList(node, scope, buffer[position + 2], buffer);
    },
    function jsxOpeningFragment(node) {
        node.attributes = [];
        node.selfClosing = false;
    },
    function jsxSpreadAttribute(node, position, buffer) {
        const { scope } = node;
        node.argument = convertNode(node, scope, buffer[position], buffer);
    },
    function jsxSpreadChild(node, position, buffer) {
        const { scope } = node;
        node.expression = convertNode(node, scope, buffer[position], buffer);
    },
    function jsxText(node, position, buffer) {
        node.value = buffer.convertString(buffer[position]);
        node.raw = buffer.convertString(buffer[position + 1]);
    },
    function labeledStatement(node, position, buffer) {
        const { scope } = node;
        node.label = convertNode(node, scope, buffer[position], buffer);
        node.body = convertNode(node, scope, buffer[position + 1], buffer);
    },
    function literalBigInt(node, position, buffer) {
        const bigint = (node.bigint = buffer.convertString(buffer[position]));
        node.raw = buffer.convertString(buffer[position + 1]);
        node.value = BigInt(bigint);
    },
    function literalBoolean(node, position, buffer) {
        const flags = buffer[position];
        const value = (node.value = (flags & 1) === 1);
        node.raw = value ? 'true' : 'false';
    },
    function literalNull(node) {
        node.value = null;
    },
    function literalNumber(node, position, buffer) {
        const rawPosition = buffer[position];
        node.raw = rawPosition === 0 ? undefined : buffer.convertString(rawPosition);
        node.value = new DataView(buffer.buffer).getFloat64((position + 1) << 2, true);
    },
    function literalRegExp(node, position, buffer) {
        const flags = buffer.convertString(buffer[position]);
        const pattern = buffer.convertString(buffer[position + 1]);
        node.raw = `/${pattern}/${flags}`;
        node.regex = { flags, pattern };
        node.value = new RegExp(pattern, flags);
    },
    function literalString(node, position, buffer) {
        node.value = buffer.convertString(buffer[position]);
        const rawPosition = buffer[position + 1];
        node.raw = rawPosition === 0 ? undefined : buffer.convertString(rawPosition);
    },
    function logicalExpression(node, position, buffer) {
        const { scope } = node;
        node.operator = parseAst_js.FIXED_STRINGS[buffer[position]];
        node.left = convertNode(node, scope, buffer[position + 1], buffer);
        node.right = convertNode(node, scope, buffer[position + 2], buffer);
    },
    function memberExpression(node, position, buffer) {
        const { scope } = node;
        const flags = buffer[position];
        node.computed = (flags & 1) === 1;
        node.optional = (flags & 2) === 2;
        node.object = convertNode(node, scope, buffer[position + 1], buffer);
        node.property = convertNode(node, scope, buffer[position + 2], buffer);
    },
    function metaProperty(node, position, buffer) {
        const { scope } = node;
        node.meta = convertNode(node, scope, buffer[position], buffer);
        node.property = convertNode(node, scope, buffer[position + 1], buffer);
    },
    function methodDefinition(node, position, buffer) {
        const { scope } = node;
        const flags = buffer[position];
        node.static = (flags & 1) === 1;
        node.computed = (flags & 2) === 2;
        node.decorators = convertNodeList(node, scope, buffer[position + 1], buffer);
        node.key = convertNode(node, scope, buffer[position + 2], buffer);
        node.value = convertNode(node, scope, buffer[position + 3], buffer);
        node.kind = parseAst_js.FIXED_STRINGS[buffer[position + 4]];
    },
    function newExpression(node, position, buffer) {
        const { scope } = node;
        node.annotations = parseAst_js.convertAnnotations(buffer[position], buffer);
        node.callee = convertNode(node, scope, buffer[position + 1], buffer);
        node.arguments = convertNodeList(node, scope, buffer[position + 2], buffer);
    },
    function objectExpression(node, position, buffer) {
        const { scope } = node;
        node.properties = convertNodeList(node, scope, buffer[position], buffer);
    },
    function objectPattern(node, position, buffer) {
        const { scope } = node;
        node.properties = convertNodeList(node, scope, buffer[position], buffer);
    },
    function privateIdentifier(node, position, buffer) {
        node.name = buffer.convertString(buffer[position]);
    },
    function program(node, position, buffer) {
        const { scope } = node;
        node.body = convertNodeList(node, scope, buffer[position], buffer);
        node.invalidAnnotations = parseAst_js.convertAnnotations(buffer[position + 1], buffer);
    },
    function property(node, position, buffer) {
        const { scope } = node;
        const flags = buffer[position];
        node.method = (flags & 1) === 1;
        node.shorthand = (flags & 2) === 2;
        node.computed = (flags & 4) === 4;
        const keyPosition = buffer[position + 1];
        node.value = convertNode(node, scope, buffer[position + 2], buffer);
        node.kind = parseAst_js.FIXED_STRINGS[buffer[position + 3]];
        node.key = keyPosition === 0 ? node.value : convertNode(node, scope, keyPosition, buffer);
    },
    function propertyDefinition(node, position, buffer) {
        const { scope } = node;
        const flags = buffer[position];
        node.static = (flags & 1) === 1;
        node.computed = (flags & 2) === 2;
        node.decorators = convertNodeList(node, scope, buffer[position + 1], buffer);
        node.key = convertNode(node, scope, buffer[position + 2], buffer);
        const valuePosition = buffer[position + 3];
        node.value = valuePosition === 0 ? null : convertNode(node, scope, valuePosition, buffer);
    },
    function restElement(node, position, buffer) {
        const { scope } = node;
        node.argument = convertNode(node, scope, buffer[position], buffer);
    },
    function returnStatement(node, position, buffer) {
        const { scope } = node;
        const argumentPosition = buffer[position];
        node.argument =
            argumentPosition === 0 ? null : convertNode(node, scope, argumentPosition, buffer);
    },
    function sequenceExpression(node, position, buffer) {
        const { scope } = node;
        node.expressions = convertNodeList(node, scope, buffer[position], buffer);
    },
    function spreadElement(node, position, buffer) {
        const { scope } = node;
        node.argument = convertNode(node, scope, buffer[position], buffer);
    },
    function staticBlock(node, position, buffer) {
        const { scope } = node;
        node.body = convertNodeList(node, scope, buffer[position], buffer);
    },
    function superElement() { },
    function switchCase(node, position, buffer) {
        const { scope } = node;
        const testPosition = buffer[position];
        node.test = testPosition === 0 ? null : convertNode(node, scope, testPosition, buffer);
        node.consequent = convertNodeList(node, scope, buffer[position + 1], buffer);
    },
    function switchStatement(node, position, buffer) {
        const { scope } = node;
        node.discriminant = convertNode(node, node.parentScope, buffer[position], buffer);
        node.cases = convertNodeList(node, scope, buffer[position + 1], buffer);
    },
    function taggedTemplateExpression(node, position, buffer) {
        const { scope } = node;
        node.tag = convertNode(node, scope, buffer[position], buffer);
        node.quasi = convertNode(node, scope, buffer[position + 1], buffer);
    },
    function templateElement(node, position, buffer) {
        const flags = buffer[position];
        node.tail = (flags & 1) === 1;
        const cookedPosition = buffer[position + 1];
        const cooked = cookedPosition === 0 ? undefined : buffer.convertString(cookedPosition);
        const raw = buffer.convertString(buffer[position + 2]);
        node.value = { cooked, raw };
    },
    function templateLiteral(node, position, buffer) {
        const { scope } = node;
        node.quasis = convertNodeList(node, scope, buffer[position], buffer);
        node.expressions = convertNodeList(node, scope, buffer[position + 1], buffer);
    },
    function thisExpression() { },
    function throwStatement(node, position, buffer) {
        const { scope } = node;
        node.argument = convertNode(node, scope, buffer[position], buffer);
    },
    function tryStatement(node, position, buffer) {
        const { scope } = node;
        node.block = convertNode(node, scope, buffer[position], buffer);
        const handlerPosition = buffer[position + 1];
        node.handler = handlerPosition === 0 ? null : convertNode(node, scope, handlerPosition, buffer);
        const finalizerPosition = buffer[position + 2];
        node.finalizer =
            finalizerPosition === 0 ? null : convertNode(node, scope, finalizerPosition, buffer);
    },
    function unaryExpression(node, position, buffer) {
        const { scope } = node;
        node.operator = parseAst_js.FIXED_STRINGS[buffer[position]];
        node.argument = convertNode(node, scope, buffer[position + 1], buffer);
    },
    function updateExpression(node, position, buffer) {
        const { scope } = node;
        const flags = buffer[position];
        node.prefix = (flags & 1) === 1;
        node.operator = parseAst_js.FIXED_STRINGS[buffer[position + 1]];
        node.argument = convertNode(node, scope, buffer[position + 2], buffer);
    },
    function variableDeclaration(node, position, buffer) {
        const { scope } = node;
        node.kind = parseAst_js.FIXED_STRINGS[buffer[position]];
        node.declarations = convertNodeList(node, scope, buffer[position + 1], buffer);
    },
    function variableDeclarator(node, position, buffer) {
        const { scope } = node;
        node.id = convertNode(node, scope, buffer[position], buffer);
        const initPosition = buffer[position + 1];
        node.init = initPosition === 0 ? null : convertNode(node, scope, initPosition, buffer);
    },
    function whileStatement(node, position, buffer) {
        const { scope } = node;
        node.test = convertNode(node, scope, buffer[position], buffer);
        node.body = convertNode(node, scope, buffer[position + 1], buffer);
    },
    function yieldExpression(node, position, buffer) {
        const { scope } = node;
        const flags = buffer[position];
        node.delegate = (flags & 1) === 1;
        const argumentPosition = buffer[position + 1];
        node.argument =
            argumentPosition === 0 ? null : convertNode(node, scope, argumentPosition, buffer);
    }
];
function convertNode(parent, parentScope, position, buffer) {
    const nodeType = buffer[position];
    const NodeConstructor = nodeConstructors$1[nodeType];
    /* istanbul ignore if: This should never be executed but is a safeguard against faulty buffers */
    if (!NodeConstructor) {
        console.trace();
        throw new Error(`Unknown node type: ${nodeType}`);
    }
    const node = new NodeConstructor(parent, parentScope);
    node.type = nodeTypeStrings[nodeType];
    node.start = buffer[position + 1];
    node.end = buffer[position + 2];
    bufferParsers[nodeType](node, position + 3, buffer);
    node.initialise();
    return node;
}
function convertNodeList(parent, parentScope, position, buffer) {
    if (position === 0)
        return parseAst_js.EMPTY_ARRAY;
    const length = buffer[position++];
    const list = new Array(length);
    for (let index = 0; index < length; index++) {
        const nodePosition = buffer[position++];
        list[index] = nodePosition ? convertNode(parent, parentScope, nodePosition, buffer) : null;
    }
    return list;
}

class UnknownNode extends NodeBase {
    hasEffects() {
        return true;
    }
    include(context) {
        super.include(context, true);
    }
}

// This file is generated by scripts/generate-node-index.js.
// Do not edit this file directly.
const nodeConstructors = {
    ArrayExpression,
    ArrayPattern,
    ArrowFunctionExpression,
    AssignmentExpression,
    AssignmentPattern,
    AwaitExpression,
    BinaryExpression,
    BlockStatement,
    BreakStatement,
    CallExpression,
    CatchClause,
    ChainExpression,
    ClassBody,
    ClassDeclaration,
    ClassExpression,
    ConditionalExpression,
    ContinueStatement,
    DebuggerStatement,
    Decorator,
    DoWhileStatement,
    EmptyStatement,
    ExportAllDeclaration,
    ExportDefaultDeclaration,
    ExportNamedDeclaration,
    ExportSpecifier,
    ExpressionStatement,
    ForInStatement,
    ForOfStatement,
    ForStatement,
    FunctionDeclaration,
    FunctionExpression,
    Identifier,
    IfStatement,
    ImportAttribute,
    ImportDeclaration,
    ImportDefaultSpecifier,
    ImportExpression,
    ImportNamespaceSpecifier,
    ImportSpecifier,
    JSXAttribute,
    JSXClosingElement,
    JSXClosingFragment,
    JSXElement,
    JSXEmptyExpression,
    JSXExpressionContainer,
    JSXFragment,
    JSXIdentifier,
    JSXMemberExpression,
    JSXNamespacedName,
    JSXOpeningElement,
    JSXOpeningFragment,
    JSXSpreadAttribute,
    JSXSpreadChild,
    JSXText,
    LabeledStatement,
    Literal,
    LogicalExpression,
    MemberExpression,
    MetaProperty,
    MethodDefinition,
    NewExpression,
    ObjectExpression,
    ObjectPattern,
    PanicError,
    ParseError,
    PrivateIdentifier,
    Program,
    Property,
    PropertyDefinition,
    RestElement,
    ReturnStatement,
    SequenceExpression,
    SpreadElement,
    StaticBlock,
    Super,
    SwitchCase,
    SwitchStatement,
    TaggedTemplateExpression,
    TemplateElement,
    TemplateLiteral,
    ThisExpression,
    ThrowStatement,
    TryStatement,
    UnaryExpression,
    UnknownNode,
    UpdateExpression,
    VariableDeclaration,
    VariableDeclarator,
    WhileStatement,
    YieldExpression
};

class ExportShimVariable extends Variable {
    constructor(module) {
        super(MISSING_EXPORT_SHIM_VARIABLE);
        this.module = module;
    }
    include() {
        super.include();
        this.module.needsExportShim = true;
    }
}

const sourceMapCache = new WeakMap();
/**
 * This clears the decoded array and falls back to the encoded string form.
 * Sourcemap mappings arrays can be very large and holding on to them for longer
 * than is necessary leads to poor heap utilization.
 */
function resetCacheToEncoded(cache) {
    if (cache.encodedMappings === undefined && cache.decodedMappings) {
        cache.encodedMappings = encode(cache.decodedMappings);
    }
    cache.decodedMappings = undefined;
}
function resetSourcemapCache(map, sourcemapChain) {
    if (map) {
        const cache = sourceMapCache.get(map);
        if (cache) {
            resetCacheToEncoded(cache);
        }
    }
    if (!sourcemapChain) {
        return;
    }
    for (const map of sourcemapChain) {
        if (map.missing)
            continue;
        resetSourcemapCache(map);
    }
}
function decodedSourcemap(map) {
    if (!map)
        return null;
    if (typeof map === 'string') {
        map = JSON.parse(map);
    }
    if (!map.mappings) {
        return {
            mappings: [],
            names: [],
            sources: [],
            version: 3
        };
    }
    const originalMappings = map.mappings;
    const isAlreadyDecoded = Array.isArray(originalMappings);
    const cache = {
        decodedMappings: isAlreadyDecoded ? originalMappings : undefined,
        encodedMappings: isAlreadyDecoded ? undefined : originalMappings
    };
    const decodedMap = {
        ...map,
        // By moving mappings behind an accessor, we can avoid unneeded computation for cases
        // where the mappings field is never actually accessed. This appears to greatly reduce
        // the overhead of sourcemap decoding in terms of both compute time and memory usage.
        get mappings() {
            if (cache.decodedMappings) {
                return cache.decodedMappings;
            }
            // If decodedMappings doesn't exist then encodedMappings should.
            // The only scenario where cache.encodedMappings should be undefined is if the map
            // this was constructed from was already decoded, or if mappings was set to a new
            // decoded string. In either case, this line shouldn't get hit.
            cache.decodedMappings = cache.encodedMappings ? decode(cache.encodedMappings) : [];
            cache.encodedMappings = undefined;
            return cache.decodedMappings;
        }
    };
    sourceMapCache.set(decodedMap, cache);
    return decodedMap;
}

function getId(m) {
    return m.id;
}

function getOriginalLocation(sourcemapChain, location) {
    const filteredSourcemapChain = sourcemapChain.filter((sourcemap) => !sourcemap.missing);
    traceSourcemap: while (filteredSourcemapChain.length > 0) {
        const sourcemap = filteredSourcemapChain.pop();
        const line = sourcemap.mappings[location.line - 1];
        if (line) {
            const filteredLine = line.filter((segment) => segment.length > 1);
            const lastSegment = filteredLine[filteredLine.length - 1];
            for (const segment of filteredLine) {
                if (segment[0] >= location.column || segment === lastSegment) {
                    location = {
                        column: segment[3],
                        line: segment[2] + 1
                    };
                    continue traceSourcemap;
                }
            }
        }
        throw new Error("Can't resolve original location of error.");
    }
    return location;
}

const ATTRIBUTE_KEYWORDS = new Set(['assert', 'with']);
function getAttributesFromImportExpression(node) {
    const { scope: { context }, options, start } = node;
    if (!(options instanceof ObjectExpression)) {
        if (options) {
            context.module.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logImportAttributeIsInvalid(context.module.id), start);
        }
        return parseAst_js.EMPTY_OBJECT;
    }
    const assertProperty = options.properties.find((property) => ATTRIBUTE_KEYWORDS.has(getPropertyKey(property)))?.value;
    if (!assertProperty) {
        return parseAst_js.EMPTY_OBJECT;
    }
    if (!(assertProperty instanceof ObjectExpression)) {
        context.module.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logImportOptionsAreInvalid(context.module.id), start);
        return parseAst_js.EMPTY_OBJECT;
    }
    const assertFields = assertProperty.properties
        .map(property => {
        const key = getPropertyKey(property);
        if (typeof key === 'string' &&
            typeof property.value.value === 'string') {
            return [key, property.value.value];
        }
        context.module.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logImportAttributeIsInvalid(context.module.id), property.start);
        return null;
    })
        .filter((property) => !!property);
    if (assertFields.length > 0) {
        return Object.fromEntries(assertFields);
    }
    return parseAst_js.EMPTY_OBJECT;
}
const getPropertyKey = (property) => {
    const key = property.key;
    return (key &&
        !property.computed &&
        (key.name || key.value));
};
function getAttributesFromImportExportDeclaration(attributes) {
    return attributes?.length
        ? Object.fromEntries(attributes.map(assertion => [getPropertyKey(assertion), assertion.value.value]))
        : parseAst_js.EMPTY_OBJECT;
}
function doAttributesDiffer(assertionA, assertionB) {
    const keysA = Object.keys(assertionA);
    return (keysA.length !== Object.keys(assertionB).length ||
        keysA.some(key => assertionA[key] !== assertionB[key]));
}

let timers = new Map();
function getPersistedLabel(label, level) {
    switch (level) {
        case 1: {
            return `# ${label}`;
        }
        case 2: {
            return `## ${label}`;
        }
        case 3: {
            return label;
        }
        default: {
            return `- ${label}`;
        }
    }
}
function timeStartImpl(label, level = 3) {
    label = getPersistedLabel(label, level);
    const startMemory = process$1.memoryUsage().heapUsed;
    const startTime = node_perf_hooks.performance.now();
    const timer = timers.get(label);
    if (timer === undefined) {
        timers.set(label, {
            memory: 0,
            startMemory,
            startTime,
            time: 0,
            totalMemory: 0
        });
    }
    else {
        timer.startMemory = startMemory;
        timer.startTime = startTime;
    }
}
function timeEndImpl(label, level = 3) {
    label = getPersistedLabel(label, level);
    const timer = timers.get(label);
    if (timer !== undefined) {
        const currentMemory = process$1.memoryUsage().heapUsed;
        timer.memory += currentMemory - timer.startMemory;
        timer.time += node_perf_hooks.performance.now() - timer.startTime;
        timer.totalMemory = Math.max(timer.totalMemory, currentMemory);
    }
}
function getTimings() {
    const newTimings = {};
    for (const [label, { memory, time, totalMemory }] of timers) {
        newTimings[label] = [time, memory, totalMemory];
    }
    return newTimings;
}
let timeStart = doNothing;
let timeEnd = doNothing;
const TIMED_PLUGIN_HOOKS = [
    'augmentChunkHash',
    'buildEnd',
    'buildStart',
    'generateBundle',
    'load',
    'moduleParsed',
    'options',
    'outputOptions',
    'renderChunk',
    'renderDynamicImport',
    'renderStart',
    'resolveDynamicImport',
    'resolveFileUrl',
    'resolveId',
    'resolveImportMeta',
    'shouldTransformCachedModule',
    'transform',
    'writeBundle'
];
function getPluginWithTimers(plugin, index) {
    if (plugin._hasTimer)
        return plugin;
    plugin._hasTimer = true;
    for (const hook of TIMED_PLUGIN_HOOKS) {
        if (hook in plugin) {
            let timerLabel = `plugin ${index}`;
            if (plugin.name) {
                timerLabel += ` (${plugin.name})`;
            }
            timerLabel += ` - ${hook}`;
            const handler = function (...parameters) {
 