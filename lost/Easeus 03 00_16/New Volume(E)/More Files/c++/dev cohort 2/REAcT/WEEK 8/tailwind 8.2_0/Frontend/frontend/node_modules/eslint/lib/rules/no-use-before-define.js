           parent,
            start,
            end,
            raw: this.source.slice(start, end),
            kind,
            negate,
        });
    }
    onUnicodePropertyCharacterSet(start, end, kind, key, value, negate, strings) {
        const parent = this._node;
        if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
            throw new Error("UnknownError");
        }
        const base = {
            type: "CharacterSet",
            parent: null,
            start,
            end,
            raw: this.source.slice(start, end),
            kind,
            strings: null,
            key,
        };
        if (strings) {
            if ((parent.type === "CharacterClass" && !parent.unicodeSets) ||
                negate ||
                value !== null) {
                throw new Error("UnknownError");
            }
            parent.elements.push(Object.assign(Object.assign({}, base), { parent, strings, value, negate }));
        }
        else {
            parent.elements.push(Object.assign(Object.assign({}, base), { parent, strings, value, negate }));
        }
    }
    onCharacter(start, end, value) {
        const parent = this._node;
        if (parent.type !== "Alternative" &&
            parent.type !== "CharacterClass" &&
            parent.type !== "StringAlternative") {
            throw new Error("UnknownError");
        }
        parent.elements.push({
            type: "Character",
            parent,
            start,
            end,
            raw: this.source.slice(start, end),
            value,
        });
    }
    onBackreference(start, end, ref) {
        const parent = this._node;
        if (parent.type !== "Alternative") {
            throw new Error("UnknownError");
        }
        const node = {
            type: "Backreference",
            parent,
            start,
            end,
            raw: this.source.slice(start, end),
            ref,
            ambiguous: false,
            resolved: DUMMY_CAPTURING_GROUP,
        };
        parent.elements.push(node);
        this._backreferences.push(node);
    }
    onCharacterClassEnter(start, negate, unicodeSets) {
        const parent = this._node;
        const base = {
            type: "CharacterClass",
            parent,
            start,
            end: start,
            raw: "",
            unicodeSets,
            negate,
            elements: [],
        };
        if (parent.type === "Alternative") {
            const node = Object.assign(Object.assign({}, base), { parent });
            this._node = node;
            parent.elements.push(node);
        }
        else if (parent.type === "CharacterClass" &&
            parent.unicodeSets &&
            unicodeSets) {
            const node = Object.assign(Object.assign({}, base), { parent,
                unicodeSets });
            this._node = node;
            parent.elements.push(node);
        }
        else {
            throw new Error("UnknownError");
        }
    }
    onCharacterClassLeave(start, end) {
        const node = this._node;
        if (node.type !== "CharacterClass" ||
            (node.parent.type !== "Alternative" &&
                node.parent.type !== "CharacterClass")) {
            throw new Error("UnknownError");
        }
        const parent = node.parent;
        node.end = end;
        node.raw = this.source.slice(start, end);
        this._node = parent;
        const expression = this._expressionBufferMap.get(node);
        if (!expression) {
            return;
        }
        if (node.elements.length > 0) {
            throw new Error("UnknownError");
        }
        this._expressionBufferMap.delete(node);
        const newNode = {
            type: "ExpressionCharacterClass",
            parent,
            start: node.start,
            end: node.end,
            raw: node.raw,
            negate: node.negate,
            expression,
        };
        expression.parent = newNode;
        if (node !== parent.elements.pop()) {
            throw new Error("UnknownError");
        }
        parent.elements.push(newNode);
    }
    onCharacterClassRange(start, end) {
        const parent = this._node;
        if (parent.type !== "CharacterClass") {
            throw new Error("UnknownError");
        }
        const elements = parent.elements;
        const max = elements.pop();
        if (!max || max.type !== "Character") {
            throw new Error("UnknownError");
        }
        if (!parent.unicodeSets) {
            const hyphen = elements.pop();
            if (!hyphen ||
                hyphen.type !== "Character" ||
                hyphen.value !== HYPHEN_MINUS) {
                throw new Error("UnknownError");
            }
        }
        const min = elements.pop();
        if (!min || min.type !== "Character") {
            throw new Error("UnknownError");
        }
        const node = {
            type: "CharacterClassRange",
            parent,
            start,
            end,
            raw: this.source.slice(start, end),
            min,
            max,
        };
        min.parent = node;
        max.parent = node;
        elements.push(node);
    }
    onClassIntersection(start, end) {
        var _a;
        const parent = this._node;
        if (parent.type !== "CharacterClass" || !parent.unicodeSets) {
            throw new Error("UnknownError");
        }
        const right = parent.elements.pop();
        const left = (_a = this._expressionBufferMap.get(parent)) !== null && _a !== void 0 ? _a : parent.elements.pop();
        if (!left ||
            !right ||
            left.type === "ClassSubtraction" ||
            (left.type !== "ClassIntersection" && !isClassSetOperand(left)) ||
            !isClassSetOperand(right)) {
            throw new Error("UnknownError");
        }
        const node = {
            type: "ClassIntersection",
            parent: parent,
            start,
            end,
            raw: this.source.slice(start, end),
            left,
            right,
        };
        left.parent = node;
        right.parent = node;
        this._expressionBufferMap.set(parent, node);
    }
    onClassSubtraction(start, end) {
        var _a;
        const parent = this._node;
        if (parent.type !== "CharacterClass" || !parent.unicodeSets) {
            throw new Error("UnknownError");
        }
        const right = parent.elements.pop();
        const left = (_a = this._expressionBufferMap.get(parent)) !== null && _a !== void 0 ? _a : parent.elements.pop();
        if (!left ||
            !right ||
            left.type === "ClassIntersection" ||
            (left.type !== "ClassSubtraction" && !isClassSetOperand(left)) ||
            !isClassSetOperand(right)) {
            throw new Error("UnknownError");
        }
        const node = {
            type: "ClassSubtraction",
            parent: parent,
            start,
            end,
            raw: this.source.slice(start, end),
            left,
            right,
        };
        left.parent = node;
        right.parent = node;
        this._expressionBufferMap.set(parent, node);
    }
    onClassStringDisjunctionEnter(start) {
        const parent = this._node;
        if (parent.type !== "CharacterClass" || !parent.unicodeSets) {
            throw new Error("UnknownError");
        }
        this._node = {
            type: "ClassStringDisjunction",
            parent,
            start,
            end: start,
            raw: "",
            alternatives: [],
        };
        parent.elements.push(this._node);
    }
    onClassStringDisjunctionLeave(start, end) {
        const node = this._node;
        if (node.type !== "ClassStringDisjunction" ||
            node.parent.type !== "CharacterClass") {
            throw new Error("UnknownError");
        }
        node.end = end;
        node.raw = this.source.slice(start, end);
        this._node = node.parent;
    }
    onStringAlternativeEnter(start) {
        const parent = this._node;
        if (parent.type !== "ClassStringDisjunction") {
            throw new Error("UnknownError");
        }
        this._node = {
            type: "StringAlternative",
            parent,
            start,
            end: start,
            raw: "",
            elements: [],
        };
        parent.alternatives.push(this._node);
    }
    onStringAlternativeLeave(start, end) {
        const node = this._node;
        if (node.type !== "StringAlternative") {
            throw new Error("UnknownError");
        }
        node.end = end;
        node.raw = this.source.slice(start, end);
        this._node = node.parent;
    }
}
class RegExpParser {
    constructor(options) {
        this._state = new RegExpParserState(options);
        this._validator = new RegExpValidator(this._state);
    }
    parseLiteral(source, start = 0, end = source.length) {
        this._state.source = source;
        this._validator.validateLiteral(source, start, end);
        const pattern = this._state.pattern;
        const flags = this._state.flags;
        const literal = {
            type: "RegExpLiteral",
            parent: null,
            start,
            end,
            raw: source,
            pattern,
            flags,
        };
        pattern.parent = literal;
        flags.parent = literal;
        return literal;
    }
    parseFlags(source, start = 0, end = source.length) {
        this._state.source = source;
        this._validator.validateFlags(source, start, end);
        return this._state.flags;
    }
    parsePattern(source, start = 0, end = source.length, uFlagOrFlags = undefined) {
        this._state.source = source;
        this._validator.validatePattern(source, start, end, uFlagOrFlags);
        return this._state.pattern;
    }
}

class RegExpVisitor {
    constructor(handlers) {
        this._handlers = handlers;
    }
    visit(node) {
        switch (node.type) {
            case "Alternative":
                this.visitAlternative(node);
                break;
            case "Assertion":
                this.visitAssertion(node);
                break;
            case "Backreference":
                this.visitBackreference(node);
                break;
            case "CapturingGroup":
                this.visitCapturingGroup(node);
                break;
            case "Character":
                this.visitCharacter(node);
                break;
            case "CharacterClass":
                this.visitCharacterClass(node);
                break;
            case "CharacterClassRange":
                this.visitCharacterClassRange(node);
                break;
            case "CharacterSet":
                this.visitCharacterSet(node);
                break;
            case "ClassIntersection":
                this.visitClassIntersection(node);
                break;
            case "ClassStringDisjunction":
                this.visitClassStringDisjunction(node);
                break;
            case "ClassSubtraction":
                this.visitClassSubtraction(node);
                b