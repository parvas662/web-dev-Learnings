seOpeningElement(initialTokenIndex);
  if (!isSelfClosing) {
    nextJSXExprToken();
    while (true) {
      switch (_base.state.type) {
        case _types.TokenType.jsxTagStart:
          nextJSXTagToken();
          if (_index.match.call(void 0, _types.TokenType.slash)) {
            nextJSXTagToken();
            jsxParseClosingElement();
            // Key after prop spread takes precedence over number of children,
            // since it means we switch to createElement, which doesn't care
            // about number of children.
            if (_base.state.tokens[initialTokenIndex].jsxRole !== _index.JSXRole.KeyAfterPropSpread) {
              if (numExplicitChildren === 1) {
                _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.OneChild;
              } else if (numExplicitChildren > 1) {
                _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.StaticChildren;
              }
            }
            return;
          }
          numExplicitChildren++;
          jsxParseElementAt();
          nextJSXExprToken();
          break;

        case _types.TokenType.jsxText:
          numExplicitChildren++;
          nextJSXExprToken();
          break;

        case _types.TokenType.jsxEmptyText:
          nextJSXExprToken();
          break;

        case _types.TokenType.braceL:
          _index.next.call(void 0, );
          if (_index.match.call(void 0, _types.TokenType.ellipsis)) {
            jsxParseSpreadChild();
            nextJSXExprToken();
            // Spread children are a mechanism to explicitly mark childre