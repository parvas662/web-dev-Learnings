"use strict";Object.defineProperty(exports, "__esModule", {value: true});var _flow = require('../plugins/flow');
var _typescript = require('../plugins/typescript');







var _index = require('../tokenizer/index');
var _keywords = require('../tokenizer/keywords');
var _types = require('../tokenizer/types');
var _base = require('./base');
var _expression = require('./expression');
var _util = require('./util');

 function parseSpread() {
  _index.next.call(void 0, );
  _expression.parseMaybeAssign.call(void 0, false);
} exports.parseSpread = parseSpread;

 function parseRest(isBlockScope) {
  _index.next.call(void 0, );
  parseBindingAtom(isBlockScope);
} exports.parseRest = parseRest;

 function parseBindingIdentifier(isBlockScope) {
  _expression.parseIdentifier.call(void 0, );
  markPriorBindingIdentifier(isBlockScope);
} exports.parseBindingIdentifier = parseBindingIdentifier;

 function parseImportedIdentifier() {
  _expression.parseIdentifier.call(void 0, );
  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
} exports.parseImportedIdentifier = parseImportedIdentifier;

 function markPriorBindingIdentifier(isBlockScope) {
  let identifierRole;
  if (_base.state.scopeDepth === 0) {
    identifierRole = _index.IdentifierRole.TopLevelDeclaration;
  } else if (isBlockScope) {
    identifierRole = _index.IdentifierRole.BlockScopedDeclaration;
  } else {
    identifierRole = _index.IdentifierRole.FunctionScopedDeclaration;
  }
  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;
} exports.markPriorBindingIdentifier = markPriorBindingIdentifier;

// Parses lvalue (assignable) atom.
 function parseBindingAtom(isBlockScope) {
  switch (_base.state.type) {
    case _types.TokenType._this: {
      // In TypeScript, "this" may be the name of a parameter, so allow it.
      const oldIsType = _index.pushTypeContext.call(void 0, 0);
      _index.next.call(void 0, );
      _index.popTypeContext.call(void 0, oldIsType);
      return;
    }

    case _types.TokenType._yield:
    case _types.TokenType.name: {
      _base.state.type = _types.TokenType.name;
      parseBindingIdentifier(isBlockScope);
      return;
    }

    case _types.TokenType.bracketL: {
      _index.next.call(void 0, );
      parseBindingList(_types.TokenType.bracketR, isBlockScope, true /* allowEmpty */);
      return;
    }

    case _types.TokenTy