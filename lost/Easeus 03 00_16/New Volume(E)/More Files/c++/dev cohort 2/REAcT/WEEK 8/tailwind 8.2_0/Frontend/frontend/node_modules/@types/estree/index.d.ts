ire.resolve('./foo/', { paths: [basedir] }),
            './foo/: resolve.sync === require.resolve'
        );
    }

    t.end();
});

test('#211 - incorrectly resolves module-paths like "." when from inside a folder with a sibling file of the same name', function (t) {
    var dir = path.join(__dirname, 'resolver');
    var basedir = path.join(dir, 'same_names/foo');

    t.equal(
        resolve.sync('./', { basedir: basedir }),
        path.join(dir, 'same_names/foo/index.js'),
        './'
    );
    if (requireResolveSupportsPaths) {
        t.equal(
            resolve.sync('./', { basedir: basedir }),
            require.resolve('./', { paths: [basedir] }),
            './: resolve.sync === require.resolve'
        );
    }

    t.equal(
        resolve.sync('.', { basedir: basedir }),
        path.join(dir, 'same_names/foo/index.js'),
        '.'
    );
    if (requireResolveSupportsPaths) {
        t.equal(
            resolve.sync('.', { basedir: basedir }),
            require.resolve('.', { paths: [basedir] }),
            '.: resolve.sync === require.resolve',
            { todo: true }
        );
    }

    t.end();
});

test('sync: #121 - treating an existing file as a dir when no basedir', function (t) {
    var testFile = path.basename(__filename);

    t.test('sanity check', function (st) {
        st.equal(
            resolve.sync('./' + testFile),
            __filename,
            'sanity check'
        );
        st.equal(
            resolve.sync('./' + testFile),
            require.resolve('./' + testFile),
            'sanity check: resolve.sync === require.resolve'
        );

        st.end();
    });

    t.test('with a fake directory', function (st) {
        function run() { return resolve.sync('./' + testFile + '/blah'); }

        st.throws(run, 'throws an error');

        try {
            run();
        } catch (e) {
            st.equal(e.code, 'MODULE_NOT_FOUND', 'error code matches require.resolve');
            st.equal(
                e.message,
                'Cannot find module \'./' + testFile + '/blah\' from \'' + __dirname + '\'',
                'can not find nonexistent module'
            );
        }

        st.end();
    });

    t.end();
});

test('sync dot main', function (t) {
    var start = new Date();

    t.equal(
        resolve.sync('./resolver/dot_main'),
        path.join(__dirname, 'resolver/dot_main/index.js'),
        './resolver/dot_main'
    );
    t.equal(
        resolve.sync('./resolver/dot_main'),
        require.resolve('./resolver/dot_main'),
        './resolver/dot_main: resolve.sync === require.resolve'
    );

    t.ok(new Date() - start < 50, 'resolve.sync timedout');

    t.end();
});

test('sync dot slash main', function (t) {
    var start = new Date();

    t.equal(
        resolve.sync('./resolver/dot_slash_main'),
        path.join(__dirname, 'resolver/dot_slash_main/index.js')
    );
    t.equal(
        resolve.sync('./resolver/dot_slash_main'),
        require.resolve('./resolver/dot_slash_main'),
        './resolver/dot_slash_main: resolve.sync === require.resolve'
    );

    t.ok(new Date() - start < 50, 'resolve.sync timedout');

    t.end();
});

test('not a directory', function (t) {
    var path = './foo';
    try {
        resolve.sync(path, { basedir: __filename });
        t.fail();
    } catch (err) {
        t.ok(err, 'a non-directory errors');
        t.equal(err && err.message, 'Cannot find module \'' + path + "' from '" + __filename + "'");
        t.equal(err && err.code, 'MODULE_NOT_FOUND');
    }
    t.end();
});

test('non-string "main" field in package.json', function (t) {
    var dir = path.join(__dirname, 'resolver');
    try {
        var result = resolve.sync('./invalid_main', { basedir: dir });
        t.equal(result, undefined, 'result should not exist');
        t.fail('should not get here');
    } catch (err) {
        t.ok(err, 'errors on non-string main');
        t.equal(err.message, 'package “invalid_main” `main` must be a string');
        t.equal(err.code, 'INVALID_PACKAGE_MAIN');
    }
    t.end();
});

test('non-string "main" field in package.json', function (t) {
    var dir = path.join(__dirname, 'resolver');
    try {
        var result = resolve.sync('./invalid_main', { basedir: dir });
        t.equal(result, undefined, 'result should not exist');
        t.fail('should not get here');
    } catch (err) {
        t.ok(err, 'errors on non-string main');
        t.equal(err.message, 'package “invalid_main” `main` must be a string');
        t.equal(err.code, 'INVALID_PACKAGE_MAIN');
    }
    t.end();
});

test('browser field in package.json', function (t) {
    var dir = path.join(__dirname, 'resolver');
    var res = resolve.sync('./browser_field', {
        basedir: dir,
        packageFilter: function packageFilter(pkg) {
            if (pkg.browser) {
                pkg.main = pkg.browser; // eslint-disable-line no-param-reassign
                delete pkg.browser; // eslint-disable-line no-param-reassign
            }
            return pkg;
        }
    });
    t.equal(res, path.join(dir, 'browser_field', 'b.js'));
    t.end();
});

test('absolute paths', function (t) {
    var extensionless = __filename.slice(0, -path.extname(__filename).length);

    t.equal(
        resolve.sync(__filename),
        __filename,
        'absolute path to this file resolves'
    );
    t.equal(
        resolve.sync(__filename),
        require.resolve(__filename),
        'absolute path to this file: resolve.sync === require.resolve'
    );

    t.equal(
        resolve.sync(extensionless),
        __filename,
        'extensionless absolute path to this file resolves'
    );
    t.equal(
        resolve.sync(__filename),
        require.resolve(__filename),
        'absolute path to this file: resolve.sync === require.resolve'
    );

    t.equal(
        resolve.sync(__filename, { basedir: process.cwd() }),
        __filename,
        'absolute path to this file with a basedir resolves'
    );
    if (requireResolveSupportsPaths) {
        t.equal(
            resolve.sync(__filename, { basedir: process.cwd() }),
            require.resolve(__filename, { paths: [process.cwd()] }),
            'absolute path to this file + basedir: resolve.sync === require.resolve'
        );
    }

    t.equal(
        resolve.sync(extensionless, { basedir: process.cwd() }),
        __filename,
        'extensionless absolute path to this file with a basedir resolves'
    );
    if (requireResolveSupportsPaths) {
        t.equal(
            resolve.sync(extensionless, { basedir: process.cwd() }),
            require.resolve(extensionless, { paths: [process.cwd()] }),
            'extensionless absolute path to this file + basedir: resolve.sync === require.resolve'
        );
    }

    t.end();
});

var malformedDir = path.join(__dirname, 'resolver/malformed_package_json');
test('malformed package.json', { skip: !fs.existsSync(malformedDir) }, function (t) {
    t.plan(5 + (requireResolveSupportsPaths ? 1 : 0));

    var basedir = malformedDir;
    var expected = path.join(basedir, 'index.js');

    t.equal(
        resolve.sync('./index.js', { basedir: basedir }),
        expected,
        'malformed package.json is silently ignored'
    );
    if (requireResolveSupportsPaths) {
        t.equal(
            resolve.sync('./index.js', { basedir: basedir }),
            require.resolve('./index.js', { paths: [basedir] }),
            'malformed package.json: resolve.sync === require.resolve'
        );
    }

    var res1 = resolve.sync(
        './index.js',
        {
            basedir: basedir,
            packageFilter: function (pkg, pkgfile, dir) {
                t.fail('should not reach here');
            }
        }
    );

    t.equal(
        res1,
        expected,
        'with packageFilter: malformed package.json is silently ignored'
    );

    var res2 = resolve.sync(
        './index.js',
        {
            basedir: basedir,
            readPackageSync: function (readFileSync, pkgfile) {
                t.equal(pkgfile, path.join(basedir, 'package.json'), 'readPackageSync: `pkgfile` is package.json path');
                var result = String(readFileSync(pkgfile));
                try {
                    return JSON.parse(result);
                } catch (e) {
                    t.ok(e instanceof SyntaxError, 'readPackageSync: malformed package.json parses as a syntax error');
                }
            }
        }
    );

    t.equal(
        res2,
        expected,
        'with readPackageSync: malformed package.json is silently ignored'
    );
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           import { Scalar } from '../nodes/Scalar.js';
import { foldFlowLines, FOLD_QUOTED, FOLD_FLOW, FOLD_BLOCK } from './foldFlowLines.js';

const getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    )
        return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
        qs = doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
            qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
            qs = doubleQuotedString;
        else
            qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
}
// The negative lookbehind avoids a polynomial search,
// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
let blockEndNewlines;
try {
    blockEndNewlines = new RegExp('(^|(?<!\n))\n+(?!\n|$)', 'g');
}
catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if 