rn ESM_RE.test(code);
}

const debug$f = createDebugger("vite:external");
const isExternalCache = /* @__PURE__ */ new WeakMap();
function shouldExternalize(environment, id, importer) {
  let isExternal = isExternalCache.get(environment);
  if (!isExternal) {
    isExternal = createIsExternal(environment);
    isExternalCache.set(environment, isExternal);
  }
  return isExternal(id, importer);
}
const isConfiguredAsExternalCache = /* @__PURE__ */ new WeakMap();
function isConfiguredAsExternal(environment, id, importer) {
  let isExternal = isConfiguredAsExternalCache.get(environment);
  if (!isExternal) {
    isExternal = createIsConfiguredAsExternal(environment);
    isConfiguredAsExternalCache.set(environment, isExternal);
  }
  return isExternal(id, importer);
}
function createIsConfiguredAsExternal(environment) {
  const { config } = environment;
  const { root, resolve } = config;
  const { external, noExternal } = resolve;
  const noExternalFilter = typeof noExternal !== "boolean" && !(Array.isArray(noExternal) && noExternal.length === 0) && createFilter(void 0, noExternal, { resolve: false });
  const targetConditions = resolve.externalConditions || [];
  const resolveOptions = {
    ...resolve,
    root,
    isProduction: false,
    isBuild: true,
    conditions: targetConditions
  };
  const isExternalizable = (id, importer, configuredAsExternal) => {
    if (!bareImportRE.test(id) || id.includes("\0")) {
      return false;
    }
    try {
      const resolved = tryNodeResolve(
        id,
        // Skip passing importer in build to avoid externalizing non-hoisted dependencies
        // unresolvable from root (which would be unresolvable from output bundles also)
        config.command === "build" ? void 0 : importer,
        resolveOptions,
        void 0,
        false
      );
      if (!resolved) {
        return false;
      }
      if (!configuredAsExternal && !isInNodeModules$1(resolved.id)) {
        return false;
      }
      return canExternalizeFile(resolved.id);
    } catch {
      debug$f?.(
        `Failed to node resolve "${id}". Skipping externalizing it by default.`
      );
      return false;
    }
  };
  return (id, importer) => {
    if (
      // If this id is defined as external, force it as external
      // Note that individual package entries are allowed in `external`
      external !== true && external.includes(id)
    ) {
      return true;
    }
    const pkgName = getNpmPackageName(id);
    if (!pkgName) {
      return isExternalizable(id, importer, false);
    }
    if (
      // A package name in ssr.external externalizes every
      // externalizable package entry
      external !== true && external.includes(pkgName)
    ) {
      return isExternalizable(id, importer, true);
    }
    if (typeof noExternal === "boolean") {
      return !noExternal;
    }
    if (noExternalFilter && !noExternalFilter(pkgName)) {
      return false;
    }
    return isExternalizable(id, importer, external === true);
  };
}
function createIsExternal(environment) {
  const processedIds = /* @__PURE__ */ new Map();
  const isConfiguredAsExternal2 = createIsConfiguredAsExternal(environment);
  return (id, importer) => {
    if (processedIds.has(id)) {
      return processedIds.get(id);
    }
    let isExternal = false;
    if (id[0] !== "." && !path$d.isAbsolute(id)) {
      isExternal = isBuiltin(id) || isConfiguredAsExternal2(id, importer);
    }
    processedIds.set(id, isExternal);
    return isExternal;
  };
}
function canExternalizeFile(filePath) {
  const ext = path$d.extname(filePath);
  return !ext || ext === ".js" || ext === ".mjs" || ext === ".cjs";
}

const normalizedClientEntry$1 = normalizePath$3(CLIENT_ENTRY);
const normalizedEnvEntry$1 = normalizePath$3(ENV_ENTRY);
const ERR_RESOLVE_PACKAGE_ENTRY_FAIL = "ERR_RESOLVE_PACKAGE_ENTRY_FAIL";
const browserExternalId = "__vite-browser-external";
const optionalPeerDepId = "__vite-optional-peer-dep";
const subpathImportsPrefix = "#";
const startsWithWordCharRE = /^\w/;
const debug$e = createDebugger("vite:resolve-details", {
  onlyWhenFocused: true
});
function resolvePlugin(resolveOptions) {
  const { root, isProduction, asSrc, preferRelative = false } = resolveOptions;
  const rootInRoot = tryStatSync(path$d.join(root, root))?.isDirectory() ?? false;
  return {
    name: "vite:resolve",
    async resolveId(id, importer, resolveOpts) {
      if (id[0] === "\0" || id.startsWith("virtual:") || // When injected directly in html/client code
      id.startsWith("/virtual:")) {
        return;
      }
      const depsOptimizer = resolveOptions.optimizeDeps && this.environment.mode === "dev" ? this.environment.depsOptimizer : void 0;
      if (id.startsWith(browserExternalId)) {
        return id;
      }
      const isRequire = resolveOpts?.custom?.["node-resolve"]?.isRequire ?? false;
      const currentEnvironmentOptions = this.environment.config;
      const options = {
        isRequire,
        ...currentEnvironmentOptions.resolve,
        ...resolveOptions,
        // plugin options + resolve options overrides
        scan: resolveOpts?.scan ?? resolveOptions.scan
      };
      const resolvedImports = resolveSubpathImports(id, importer, options);
      if (resolvedImports) {
        id = resolvedImports;
        if (resolveOpts.custom?.["vite:import-glob"]?.isSubImportsPattern) {
          return normalizePath$3(path$d.join(root, id));
        }
      }
      if (importer) {
        if (isTsRequest(importer) || resolveOpts.custom?.depScan?.loader?.startsWith("ts")) {
          options.isFromTsImporter = true;
        } else {
          const moduleLang = this.getModuleInfo(importer)?.meta?.vite?.lang;
          options.isFromTsImporter = moduleLang && isTsRequest(`.${moduleLang}`);
        }
      }
      let res;
      if (asSrc && depsOptimizer?.isOptimizedDepUrl(id)) {
        const optimizedPath = id.startsWith(FS_PREFIX) ? fsPathFromId(id) : normalizePath$3(path$d.resolve(root, id.slice(1)));
        return optimizedPath;
      }
      if (asSrc && id.startsWith(FS_PREFIX)) {
        res = fsPathFromId(id);
        debug$e?.(`[@fs] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
        return ensureVersionQuery(res, id, options, depsOptimizer);
      }
      if (asSrc && id[0] === "/" && (rootInRoot || !id.startsWith(withTrailingSlash(root)))) {
        const fsPath = path$d.resolve(root, id.slice(1));
        if (res = tryFsResolve(fsPath, options)) {
          debug$e?.(`[url] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
          return ensureVersionQuery(res, id, options, depsOptimizer);
        }
      }
      if (id[0] === "." || (preferRelative || importer?.endsWith(".html")) && startsWithWordCharRE.test(id)) {
        const basedir = importer ? path$d.dirname(importer) : process.cwd();
        const fsPath = path$d.resolve(basedir, id);
        const normalizedFsPath = normalizePath$3(fsPath);
        if (depsOptimizer?.isOptimizedDepFile(normalizedFsPath)) {
          if (!options.isBuild && !DEP_VERSION_RE.test(normalizedFsPath)) {
            const browserHash = optimizedDepInfoFromFile(
              depsOptimizer.metadata,
              normalizedFsPath
            )?.browserHash;
            if (browserHash) {
              return injectQuery(normalizedFsPath, `v=${browserHash}`);
            }
          }
          return normalizedFsPath;
        }
        if (options.mainFields.includes("browser") && (res = tryResolveBrowserMapping(fsPath, importer, options, true))) {
          return res;
        }
        if (res = tryFsResolve(fsPath, options)) {
          res = ensureVersionQuery(res, id, options, depsOptimizer);
          debug$e?.(`[relative] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
          if (!options.idOnly && !options.scan && options.isBuild) {
            const resPkg = findNearestPackageData(
              path$d.dirname(res),
              options.packageCache
            );
            if (resPkg) {
              return {
                id: res,
                moduleSideEffects: resPkg.hasSideEffects(res)
              };
            }
          }
          return res;
        }
      }
      if (id.startsWith("file://")) {
        id = fileURLToPath$1(id);
      }
      if (isWindows$3 && id[0] === "/") {
        const basedir = importer ? path$d.dirname(importer) : process.cwd();
        const fsPath = path$d.resolve(basedir, id);
        if (res = tryFsResolve(fsPath, options)) {
          debug$e?.(`[drive-relative] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
          return ensureVersionQuery(res, id, options, depsOptimizer);
        }
      }
      if (isNonDriveRelativeAbsolutePath(id) && (res = tryFsResolve(id, options))) {
        debug$e?.(`[fs] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
        return ensureVersionQuery(res, id, options, depsOptimizer);
      }
      if (isExternalUrl(id)) {
        return options.idOnly ? id : { id, external: true };
      }
      if (isDataUrl(id)) {
        return null;
      }
      if (bareImportRE.test(id)) {
        const external = options.externalize && options.isBuild && currentEnvironmentOptions.consumer === "server" && shouldExternalize(this.environment, id, importer);
        if (!external && asSrc && depsOptimizer && !options.scan && (res = await tryOptimizedResolve(
          depsOptimizer,
          id,
          importer,
          options.preserveSymlinks,
          options.packageCache
        ))) {
          return res;
        }
        if (options.mainFields.includes("browser") && (res = tryResolveBrowserMapping(
          id,
          importer,
          options,
          false,
          external
        ))) {
          return res;
        }
        if (res = tryNodeResolve(id, importer, options, depsOptimizer, external)) {
          return res;
        }
        if (isBuiltin(id)) {
          if (currentEnvironmentOptions.consumer === "server") {
            if (options.noExternal === true && // if both noExternal and external are true, noExternal will take the higher priority and bundle it.
            // only if the id is explicitly listed in external, we will externalize it and skip this error.
            (options.external === true || !options.external.includes(id))) {
              let message = `Cannot bundle Node.js built-in "${id}"`;
              if (importer) {
                message += ` imported from "${path$d.relative(
                  process.cwd(),
                  importer
                )}"`;
              }
              message += `. Consider disabling environments.${this.environment.name}.noExternal or remove the built-in dependency.`;
              this.error(message);
            }
            return options.idOnly ? id : { id, external: true, moduleSideEffects: false };
          } else {
            if (!asSrc) {
              debug$e?.(
                `externalized node built-in "${id}" to empty module. (imported by: ${colors$1.white(colors$1.dim(importer))})`
              );
            } else if (isProduction) {
              this.warn(
                `Module "${id}" has been externalized for browser compatibility, imported by "${importer}". See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`
              );
            }
            return isProduction ? browserExternalId : `${browserExternalId}:${id}`;
          }
        }
      }
      debug$e?.(`[fallthrough] ${colors$1.dim(id)}`);
    },
    load(id) {
      if (id.startsWith(browserExternalId)) {
        if (isProduction) {
          return `export default {}`;
        } else {
          id = id.slice(browserExternalId.length + 1);
          return `export default new Proxy({}, {
  get(_, key) {
    throw new Error(\`Module "${id}" has been externalized for browser compatibility. Cannot access "${id}.\${key}" in client code.  See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.\`)
  }
})`;
        }
      }
      if (id.startsWith(optionalPeerDepId)) {
        if (isProduction) {
          return `export default {}`;
        } else {
          const [, peerDep, parentDep] = id.split(":");
          return `throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}". Is it installed?\`)`;
        }
      }
    }
  };
}
function resolveSubpathImports(id, importer, options) {
  if (!importer || !id.startsWith(subpathImportsPrefix)) return;
  const basedir = path$d.dirname(importer);
  const pkgData = findNearestPackageData(basedir, options.packageCache);
  if (!pkgData) return;
  let { file: idWithoutPostfix, postfix } = splitFileAndPostfix(id.slice(1));
  idWithoutPostfix = "#" + idWithoutPostfix;
  let importsPath = resolveExportsOrImports(
    pkgData.data,
    idWithoutPostfix,
    options,
    "imports"
  );
  if (importsPath?.[0] === ".") {
    importsPath = path$d.relative(basedir, path$d.join(pkgData.dir, importsPath));
    if (importsPath[0] !== ".") {
      importsPath = `./${importsPath}`;
    }
  }
  return importsPath + postfix;
}
function ensureVersionQuery(resolved, id, options, depsOptimizer) {
  if (!options.isBuild && !options.scan && depsOptimizer && !(resolved === normalizedClientEntry$1 || resolved === normalizedEnvEntry$1)) {
    const isNodeModule = isInNodeModules$1(id) || isInNodeModules$1(resolved);
    if (isNodeModule && !DEP_VERSION_RE.test(resolved)) {
      const versionHash = depsOptimizer.metadata.browserHash;
      if (versionHash && isOptimizable(resolved, depsOptimizer.options)) {
        resolved = injectQuery(resolved, `v=${versionHash}`);
      }
    }
  }
  return resolved;
}
function tryFsResolve(fsPath, options, tryIndex = true, skipPackageJson = false) {
  const hashIndex = fsPath.indexOf("#");
  if (hashIndex >= 0 && isInNodeModules$1(fsPath)) {
    const queryIndex = fsPath.indexOf("?");
    if (queryIndex < 0 || queryIndex > hashIndex) {
      const file2 = queryIndex > hashIndex ? fsPath.slice(0, queryIndex) : fsPath;
      const res2 = tryCleanFsResolve(file2, options, tryIndex, skipPackageJson);
      if (res2) return res2 + fsPath.slice(file2.length);
    }
  }
  const { file, postfix } = splitFileAndPostfix(fsPath);
  const res = tryCleanFsResolve(file, options, tryIndex, skipPackageJson);
  if (res) return res + postfix;
}
const knownTsOutputRE = /\.(?:js|mjs|cjs|jsx)$/;
const isPossibleTsOutput = (url) => knownTsOutputRE.test(url);
function tryCleanFsResolve(file, options, tryIndex = true, skipPackageJson = false) {
  const { tryPrefix, extensions, preserveSymlinks } = options;
  const fileResult = tryResolveRealFileOrType(file, options.preserveSymlinks);
  if (fileResult?.path) return fileResult.path;
  let res;
  const possibleJsToTs = options.isFromTsImporter && isPossibleTsOutput(file);
  if (possibleJsToTs || options.extensions.length || tryPrefix) {
    const dirPath = path$d.dirname(file);
    if (isDirectory(dirPath)) {
      if (possibleJsToTs) {
        const fileExt = path$d.extname(file);
        const fileName = file.slice(0, -fileExt.length);
        if (res = tryResolveRealFile(
          fileName + fileExt.replace("js", "ts"),
          preserveSymlinks
        ))
          return res;
        if (fileExt === ".js" && (res = tryResolveRealFile(fileName + ".tsx", preserveSymlinks)))
          return res;
      }
      if (res = tryResolveRealFileWithExtensions(
        file,
        extensions,
        preserveSymlinks
      ))
        return res;
      if (tryPrefix) {
        const prefixed = `${dirPath}/${options.tryPrefix}${path$d.basename(file)}`;
        if (res = tryResolveRealFile(prefixed, preserveSymlinks)) return res;
        if (res = tryResolveRealFileWithExtensions(
          prefixed,
          extensions,
          preserveSymlinks
        ))
          return res;
      }
    }
  }
  if (tryIndex && fileResult?.type === "directory") {
    const dirPath = file;
    if (!skipPackageJson) {
      let pkgPath = `${dirPath}/package.json`;
      try {
        if (fs__default.existsSync(pkgPath)) {
          if (!options.preserveSymlinks) {
            pkgPath = safeRealpathSync(pkgPath);
          }
          const pkg = loadPackageData(pkgPath);
          return resolvePackageEntry(dirPath, pkg, options);
        }
      } catch (e) {
        if (e.code !== ERR_RESOLVE_PACKAGE_ENTRY_FAIL && e.code !== "ENOENT")
          throw e;
      }
    }
    if (res = tryResolveRealFileWithExtensions(
      `${dirPath}/index`,
      extensions,
      preserveSymlinks
    ))
      return res;
    if (tryPrefix) {
      if (res = tryResolveRealFileWithExtensions(
        `${dirPath}/${options.tryPrefix}index`,
        extensions,
        preserveSymlinks
      ))
        return res;
    }
  }
}
function tryNodeResolve(id, importer, options, depsOptimizer, externalize) {
  const { root, dedupe, isBuild, preserveSymlinks, packageCache } = options;
  const deepMatch = deepImportRE.exec(id);
  const pkgId = deepMatch ? deepMatch[1] || deepMatch[2] : cleanUrl(id);
  let basedir;
  if (dedupe?.includes(pkgId)) {
    basedir = root;
  } else if (importer && path$d.isAbsolute(importer) && // css processing appends `*` for importer
  (importer[importer.length - 1] === "*" || fs__default.existsSync(cleanUrl(importer)))) {
    basedir = path$d.dirname(importer);
  } else {
    basedir = root;
  }
  let selfPkg = null;
  if (!isBuiltin(id) && !id.includes("\0") && bareImportRE.test(id)) {
    const selfPackageData = findNearestPackageData(basedir, packageCache);
    selfPkg = selfPackageData?.data.exports && selfPackageData?.data.name === pkgId ? selfPackageData : null;
  }
  const pkg = selfPkg || resolvePackageData(pkgId, basedir, preserveSymlinks, packageCache);
  if (!pkg) {
    if (basedir !== root && // root has no peer dep
    !isBuiltin(id) && !id.includes("\0") && bareImportRE.tes