=== deps.size
            ? null
            : (1 < deps.size ? "" : singlePrefix + " ") +
                label +
                " " +
                (1 < deps.size ? "dependencies" : "dependency") +
                ": " +
                joinEnglish(
                  Array.from(deps)
                    .sort()
                    .map(function (name) {
                      return "'" + formatDependency(name) + "'";
                    })
                ) +
                (". Either " +
                  fixVerb +
                  " " +
                  (1 < deps.size ? "them" : "it") +
                  " or remove the dependency array.");
        }
        isEffect &&
          node.async &&
          reportProblem({
            node: node,
            message:
              "Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching"
          });
        for (
          var scope = scopeManager.acquire(node),
            pureScopes = new Set(),
            componentScope = null,
            currentScope = scope.upper;
          currentScope;

        ) {
          pureScopes.add(currentScope);
          if ("function" === currentScope.type) break;
          currentScope = currentScope.upper;
        }
        if (currentScope) {
          componentScope = currentScope;
          var isArray = Array.isArray,
            memoizedIsStableKnownHookValue = memoizeWithWeakMap(function (
              resolved
            ) {
              if (!isArray(resolved.defs)) return !1;
              var def = resolved.defs[0];
              if (null == def || "VariableDeclarator" !== def.node.type)
                return !1;
              var init = def.node.init;
              if (null == init) return !1;
              for (
                ;
                "TSAsExpression" === init.type || "AsExpression" === init.type;

              )
                init = init.expression;
              var declaration = def.node.parent;
              if (
                null == declaration &&
                (fastFindReferenceWithParent(componentScope.block, def.node.id),
                (declaration = def.node.parent),
                null == declaration)
              )
                return !1;
              if (
                "const" === declaration.kind &&
                "Literal" === init.type &&
                ("string" === typeof init.value ||
                  "number" === typeof init.value ||
                  null === init.value)
              )
                return !0;
              if ("CallExpression" !== init.type) return !1;
              init = init.callee;
              "MemberExpression" !== init.type ||
                "React" !== init.object.name ||
                null == init.property ||
                init.computed ||
                (init = init.property);
              if ("Identifier" !== init.type) return !1;
              def = def.node.id;
              init = init.name;
              if ("useRef" === init && "Identifier" === def.type) return !0;
              if ("useState" === init || "useReducer" === init) {
                if (
                  "ArrayPattern" === def.type &&
                  2 === def.elements.length &&
                  isArray(resolved.identifiers)
                ) {
                  if (def.elements[1] === resolved.identifiers[0]) {
                    if ("useState" === init)
                      for (
                        resolved = resolved.references, declaration = init = 0;
                        declaration < resolved.length;
                        declaration++
                      ) {
                        resolved[declaration].isWrite() && init++;
                        if (1 < init) return !1;
                        setStateCallSites.set(
                          resolved[declaration].identifier,
                          def.elements[0]
                        );
                      }
                    return !0;
                  }
                  if (
                    def.elements[0] === resolved.identifiers[0] &&
                    "useState" === init
                  )
                    for (
                      resolved = resolved.references, def = 0;
                      def < resolved.length;
                      def++
                    )
                      stateVariables.add(resolved[def].identifier);
                }
              } else if (
                "useTransition" === init &&
                "ArrayPattern" === def.type &&
                2 === def.elements.length &&
                Array.isArray(resolved.identifiers) &&
                def.elements[1] === resolved.identifiers[0]
              )
                return !0;
              return !1;
            }, stableKnownValueCache),
            memoizedIsFunctionWithoutCapturedValues = memoizeWithWeakMap(
              function (resolved) {
                if (!isArray(resolved.defs)) return !1;
                resolved = resolved.defs[0];
                if (
                  null == resolved ||
                  null == resolved.node ||
                  null == resolved.node.id
                )
                  return !1;
                var fnNode = resolved.node,
                  childScopes = componentScope.childScopes;
                resolved = null;
                var i;
                for (i = 0; i < childScopes.length; i++) {
                  var childScope = childScopes[i],
                    childScopeBlock = childScope.block;
                  if (
                    ("FunctionDeclaration" === fnNode.type &&
                      childScopeBlock === fnNode) ||
                    ("VariableDeclarator" === fnNode.type &&
                      childScopeBlock.parent === fnNode)
                  ) {
                    resolved = childScope;
                    break;
                  }
                }
                if (null == resolved) return !1;
                for (i = 0; i < resolved.through.length; i++)
                  if (
                    ((fnNode = resolved.through[i]),
                    null != fnNode.resolved &&
                      pureScopes.has(fnNode.resolved.scope) &&
                      !memoizedIsStableKnownHookValue(fnNode.resolved))
                  )
                    return !1;
                return !0;
              },
              functionWithoutCapturedValueCache
            ),
            currentRefsInEffectCleanup = new Map(),
            dependencies = new Map(),
            optionalChains = new Map();
          gatherDependenciesRecursively(scope);
          currentRefsInEffectCleanup.forEach(function (_ref, dependency) {
            var dependencyNode = _ref.dependencyNode;
            _ref = _ref.reference.resolved.references;
            for (var foundCurrentAssignment = !1, i = 0; i < _ref.length; i++) {
              var parent = _ref[i].identifier.parent;
              if (
                null != parent &&
                "MemberExpression" === parent.type &&
                !parent.computed &&
                "Identifier" === parent.property.type &&
                "current" === parent.property.name &&
                "AssignmentExpression" === parent.parent.type &&
                parent.parent.left === parent
              ) {
                foundCurrentAssignment = !0;
                break;
              }
            }
            foundCurrentAssignment ||
              reportProblem({
                node: dependencyNode.parent.property,
                message:
                  "The ref value '" +
                  dependency +
                  ".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '" +
                  (dependency +
                    ".current' to a variable inside the effect, and use that variable in the cleanup function.")
              });
          });
          var staleAssignments = new Set(),
            stableDependencies = new Set();
          dependencies.forEach(function (_ref2, key) {
            var references = _ref2.references;
            _ref2.isStable && stableDependencies.add(key);
            references.forEach(function (reference) {
              reference.writeExpr &&
                ((reference = reference.writeExpr),
                staleAssignments.has(key) ||
                  (staleAssignments.add(key),
                  reportProblem({
                    node: reference,
                    message:
                      "Assignments to the '" +
                      key +
                      "' variable from inside React Hook " +
                      (getSource(reactiveHook) +
                        " will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside ") +
                      (getSource(reactiveHook) + ".")
                  })));
            });
          });
          if (!(0 < staleAssignments.size))
            if (declaredDependenciesNode) {
              var declaredDependencies = [],
                externalDependencies = new Set();
              currentScope =
                "TSAsExpression" === declaredDependenciesNode.type &&
                "ArrayExpression" === declaredDependenciesNode.expression.type;
              "ArrayExpression" === declaredDependenciesNode.type ||
              currentScope
                ? (currentScope
                    ? declaredDependenciesNode.expression
                    : declaredDependenciesNode
                  ).elements.forEach(function (declaredDependencyNode) {
                    if (null !== declaredDependencyNode)
                      if ("S