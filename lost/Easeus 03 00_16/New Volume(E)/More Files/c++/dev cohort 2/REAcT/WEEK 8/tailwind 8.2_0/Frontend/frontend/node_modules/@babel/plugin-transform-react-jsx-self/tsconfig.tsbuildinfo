62.ecma-international.org/9.0/#sec-getreferencedname'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/9.0/#sec-getsubstitution'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/9.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/9.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/9.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-getthisvalue'
	},
	GetV: {
		url: 'https://262.ecma-international.org/9.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-getvaluefrombuffer'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-getviewvalue'
	},
	GetWaiterList: {
		url: 'https://262.ecma-international.org/9.0/#sec-getwaiterlist'
	},
	GlobalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/9.0/#sec-globaldeclarationinstantiation'
	},
	'happens-before': {
		url: 'https://262.ecma-international.org/9.0/#sec-happens-before'
	},
	HasOwnProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-hasownproperty'
	},
	HasPrimitiveBase: {
		url: 'https://262.ecma-international.org/9.0/#sec-hasprimitivebase'
	},
	HasProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-hasproperty'
	},
	'host-synchronizes-with': {
		url: 'https://262.ecma-international.org/9.0/#sec-host-synchronizes-with'
	},
	HostEventSet: {
		url: 'https://262.ecma-international.org/9.0/#sec-hosteventset'
	},
	HourFromTime: {
		url: 'https://262.ecma-international.org/9.0/#eqn-HourFromTime'
	},
	IfAbruptRejectPromise: {
		url: 'https://262.ecma-international.org/9.0/#sec-ifabruptrejectpromise'
	},
	ImportedLocalNames: {
		url: 'https://262.ecma-international.org/9.0/#sec-importedlocalnames'
	},
	InitializeBoundName: {
		url: 'https://262.ecma-international.org/9.0/#sec-initializeboundname'
	},
	InitializeHostDefinedRealm: {
		url: 'https://262.ecma-international.org/9.0/#sec-initializehostdefinedrealm'
	},
	InitializeReferencedBinding: {
		url: 'https://262.ecma-international.org/9.0/#sec-initializereferencedbinding'
	},
	InLeapYear: {
		url: 'https://262.ecma-international.org/9.0/#eqn-InLeapYear'
	},
	InnerModuleEvaluation: {
		url: 'https://262.ecma-international.org/9.0/#sec-innermoduleevaluation'
	},
	InnerModuleInstantiation: {
		url: 'https://262.ecma-international.org/9.0/#sec-innermoduleinstantiation'
	},
	InstanceofOperator: {
		url: 'https://262.ecma-international.org/9.0/#sec-instanceofoperator'
	},
	IntegerIndexedElementGet: {
		url: 'https://262.ecma-international.org/9.0/#sec-integerindexedelementget'
	},
	IntegerIndexedElementSet: {
		url: 'https://262.ecma-international.org/9.0/#sec-integerindexedelementset'
	},
	IntegerIndexedObjectCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-integerindexedobjectcreate'
	},
	InternalizeJSONProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-internalizejsonproperty'
	},
	Invoke: {
		url: 'https://262.ecma-international.org/9.0/#sec-invoke'
	},
	IsAccessorDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-isaccessordescriptor'
	},
	IsAnonymousFunctionDefinition: {
		url: 'https://262.ecma-international.org/9.0/#sec-isanonymousfunctiondefinition'
	},
	IsArray: {
		url: 'https://262.ecma-international.org/9.0/#sec-isarray'
	},
	IsCallable: {
		url: 'https://262.ecma-international.org/9.0/#sec-iscallable'
	},
	IsCompatiblePropertyDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-iscompatiblepropertydescriptor'
	},
	IsConcatSpreadable: {
		url: 'https://262.ecma-international.org/9.0/#sec-isconcatspreadable'
	},
	IsConstructor: {
		url: 'https://262.ecma-international.org/9.0/#sec-isconstructor'
	},
	IsDataDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-isdatadescriptor'
	},
	IsDetachedBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-isdetachedbuffer'
	},
	IsExtensible: {
		url: 'https://262.ecma-international.org/9.0/#sec-isextensible-o'
	},
	IsGenericDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-isgenericdescriptor'
	},
	IsInTailPosition: {
		url: 'https://262.ecma-international.org/9.0/#sec-isintailposition'
	},
	IsInteger: {
		url: 'https://262.ecma-international.org/9.0/#sec-isinteger'
	},
	IsLabelledFunction: {
		url: 'https://262.ecma-international.org/9.0/#sec-islabelledfunction'
	},
	IsPromise: {
		url: 'https://262.ecma-international.org/9.0/#sec-ispromise'
	},
	IsPropertyKey: {
		url: 'https://262.ecma-international.org/9.0/#sec-ispropertykey'
	},
	IsPropertyReference: {
		url: 'https://262.ecma-international.org/9.0/#sec-ispropertyreference'
	},
	IsRegExp: {
		url: 'https://262.ecma-international.org/9.0/#sec-isregexp'
	},
	IsSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-issharedarraybuffer'
	},
	IsStrictReference: {
		url: 'https://262.ecma-international.org/9.0/#sec-isstrictreference'
	},
	IsStringPrefix: {
		url: 'https://262.ecma-international.org/9.0/#sec-isstringprefix'
	},
	IsSuperReference: {
		url: 'https://262.ecma-international.org/9.0/#sec-issuperreference'
	},
	IsUnresolvableReference: {
		url: 'https://262.ecma-international.org/9.0/#sec-isunresolvablereference'
	},
	IsWordChar: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-iswordchar-abstract-operation'
	},
	IterableToList: {
		url: 'https://262.ecma-international.org/9.0/#sec-iterabletolist'
	},
	IteratorClose: {
		url: 'https://262.ecma-international.org/9.0/#sec-iteratorclose'
	},
	IteratorComplete: {
		url: 'https://262.ecma-international.org/9.0/#sec-iteratorcomplete'
	},
	IteratorNext: {
		url: 'https://262.ecma-international.org/9.0/#sec-iteratornext'
	},
	IteratorStep: {
		url: 'https://262.ecma-international.org/9.0/#sec-iteratorstep'
	},
	IteratorValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-iteratorvalue'
	},
	LeaveCriticalSection: {
		url: 'https://262.ecma-international.org/9.0/#sec-leavecriticalsection'
	},
	LocalTime: {
		url: 'https://262.ecma-international.org/9.0/#sec-localtime'
	},
	LoopContinues: {
		url: 'https://262.ecma-international.org/9.0/#sec-loopcontinues'
	},
	MakeArgGetter: {
		url: 'https://262.ecma-international.org/9.0/#sec-makearggetter'
	},
	MakeArgSetter: {
		url: 'https://262.ecma-international.org/9.0/#sec-makeargsetter'
	},
	MakeClassConstructor: {
		url: 'https://262.ecma-international.org/9.0/#sec-makeclassconstructor'
	},
	MakeConstructor: {
		url: 'https://262.ecma-international.org/9.0/#sec-makeconstructor'
	},
	MakeDate: {
		url: 'https://262.ecma-international.org/9.0/#sec-makedate'
	},
	MakeDay: {
		url: 'https://262.ecma-international.org/9.0/#sec-makeday'
	},
	MakeMethod: {
		url: 'https://262.ecma-international.org/9.0/#sec-makemethod'
	},
	MakeSuperPropertyReference: {
		url: 'https://262.ecma-international.org/9.0/#sec-makesuperpropertyreference'
	},
	MakeTime: {
		url: 'https://262.ecma-international.org/9.0/#sec-maketime'
	},
	max: {
		url: 'https://262.ecma-international.org/9.0/#eqn-max'
	},
	'memory-order': {
		url: 'https://262.ecma-international.org/9.0/#sec-memory-order'
	},
	min: {
		url: 'https://262.ecma-international.org/9.0/#eqn-min'
	},
	MinFromTime: {
		url: 'https://262.ecma-international.org/9.0/#eqn-MinFromTime'
	},
	ModuleDeclarationEnvironmentSetup: {
		url: 'https://262.ecma-international.org/9.0/#sec-moduledeclarationenvironmentsetup'
	},
	ModuleExecution: {
		url: 'https://262.ecma-international.org/9.0/#sec-moduleexecution'
	},
	ModuleNamespaceCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-modulenamespacecreate'
	},
	modulo: {
		url: 'https://262.ecma-international.org/9.0/#eqn-modulo'
	},
	MonthFromTime: {
		url: 'https://262.ecma-international.org/9.0/#eqn-MonthFromTime'
	},
	msFromTime: {
		url: 'https://262.ecma-international.org/9.0/#eqn-msFromTime'
	},
	NewDeclarativeEnvironment: {
		url: 'https://262.ecma-international.org/9.0/#sec-newdeclarativeenvironment'
	},
	NewFunctionEnvironment: {
		url: 'https://262.ecma-international.org/9.0/#sec-newfunctionenvironment'
	},
	NewGlobalEnvironment: {
		url: 'https://262.ecma-international.org/9.0/#sec-newglobalenvironment'
	},
	NewModuleEnvironment: {
		url: 'https://262.ecma-international.org/9.0/#sec-newmoduleenvironment'
	},
	NewObjectEnvironment: {
		url: 'https://262.ecma-international.org/9.0/#sec-newobjectenvironment'
	},
	NewPromiseCapability: {
		url: 'https://262.ecma-international.org/9.0/#sec-newpromisecapability'
	},
	NormalCompletion: {
		url: 'https://262.ecma-international.org/9.0/#sec-normalcompletion'
	},
	NumberToRawBytes: {
		url: 'https://262.ecma-international.org/9.0/#sec-numbertorawbytes'
	},
	NumberToString: {
		url: 'https://262.ecma-international.org/9.0/#sec-tostring-applied-to-the-number-type'
	},
	ObjectCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-objectcreate'
	},
	ObjectDefineProperties: {
		url: 'https://262.ecma-international.org/9.0/#sec-objectdefineproperties'
	},
	OrdinaryCallBindThis: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarycallbindthis'
	},
	OrdinaryCallEvaluateBody: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarycallevaluatebody'
	},
	OrdinaryCreateFromConstructor: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarycreatefromconstructor'
	},
	OrdinaryDefineOwnProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarydefineownproperty'
	},
	OrdinaryDelete: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarydelete'
	},
	OrdinaryGet: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinaryget'
	},
	OrdinaryGetOwnProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarygetownproperty'
	},
	OrdinaryGetPrototypeOf: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarygetprototypeof'
	},
	OrdinaryHasInstance: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinaryhasinstance'
	},
	OrdinaryHasProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinaryhasproperty'
	},
	OrdinaryIsExtensible: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinaryisextensible'
	},
	OrdinaryOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinaryownpropertykeys'
	},
	OrdinaryPreventExtensions: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarypreventextensions'
	},
	OrdinarySet: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinaryset'
	},
	OrdinarySetPrototypeOf: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarysetprototypeof'
	},
	OrdinarySetWithOwnDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarysetwithowndescriptor'
	},
	OrdinaryToPrimitive: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarytoprimitive'
	},
	ParseModule: {
		url: 'https://262.ecma-international.org/9.0/#sec-parsemodule'
	},
	ParseScript: {
		url: 'https://262.ecma-international.org/9.0/#sec-parse-script'
	},
	PerformEval: {
		url: 'https://262.ecma-international.org/9.0/#sec-performeval'
	},
	PerformPromiseAll: {
		url: 'https://262.ecma-international.org/9.0/#sec-performpromiseall'
	},
	PerformPromiseRace: {
		url: 'https://262.ecma-international.org/9.0/#sec-performpromiserace'
	},
	PerformPromiseThen: {
		url: 'https://262.ecma-international.org/9.0/#sec-performpromisethen'
	},
	PrepareForOrdinaryCall: {
		url: 'https://262.ecma-international.org/9.0/#sec-prepareforordinarycall'
	},
	PrepareForTailCall: {
		url: 'https://262.ecma-international.org/9.0/#sec-preparefortailcall'
	},
	PromiseReactionJob: {
		url: 'https://262.ecma-international.org/9.0/#sec-promisereactionjob'
	},
	PromiseResolve: {
		url: 'https://262.ecma-international.org/9.0/#sec-promise-resolve'
	},
	PromiseResolveThenableJob: {
		url: 'https://262.ecma-international.org/9.0/#sec-promiseresolvethenablejob'
	},
	ProxyCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-proxycreate'
	},
	PutValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-putvalue'
	},
	QuoteJSONString: {
		url: 'https://262.ecma-international.org/9.0/#sec-quotejsonstring'
	},
	RawBytesToNumber: {
		url: 'https://262.ecma-international.org/9.0/#sec-rawbytestonumber'
	},
	'reads-bytes-from': {
		url: 'https://262.ecma-international.org/9.0/#sec-reads-bytes-from'
	},
	'reads-from': {
		url: 'https://262.ecma-international.org/9.0/#sec-reads-from'
	},
	RegExpAlloc: {
		url: 'https://262.ecma-international.org/9.0/#sec-regexpalloc'
	},
	RegExpBuiltinExec: {
		url: 'https://262.ecma-international.org/9.0/#sec-regexpbuiltinexec'
	},
	RegExpCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-regexpcreate'
	},
	RegExpExec: {
		url: 'https://262.ecma-international.org/9.0/#sec-regexpexec'
	},
	RegExpInitialize: {
		url: 'https://262.ecma-international.org/9.0/#sec-regexpinitialize'
	},
	RejectPromise: {
		url: 'https://262.ecma-international.org/9.0/#sec-rejectpromise'
	},
	RemoveWaiter: {
		url: 'https://262.ecma-international.org/9.0/#sec-removewaiter'
	},
	RemoveWaiters: {
		url: 'https://262.ecma-international.org/9.0/#sec-removewaiters'
	},
	RepeatMatcher: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-repeatmatcher-abstract-operation'
	},
	RequireObjectCoercible: {
		url: 'https://262.ecma-international.org/9.0/#sec-requireobjectcoercible'
	},
	ResolveBinding: {
		url: 'https://262.ecma-international.org/9.0/#sec-resolvebinding'
	},
	ResolveThisBinding: {
		url: 'https://262.ecma-international.org/9.0/#sec-resolvethisbinding'
	},
	ReturnIfAbrupt: {
		url: 'https://262.ecma-international.org/9.0/#sec-returnifabrupt'
	},
	RunJobs: {
		url: 'https://262.ecma-international.org/9.0/#sec-runjobs'
	},
	SameValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-samevalue'
	},
	SameValueNonNumber: {
		url: 'https://262.ecma-international.org/9.0/#sec-samevaluenonnumber'
	},
	SameValueZero: {
		url: 'https://262.ecma-international.org/9.0/#sec-samevaluezero'
	},
	ScriptEvaluation: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-scriptevaluation'
	},
	ScriptEvaluationJob: {
		url: 'https://262.ecma-international.org/9.0/#sec-scriptevaluationjob'
	},
	SecFromTime: {
		url: 'https://262.ecma-international.org/9.0/#eqn-SecFromTime'
	},
	SerializeJSONArray: {
		url: 'https://262.ecma-international.org/9.0/#sec-serializejsonarray'
	},
	SerializeJSONObject: {
		url: 'https://262.ecma-international.org/9.0/#sec-serializejsonobject'
	},
	SerializeJSONProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-serializejsonproperty'
	},
	Set: {
		url: 'https://262.ecma-international.org/9.0/#sec-set-o-p-v-throw'
	},
	SetDefaultGlobalBindings: {
		url: 'https://262.ecma-international.org/9.0/#sec-setdefaultglobalbindings'
	},
	SetFunctionLength: {
		url: 'https://262.ecma-international.org/9.0/#sec-setfunctionlength'
	},
	SetFunctionName: {
		url: 'https://262.ecma-international.org/9.0/#sec-setfunctionname'
	},
	SetImmutablePrototype: {
		url: 'https://262.ecma-international.org/9.0/#sec-set-immutable-prototype'
	},
	SetIntegrityLevel: {
		url: 'https://262.ecma-international.org/9.0/#sec-setintegritylevel'
	},
	SetRealmGlobalObject: {
		url: 'https://262.ecma-international.org/9.0/#sec-setrealmglobalobject'
	},
	SetValueInBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-setvalueinbuffer'
	},
	SetViewValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-setviewvalue'
	},
	SharedDataBlockEventSet: {
		url: 'https://262.ecma-international.org/9.0/#sec-sharedatablockeventset'
	},
	SortCompare: {
		url: 'https://262.ecma-international.org/9.0/#sec-sortcompare'
	},
	SpeciesConstructor: {
		url: 'https://262.ecma-international.org/9.0/#sec-speciesconstructor'
	},
	SplitMatch: {
		url: 'https://262.ecma-international.org/9.0/#sec-splitmatch'
	},
	'Strict Equality Comparison': {
		url: 'https://262.ecma-international.org/9.0/#sec-strict-equality-comparison'
	},
	StringCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-stringcreate'
	},
	StringGetOwnProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-stringgetownproperty'
	},
	Suspend: {
		url: 'https://262.ecma-international.org/9.0/#sec-suspend'
	},
	SymbolDescriptiveString: {
		url: 'https://262.ecma-international.org/9.0/#sec-symboldescriptivestring'
	},
	'synchronizes-with': {
		url: 'https://262.ecma-international.org/9.0/#sec-synchronizes-with'
	},
	TestIntegrityLevel: {
		url: 'https://262.ecma-international.org/9.0/#sec-testintegritylevel'
	},
	thisBooleanValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-thisbooleanvalue'
	},
	thisNumberValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-thisnumbervalue'
	},
	thisStringValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-thisstringvalue'
	},
	thisSymbolValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-thissymbolvalue'
	},
	thisTimeValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-thistimevalue'
	},
	ThrowCompletion: {
		url: 'https://262.ecma-international.org/9.0/#sec-throwcompletion'
	},
	TimeClip: {
		url: 'https://262.ecma-international.org/9.0/#sec-timeclip'
	},
	TimeFromYear: {
		url: 'https://262.ecma-international.org/9.0/#eqn-TimeFromYear'
	},
	TimeString: {
		url: 'https://262.ecma-international.org/9.0/#sec-timestring'
	},
	TimeWithinDay: {
		url: 'https://262.ecma-international.org/9.0/#eqn-TimeWithinDay'
	},
	TimeZoneString: {
		url: 'https://262.ecma-international.org/9.0/#sec-timezoneestring'
	},
	ToBoolean: {
		url: 'https://262.ecma-international.org/9.0/#sec-toboolean'
	},
	ToDateString: {
		url: 'https://262.ecma-international.org/9.0/#sec-todatestring'
	},
	ToIndex: {
		url: 'https://262.ecma-international.org/9.0/#sec-toindex'
	},
	ToInt16: {
		url: 'https://262.ecma-international.org/9.0/#sec-toint16'
	},
	ToInt32: {
		url: 'https://262.ecma-international.org/9.0/#sec-toint32'
	},
	ToInt8: {
		url: 'https://262.ecma-international.org/9.0/#sec-toint8'
	},
	ToInteger: {
		url: 'https://262.ecma-international.org/9.0/#sec-tointeger'
	},
	ToLength: {
		url: 'https://262.ecma-international.org/9.0/#sec-tolength'
	},
	ToNumber: {
		url: 'https://262.ecma-international.org/9.0/#sec-tonumber'
	},
	ToObject: {
		url: 'https://262.ecma-international.org/9.0/#sec-toobject'
	},
	TopLevelModuleEvaluationJob: {
		url: 'https://262.ecma-international.org/9.0/#sec-toplevelmoduleevaluationjob'
	},
	ToPrimitive: {
		url: 'https://262.ecma-international.org/9.0/#sec-toprimitive'
	},
	ToPropertyDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-topropertydescriptor'
	},
	ToPropertyKey: {
		url: 'https://262.ecma-international.org/9.0/#sec-topropertykey'
	},
	ToString: {
		url: 'https://262.ecma-international.org/9.0/#sec-tostring'
	},
	ToUint16: {
		url: 'https://262.ecma-international.org/9.0/#sec-touint16'
	},
	ToUint32: {
		url: 'https://262.ecma-international.org/9.0/#sec-touint32'
	},
	ToUint8: {
		url: 'https://262.ecma-international.org/9.0/#sec-touint8'
	},
	ToUint8Clamp: {
		url: 'https://262.ecma-international.org/9.0/#sec-touint8clamp'
	},
	TriggerPromiseReactions: {
		url: 'https://262.ecma-international.org/9.0/#sec-triggerpromisereactions'
	},
	Type: {
		url: 'https://262.ecma-international.org/9.0/#sec-ecmascript-data-types-and-values'
	},
	TypedArrayCreate: {
		url: 'https://262.ecma-international.org/9.0/#typedarray-create'
	},
	TypedArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/9.0/#typedarray-species-create'
	},
	UnicodeEscape: {
		url: 'https://262.ecma-international.org/9.0/#sec-unicodeescape'
	},
	UnicodeMatchProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-unicodematchproperty-p'
	},
	UnicodeMatchPropertyValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-unicodematchpropertyvalue-p-v'
	},
	UpdateEmpty: {
		url: 'https://262.ecma-international.org/9.0/#sec-updateempty'
	},
	UTC: {
		url: 'https://262.ecma-international.org/9.0/#sec-utc-t'
	},
	UTF16Decode: {
		url: 'https://262.ecma-international.org/9.0/#sec-utf16decode'
	},
	UTF16Encoding: {
		url: 'https://262.ecma-international.org/9.0/#sec-utf16encoding'
	},
	ValidateAndApplyPropertyDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-validateandapplypropertydescriptor'
	},
	ValidateAtomicAccess: {
		url: 'https://262.ecma-international.org/9.0/#sec-validateatomicaccess'
	},
	ValidateSharedIntegerTypedArray: {
		url: 'https://262.ecma-international.org/9.0/#sec-validatesharedintegertypedarray'
	},
	ValidateTypedArray: {
		url: 'https://262.ecma-international.org/9.0/#sec-validatetypedarray'
	},
	ValueOfReadEvent: {
		url: 'https://262.ecma-international.org/9.0/#sec-valueofreadevent'
	},
	WakeWaiter: {
		url: 'https://262.ecma-international.org/9.0/#sec-wakewaiter'
	},
	WeekDay: {
		url: 'https://262.ecma-international.org/9.0/#sec-week-day'
	},
	WordCharacters: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-wordcharacters-abstract-operation'
	},
	YearFromTime: {
		url: 'https://262.ecma-international.org/9.0/#eqn-YearFromTime'
	}
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue;
    }
    if (token.type === "MultiLineComment") {
      result += token.value.replace(/[^\n]/g, FILL_COMMENT);
      continue;
    }
    if (token.type === "StringLiteral") {
      if (!token.closed) {
        result += token.value;
        continue;
      }
      const body = token.value.slice(1, -1);
      {
        result += token.value[0] + FILL.repeat(body.length) + token.value[token.value.length - 1];
        continue;
      }
    }
    if (token.type === "NoSubstitutionTemplate") {
      const body = token.value.slice(1, -1);
      {
        result += `\`${body.replace(/[^\n]/g, FILL)}\``;
        continue;
      }
    }
    if (token.type === "RegularExpressionLiteral") {
      const body = token.value;
      {
        result += body.replace(/\/(.*)\/(\w?)$/g, (_, $1, $2) => `/${FILL.repeat($1.length)}/${$2}`);
        continue;
      }
    }
    if (token.type === "TemplateHead") {
      const body = token.value.slice(1, -2);
      {
        result += `\`${body.replace(/[^\n]/g, FILL)}\${`;
        continue;
      }
    }
    if (token.type === "TemplateTail") {
      const body = token.value.slice(0, -2);
      {
        result += `}${body.replace(/[^\n]/g, FILL)}\``;
        continue;
      }
    }
    if (token.type === "TemplateMiddle") {
      const body = token.value.slice(1, -2);
      {
        result += `}${body.replace(/[^\n]/g, FILL)}\${`;
        continue;
      }
    }
    result += token.value;
  }
  return {
    result,
    tokens
  };
}

function stripLiteral(code, options) {
  return stripLiteralDetailed(code).result;
}
function stripLiteralDetailed(code, options) {
  return stripLiteralJsTokens(code);
}

function importGlobPlugin(config) {
  const importGlobMaps = /* @__PURE__ */ new Map();
  return {
    name: "vite:import-glob",
    buildStart() {
      importGlobMaps.clear();
    },
    async transform(code, id) {
      if (!code.includes("import.meta.glob")) return;
      const result = await transformGlobImport(
        code,
        id,
        config.root,
        (im, _, options) => this.resolve(im, id, options).then((i) => i?.id || im),
        config.experimental.importGlobRestoreExtension,
        config.logger
      );
      if (result) {
        const allGlobs = result.matches.map((i) => i.globsResolved);
        if (!importGlobMaps.has(this.environment)) {
          importGlobMaps.set(this.environment, /* @__PURE__ */ new Map());
        }
        const globMatchers = allGlobs.map((globs) => {
          const affirmed = [];
          const negated = [];
          for (const glob2 of globs) {
            (glob2[0] === "!" ? negated : affirmed).push(glob2);
          }
          const affirmedMatcher = picomatch$5(affirmed);
          const negatedMatcher = picomatch$5(negated);
          return (file) => {
            return (affirmed.length === 0 || affirmedMatcher(file)) && !(negated.length > 0 && negatedMatcher(file));
          };
        });
        importGlobMaps.get(this.environment).set(id, globMatchers);
        return transformStableResult(result.s, id, config);
      }
    },
    hotUpdate({ type, file, modules: oldModules }) {
      if (type === "update") return;
      const importGlobMap = importGlobMaps.get(this.environment);
      if (!importGlobMap) return;
      const modules = [];
      for (const [id, globMatchers] of importGlobMap) {
        if (globMatchers.some((matcher) => matcher(file))) {
          const mod = this.environment.moduleGraph.getModuleById(id);
          if (mod) modules.push(mod);
        }
      }
      return modules.length > 0 ? [...oldModules, ...modules] : void 0;
    }
  };
}
const importGlobRE = /\bimport\.meta\.glob(?:<\w+>)?\s*\(/g;
const objectKeysRE = /\bObject\.keys\(\s*$/;
const objectValuesRE = /\bObject\.values\(\s*$/;
const knownOptions = {
  as: ["string"],
  eager: ["boolean"],
  import: ["string"],
  exhaustive: ["boolean"],
  query: ["object", "string"]
};
const forceDefaultAs = ["raw", "url"];
function err$1(e, pos) {
  const error = new Error(e);
  error.pos = pos;
  return error;
}
function parseGlobOptions(rawOpts, optsStartIndex, logger) {
  let opts = {};
  try {
    opts = evalValue(rawOpts);
  } catch {
    throw err$1(
      "Vite is unable to parse the glob options as the value is not static",
      optsStartIndex
    );
  }
  if (opts == null) {
    return {};
  }
  for (const key in opts) {
    if (!(key in knownOptions)) {
      throw err$1(`Unknown glob option "${key}"`, optsStartIndex);
    }
    const allowedTypes = knownOptions[key];
    const valueType = typeof opts[key];
    if (!allowedTypes.includes(valueType)) {
      throw err$1(
        `Expected glob option "${key}" to be of type ${allowedTypes.join(
          " or "
        )}, but got ${valueType}`,
        optsStartIndex
      );
    }
  }
  if (typeof opts.query === "object") {
    for (const key in opts.query) {
      const value = opts.query[key];
      if (!["string", "number", "boolean"].includes(typeof value)) {
        throw err$1(
          `Expected glob option "query.${key}" to be of type string, number, or boolean, but got ${typeof value}`,
          optsStartIndex
        );
      }
    }
    opts.query = stringifyQuery(opts.query);
  }
  if (opts.as && logger) {
    const importSuggestion = forceDefaultAs.includes(opts.as) ? `, import: 'default'` : "";
    logger.warn(
      colors$1.yellow(
        `The glob option "as" has been deprecated in favour of "query". Please update \`as: '${opts.as}'\` to \`query: '?${opts.as}'${importSuggestion}\`.`
      )
    );
  }
  if (opts.as && forceDefaultAs.includes(opts.as)) {
    if (opts.import && opts.import !== "default" && opts.import !== "*")
      throw err$1(
        `Option "import" can only be "default" or "*" when "as" is "${opts.as}", but got "${opts.import}"`,
        optsStartIndex
      );
    opts.import = opts.import || "default";
  }
  if (opts.as && opts.query)
    throw err$1(
      'Options "as" and "query" cannot be used together',
      optsStartIndex
    );
  if (opts.as) opts.query = opts.as;
  if (opts.query && opts.query[0] !== "?") opts.query = `?${opts.query}`;
  return opts;
}
async function parseImportGlob(code, importer, root, resolveId, logger) {
  let cleanCode;
  try {
    cleanCode = stripLiteral(code);
  } catch {
    return [];
  }
  const matches = Array.from(cleanCode.matchAll(importGlobRE));
  const tasks = matches.map(async (match, index) => {
    const start = match.index;
    const err2 = (msg) => {
      const e = new Error(`Invalid glob import syntax: ${msg}`);
      e.pos = start;
      return e;
    };
    const end = findCorrespondingCloseParenthesisPosition(
      cleanCode,
      start + match[0].length
    ) + 1;
    if (end <= 0) {
      throw err2("Close parenthesis not found");
    }
    const statementCode = code.slice(start, end);
    const rootAst = (await parseAstAsync(statementCode)).body[0];
    if (rootAst.type !== "ExpressionStatement") {
      throw err2(`Expect CallExpression, got ${rootAst.type}`);
    }
    const ast = rootAst.expression;
    if (ast.type !== "CallExpression") {
      throw err2(`Expect CallExpression, got ${ast.type}`);
    }
    if (ast.arguments.length < 1 || ast.arguments.length > 2)
      throw err2(`Expected 1-2 arguments, but got ${ast.arguments.length}`);
    const arg1 = ast.arguments[0];
    const arg2 = ast.arguments[1];
    const globs = [];
    const validateLiteral = (element) => {
      if (!element) return;
      if (element.type === "Literal") {
        if (typeof element.value !== "string")
          throw err2(
            `Expected glob to be a string, but got "${typeof element.value}"`
          );
        globs.push(element.value);
      } else if (element.type === "TemplateLiteral") {
        if (element.expressions.length !== 0) {
          throw err2(
            `Expected glob to be a string, but got dynamic template literal`
          );
        }
        globs.push(element.quasis[0].value.raw);
      } else {
        throw err2("Could only use literals");
      }
    };
    if (arg1.type === "ArrayExpression") {
      for (const element of arg1.elements) {
        validateLiteral(element);
      }
    } else {
      validateLiteral(arg1);
    }
    let options = {};
    if (arg2) {
      if (arg2.type !== "ObjectExpression")
        throw err2(
          `Expected the second argument to be an object literal, but got "${arg2.type}"`
        );
      options = parseGlobOptions(
        code.slice(start + arg2.start, start + arg2.end),
        start + arg2.start,
        logger
      );
    }
    const globsResolved = await Promise.all(
      globs.map((glob2) => toAbsoluteGlob(glob2, root, importer, resolveId))
    );
    const isRelative = globs.every((i) => ".!".includes(i[0]));
    const sliceCode = cleanCode.slice(0, start);
    const onlyKeys = objectKeysRE.test(sliceCode);
    let onlyValues = false;
    if (!onlyKeys) {
      onlyValues = objectValuesRE.test(sliceCode);
    }
    return {
      index,
      globs,
      globsResolved,
      isRelative,
      options,
      start,
      end,
      onlyKeys,
      onlyValues
    };
  });
  return (await Promise.all(tasks)).filter(Boolean);
}
function findCorrespondingCloseParenthesisPosition(cleanCode, openPos) {
  const closePos = cleanCode.indexOf(")", openPos);
  if (closePos < 0) return -1;
  if (!cleanCode.slice(openPos, closePos).includes("(")) return closePos;
  let remainingParenthesisCount = 0;
  const cleanCodeLen = cleanCode.length;
  for (let pos = openPos; pos < cleanCodeLen; pos++) {
    switch (cleanCode[pos]) {
      case "(": {
        remainingParenthesisCount++;
        break;
      }
      case ")": {
        remainingParenthesisCount--;
        if (remainingParenthesisCount <= 0) {
          return pos;
        }
      }
    }
  }
  return -1;
}
const importPrefix = "__vite_glob_";
const { basename, dirname, relative } = posix$1;
async function transformGlobImport(code, id, root, resolveId, restoreQueryExtension = false, logger) {
  id = slash$1(id);
  root = slash$1(root);
  const isVirtual = isVirtualModule(id);
  const dir = isVirtual ? void 0 : dirname(id);
  const matches = await parseImportGlob(
    code,
    isVirtual ? void 0 : id,
    root,
    resolveId,
    logger
  );
  const matchedFiles = /* @__PURE__ */ new Set();
  if (!matches.length) return null;
  const s = new MagicString(code);
  const staticImports = (await Promise.all(
    matches.map(
      async ({
        globsResolved,
        isRelative,
        options,
        index,
        start,
        end,
        onlyKeys,
        onlyValues
      }) => {
        const cwd = getCommonBase(globsResolved) ?? root;
        const files = (await glob(globsResolved, {
          absolute: true,
          cwd,
          dot: !!options.exhaustive,
          expandDirectories: false,
          ignore: options.exhaustive ? [] : ["**/node_modules/**"]
        })).filter((file) => file !== id).sort();
        const objectProps = [];
        const staticImports2 = [];
        const resolvePaths = (file) => {
          if (!dir) {
            if (isRelative)
              throw new Error(
                "In virtual modules, all globs must start with '/'"
              );
            const filePath2 = `/${relative(root, file)}`;
            return { filePath: filePath2, importPath: filePath2 };
          }
          let importPath = relative(dir, file);
          if (importPath[0] !== ".") importPath = `./${importPath}`;
          let filePath;
          if (isRelative) {
            filePath = importPath;
          } else {
            filePath = relative(root, file);
            if (filePath[0] !== ".") filePath = `/${filePath}`;
          }
          return { filePath, importPath };
        };
        files.forEach((file, i) => {
          const paths = resolvePaths(file);
          const filePath = paths.filePath;
          let importPath = paths.importPath;
          let importQuery = options.query ?? "";
          if (onlyKeys) {
            objectProps.push(`${JSON.stringify(filePath)}: 0`);
            return;
          }
          if (importQuery && importQuery !== "?raw") {
            const fileExtension = basename(file).split(".").slice(-1)[0];
            if (fileExtension && restoreQueryExtension)
              importQuery = `${importQuery}&lang.${fileExtension}`;
          }
          importPath = `${importPath}${importQuery}`;
          const importKey = options.import && options.import !== "*" ? options.import : void 0;
          if (options.eager) {
            const variableName = `${importPrefix}${index}_${i}`;
            const expression = importKey ? `{ ${importKey} as ${variableName} }` : `* as ${variableName}`;
            staticImports2.push(
              `import ${expression} from ${JSON.stringify(importPath)}`
            );
            objectProps.push(
              onlyValues ? `${variableName}` : `${JSON.stringify(filePath)}: ${variableName}`
            );
          } else {
            let importStatement = `import(${JSON.stringify(importPath)})`;
            if (importKey)
              importStatement += `.then(m => m[${JSON.stringify(importKey)}])`;
            objectProps.push(
              onlyValues ? `() => ${importStatement}` : `${JSON.stringify(filePath)}: () => ${importStatement}`
            );
          }
        });
        files.forEach((i) => matchedFiles.add(i));
        const originalLineBreakCount = code.slice(start, end).match(/\n/g)?.length ?? 0;
        const lineBreaks = originalLineBreakCount > 0 ? "\n".repeat(originalLineBreakCount) : "";
        let replacement = "";
        if (onlyKeys) {
          replacement = `{${objectProps.join(",")}${lineBreaks}}`;
        } else if (onlyValues) {
          replacement = `[${objectProps.join(",")}${lineBreaks}]`;
        } else {
          replacement = `/* #__PURE__ */ Object.assign({${objectProps.join(
            ","
          )}${lineBreaks}})`;
        }
        s.overwrite(start, end, replacement);
        return staticImports2;
      }
    )
  )).flat();
  if (staticImports.length) s.prepend(`${staticImports.join(";")};`);
  return {
    s,
    matches,
    files: matchedFiles
  };
}
function globSafePath(path) {
  return escapePath(normalizePath$3(path));
}
function lastNthChar(str, n) {
  return str.charAt(str.length - 1 - n);
}
function globSafeResolvedPath(resolved, glob2) {
  let numEqual = 0;
  const maxEqual = Math.min(resolved.length, glob2.length);
  while (numEqual < maxEqual && lastNthChar(resolved, numEqual) === lastNthChar(glob2, numEqual)) {
    numEqual += 1;
  }
  const staticPartEnd = resolved.length - numEqual;
  const staticPart = resolved.slice(0, staticPartEnd);
  const dynamicPart = resolved.slice(staticPartEnd);
  return globSafePath(staticPart) + dynamicPart;
}
async function toAbsoluteGlob(glob2, root, importer, resolveId) {
  let pre = "";
  if (glob2[0] === "!") {
    pre = "!";
    glob2 = glob2.slice(1);
  }
  root = globSafePath(root);
  const dir = importer ? globSafePath(dirname(importer)) : root;
  if (glob2[0] === "/") return pre + posix$1.join(root, glob2.slice(1));
  if (glob2.startsWith("./")) return pre + posix$1.join(dir, glob2.slice(2));
  if (glob2.startsWith("../")) return pre + posix$1.join(dir, glob2);
  if (glob2.startsWith("**")) return pre + glob2;
  const isSubImportsPattern = glob2[0] === "#" && glob2.includes("*");
  const resolved = normalizePath$3(
    await resolveId(glob2, importer, {
      custom: { "vite:import-glob": { isSubImportsPattern } }
    }) || glob2
  );
  if (isAbsolute$1(resolved)) {
    return pre + globSafeResolvedPath(resolved, glob2);
  }
  throw new Error(
    `Invalid glob: "${glob2}" (resolved: "${resolved}"). It must start with '/' or './'`
  );
}
function getCommonBase(globsResolved) {
  const bases = globsResolved.filter((g) => g[0] !== "!").map((glob2) => {
    let { base } = picomatch$5.scan(glob2);
    if (posix$1.basename(base).includes(".")) base = posix$1.dirname(base);
    return base;
  });
  if (!bases.length) return null;
  let commonAncestor = "";
  const dirS = bases[0].split("/");
  for (let i = 0; i < dirS.length; i++) {
    const candidate = dirS.slice(0, i + 1).join("/");
    if (bases.every((base) => base.startsWith(candidate)))
      commonAncestor = candidate;
    else break;
  }
  if (!commonAncestor) commonAncestor = "/";
  return commonAncestor;
}
function isVirtualModule(id) {
  return id.startsWith("virtual:") || id[0] === "\0" || !id.includes("/");
}

class ScanEnvironment extends BaseEnvironment {
  mode = "scan";
  get pluginContainer() {
    if (!this._pluginContainer)
      throw new Error(
        `${this.name} environment.pluginContainer called before initialized`
      );
    return this._pluginContainer;
  }
  /**
   * @internal
   */
  _pluginContainer;
  async init() {
    if (this._initiated) {
      return;
    }
    this._initiated = true;
    this._plugins = await resolveEnvironmentPlugins(this);
    this._pluginContainer = await createEnvironmentPluginContainer(
      this,
      this.plugins
    );
    await this._pluginContainer.buildStart();
  }
}
function devToScanEnvironment(environment) {
  return {
    mode: "scan",
    get name() {
      return environment.name;
    },
    getTopLevelConfig() {
      return environment.getTopLevelConfig();
    },
    /**
     * @deprecated use environment.config instead
     **/
    get options() {
      return environment.options;
    },
    get config() {
      return environment.config;
    },
    get logger() {
      return environment.logger;
    },
    get pluginContainer() {
      return environment.pluginContainer;
    },
    get plugins() {
      return environment.plugins;
    }
  };
}
const debug$d = createDebugger("vite:deps");
const htmlTypesRE = /\.(html|vue|svelte|astro|imba)$/;
const importsRE = /(?<!\/\/.*)(?<=^|;|\*\/)\s*import(?!\s+type)(?:[\w*{}\n\r\t, ]+from)?\s*("[^"]+"|'[^']+')\s*(?=$|;|\/\/|\/\*)/gm;
function scanImports(environment) {
  const start = performance.now();
  const deps = {};
  const missing = {};
  let entries;
  const { config } = environment;
  const scanContext = { cancelled: false };
  const esbuildContext = computeEntries(
    environment
  ).then((computedEntries) => {
    entries = computedEntries;
    if (!entries.length) {
      if (!config.optimizeDeps.entries && !config.optimizeDeps.include) {
        environment.logger.warn(
          colors$1.yellow(
            "(!) Could not auto-determine entry point from rollupOptions or html files and there are no explicit optimizeDeps.include patterns. Skipping dependency pre-bundling."
          )
        );
      }
      return;
    }
    if (scanContext.cancelled) return;
    debug$d?.(
      `Crawling dependencies using entries: ${entries.map((entry) => `
  ${colors$1.dim(entry)}`).join("")}`
    );
    return prepareEsbuildScanner(
      environment,
      entries,
      deps,
      missing,
      scanContext
    );
  });
  const result = esbuildContext.then((context) => {
    function disposeContext() {
      return context?.dispose().catch((e) => {
        environment.logger.error("Failed to dispose esbuild context", {
          error: e
        });
      });
    }
    if (!context || scanContext?.cancelled) {
      disposeContext();
      return { deps: {}, missing: {} };
    }
    return context.rebuild().then(() => {
      return {
        // Ensure a fixed order so hashes are stable and improve logs
        deps: orderedDependencies(deps),
        missing
      };
    }).finally(() => {
      return disposeContext();
    });
  }).catch(async (e) => {
    if (e.errors && e.message.includes("The build was canceled")) {
      return { deps: {}, missing: {} };
    }
    const prependMessage = colors$1.red(`  Failed to scan for dependencies from entries:
  ${entries.join("\n")}

  `);
    if (e.errors) {
      const msgs = await formatMessages(e.errors, {
        kind: "error",
        color: true
      });
      e.message = prependMessage + msgs.join("\n");
    } else {
      e.message = prependMessage + e.message;
    }
    throw e;
  }).finally(() => {
    if (debug$d) {
      const duration = (performance.now() - start).toFixed(2);
      const depsStr = Object.keys(orderedDependencies(deps)).sort().map((id) => `
  ${colors$1.cyan(id)} -> ${colors$1.dim(deps[id])}`).join("") || colors$1.dim("no dependencies found");
      debug$d(`Scan completed in ${duration}ms: ${depsStr}`);
    }
  });
  return {
    cancel: async () => {
      scanContext.cancelled = true;
      return esbuildContext.then((context) => context?.cancel());
    },
    result
  };
}
async function computeEntries(environment) {
  let entries = [];
  const explicitEntryPatterns = environment.config.optimizeDeps.entries;
  const buildInput = environment.config.build.rollupOptions?.input;
  if (explicitEntryPatterns) {
    entries = await globEntries(explicitEntryPatterns, environment);
  } else if (buildInput) {
    const resolvePath = async (p) => {
      const id = (await environment.pluginContainer.resolveId(p, void 0, {
        scan: true
      }))?.id;
      if (id === void 0) {
        throw new Error(
          `failed to resolve rollupOptions.input value: ${JSON.stringify(p)}.`
        );
      }
      return id;
    };
    if (typeof buildInput === "string") {
      entries = [await resolvePath(buildInput)];
    } else if (Array.isArray(buildInput)) {
      entries = await Promise.all(buildInput.map(resolvePath));
    } else if (isObject$2(buildInput)) {
      entries = await Promise.all(Object.values(buildInput).map(resolvePath));
    } else {
      throw new Error("invalid rollupOptions.input value.");
    }
  } else {
    entries = await globEntries("**/*.html", environment);
  }
  entries = entries.filter(
    (entry) => isScannable(entry, environment.config.optimizeDeps.extensions) && fs__default.existsSync(entry)
  );
  return entries;
}
async function prepareEsbuildScanner(environment, entries, deps, missing, scanContext) {
  if (scanContext?.cancelled) return;
  const plugin = esbuildScanPlugin(environment, deps, missing, entries);
  const { plugins = [], ...esbuildOptions } = environment.config.optimizeDeps.esbuildOptions ?? {};
  let tsconfigRaw = esbuildOptions.tsconfigRaw;
  if (!tsconfigRaw && !esbuildOptions.tsconfig) {
    const { tsconfig } = await loadTsconfigJsonForFile(
      path$d.join(environment.config.root, "_dummy.js")
    );
    if (tsconfig.compilerOptions?.experimentalDecorators) {
      tsconfigRaw = { compilerOptions: { experimentalDecorators: true } };
    }
  }
  return await esbuild.context({
    absWorkingDir: process.cwd(),
    write: false,
    stdin: {
      contents: entries.map((e) => `import ${JSON.stringify(e)}`).join("\n"),
      loader: "js"
    },
    bundle: true,
    format: "esm",
    logLevel: "silent",
    plugins: [...plugins, plugin],
    ...esbuildOptions,
    tsconfigRaw
  });
}
function orderedDependencies(deps) {
  const depsList = Object.entries(deps);
  depsList.sort((a, b) => a[0].localeCompare(b[0]));
  return Object.fromEntries(depsList);
}
function globEntries(pattern, environment) {
  const resolvedPatterns = arraify(pattern);
  if (resolvedPatterns.every((str) => !isDynamicPattern(str))) {
    return resolvedPatterns.map(
      (p) => normalizePath$3(path$d.resolve(environment.config.root, p))
    );
  }
  return glob(pattern, {
    absolute: true,
    cwd: environment.config.root,
    ignore: [
      "**/node_modules/**",
      `**/${environment.config.build.outDir}/**`,
      // if there aren't explicit entries, also ignore other common folders
      ...environment.config.optimizeDeps.entries ? [] : [`**/__tests__/**`, `**/coverage/**`]
    ]
  });
}
const scriptRE = /(<script(?:\s+[a-z_:][-\w:]*(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^"'<>=\s]+))?)*\s*>)(.*?)<\/script>/gis;
const commentRE$1 = /<!--.*?-->/gs;
const srcRE = /\bsrc\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const typeRE = /\btype\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const langRE = /\blang\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const svelteScriptModuleRE = /\bcontext\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const svelteModuleRE = /\smodule\b/i;
function esbuildScanPlugin(environment, depImports, missing, entries) {
  const seen = /* @__PURE__ */ new Map();
  async function resolveId(id, importer, options) {
    return environment.pluginContainer.resolveId(
      id,
      importer && normalizePath$3(importer),
      {
        ...options,
        scan: true
      }
    );
  }
  const resolve = async (id, importer, options) => {
    const key = id + (importer && path$d.dirname(importer));
    if (seen.has(key)) {
      return seen.get(key);
    }
    const resolved = await resolveId(id, importer, options);
    const res = resolved?.id;
    seen.set(key, res);
    return res;
  };
  const optimizeDepsOptions = environment.config.optimizeDeps;
  const include = optimizeDepsOptions.include;
  const exclude = [
    ...optimizeDepsOptions.exclude ?? [],
    "@vite/client",
    "@vite/env"
  ];
  const isUnlessEntry = (path2) => !entries.includes(path2);
  const externalUnlessEntry = ({ path: path2 }) => ({
    path: path2,
    external: isUnlessEntry(path2)
  });
  const doTransformGlobImport = async (contents, id, loader) => {
    let transpiledContents;
    if (loader !== "js") {
      transpiledContents = (await transform$1(contents, { loader })).code;
    } else {
      transpiledContents = contents;
    }
    const result = await transformGlobImport(
      transpiledContents,
      id,
      environment.config.root,
      resolve
    );
    return result?.s.toString() || transpiledContents;
  };
  return {
    name: "vite:dep-scan",
    setup(build) {
      const scripts = {};
      build.onResolve({ filter: externalRE }, ({ path: path2 }) => ({
        path: path2,
        external: true
      }));
      build.onResolve({ filter: dataUrlRE }, ({ path: path2 }) => ({
        path: path2,
        external: true
      }));
      build.onResolve({ filter: virtualModuleRE }, ({ path: path2 }) => {
        return {
          // strip prefix to get valid filesystem path so esbuild can resolve imports in the file
          path: path2.replace(virtualModulePrefix, ""),
          namespace: "script"
        };
      });
      build.onLoad({ filter: /.*/, namespace: "script" }, ({ path: path2 }) => {
        return scripts[path2];
      });
      build.onResolve({ filter: htmlTypesRE }, async ({ path: path2, importer }) => {
        const resolved = await resolve(path2, importer);
        if (!resolved) return;
        if (isInNodeModules$1(resolved) && isOptimizable(resolved, optimizeDepsOptions))
          return;
        return {
          path: resolved,
          namespace: "html"
        };
      });
      const htmlTypeOnLoadCallback = async ({ path: p }) => {
        let raw = await fsp.readFile(p, "utf-8");
        raw = raw.replace(commentRE$1, "<!---->");
        const isHtml = p.endsWith(".html");
        let js = "";
        let scriptId = 0;
        const matches = raw.matchAll(scriptRE);
        for (const [, openTag, content] of matches) {
          const typeMatch = typeRE.exec(openTag);
          const type = typeMatch && (typeMatch[1] || typeMatch[2] || typeMatch[3]);
          const langMatch = langRE.exec(openTag);
          const lang = langMatch && (langMatch[1] || langMatch[2] || langMatch[3]);
          if (isHtml && type !== "module") {
            continue;
          }
          if (type && !(type.includes("javascript") || type.includes("ecmascript") || type === "module")) {
            continue;
          }
          let loader = "js";
          if (lang === "ts" || lang === "tsx" || lang === "jsx") {
            loader = lang;
          } else if (p.endsWith(".astro")) {
            loader = "ts";
          }
          const srcMatch = srcRE.exec(openTag);
          if (srcMatch) {
            const src = srcMatch[1] || srcMatch[2] || srcMatch[3];
            js += `import ${JSON.stringify(src)}
`;
          } else if (content.trim()) {
            const contents = content + (loader.startsWith("ts") ? extractImportPaths(content) : "");
            const key = `${p}?id=${scriptId++}`;
            if (contents.includes("import.meta.glob")) {
              scripts[key] = {
                loader: "js",
                // since it is transpiled
                contents: await doTransformGlobImport(contents, p, loader),
                resolveDir: normalizePath$3(path$d.dirname(p)),
                pluginData: {
                  htmlType: { loader }
                }
              };
            } else {
              scripts[key] = {
                loader,
                contents,
                resolveDir: normalizePath$3(path$d.dirname(p)),
                pluginData: {
                  htmlType: { loader }
                }
              };
            }
            const virtualModulePath = JSON.stringify(virtualModulePrefix + key);
            let addedImport = false;
            if (p.endsWith(".svelte")) {
              let isModule = svelteModuleRE.test(openTag);
              if (!isModule) {
                const contextMatch = svelteScriptModuleRE.exec(openTag);
                const context = contextMatch && (contextMatch[1] || contextMatch[2] || contextMatch[3]);
                isModule = context === "module";
              }
              if (!isModule) {
                addedImport = true;
                js += `import ${virtualModulePath}
`;
              }
            }
            if (!addedImport) {
              js += `export * from ${virtualModulePath}
`;
            }
          }
        }
        if (!p.endsWith(".vue") || !js.includes("export default")) {
          js += "\nexport default {}";
        }
        return {
          loader: "js",
          contents: js
        };
      };
      build.onLoad(
        { filter: htmlTypesRE, namespace: "html" },
        htmlTypeOnLoadCallback
      );
      build.onLoad(
        { filter: htmlTypesRE, namespace: "file" },
        htmlTypeOnLoadCallback
      );
      build.onResolve(
        {
          // avoid matching windows volume
          filter: /^[\w@][^:]/
        },
        async ({ path: id, importer, pluginData }) => {
          if (moduleListContains(exclude, id)) {
            return externalUnlessEntry({ path: id });
          }
          if (depImports[id]) {
            return externalUnlessEntry({ path: id });
          }
          const resolved = await resolve(id, importer, {
            custom: {
              depScan: { loader: pluginData?.htmlType?.loader }
            }
          });
          if (resolved) {
            if (shouldExternalizeDep(resolved, id)) {
              return externalUnlessEntry({ path: id });
            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  'use strict';

module.exports = {
	IsPropertyDescriptor: 'https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type', // not actually an abstract op

	abs: {
		url: 'https://262.ecma-international.org/7.0/#sec-algorithm-conventions'
	},
	'Abstract Equality Comparison': {
		url: 'https://262.ecma-international.org/7.0/#sec-abstract-equality-comparison'
	},
	'Abstract Relational Comparison': {
		url: 'https://262.ecma-international.org/7.0/#sec-abstract-relational-comparison'
	},
	AddRestrictedFunctionProperties: {
		url: 'https://262.ecma-international.org/7.0/#sec-addrestrictedfunctionproperties'
	},
	AdvanceStringIndex: {
		url: 'https://262.ecma-international.org/7.0/#sec-advancestringindex'
	},
	AllocateArrayBuffer: {
		url: 'https://262.ecma-international.org/7.0/#sec-allocatearraybuffer'
	},
	AllocateTypedArray: {
		url: 'https://262.ecma-international.org/7.0/#sec-allocatetypedarray'
	},
	AllocateTypedArrayBuffer: {
		url: 'https://262.ecma-international.org/7.0/#sec-allocatetypedarraybuffer'
	},
	ArrayCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-arraycreate'
	},
	ArraySetLength: {
		url: 'https://262.ecma-international.org/7.0/#sec-arraysetlength'
	},
	ArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-arrayspeciescreate'
	},
	BlockDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/7.0/#sec-blockdeclarationinstantiation'
	},
	BoundFunctionCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-boundfunctioncreate'
	},
	Call: {
		url: 'https://262.ecma-international.org/7.0/#sec-call'
	},
	Canonicalize: {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-canonicalize-ch'
	},
	CanonicalNumericIndexString: {
		url: 'https://262.ecma-international.org/7.0/#sec-canonicalnumericindexstring'
	},
	CharacterRange: {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-characterrange-abstract-operation'
	},
	CharacterRangeOrUnion: {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-characterrangeorunion-abstract-operation'
	},
	CharacterSetMatcher: {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-charactersetmatcher-abstract-operation'
	},
	CloneArrayBuffer: {
		url: 'https://262.ecma-international.org/7.0/#sec-clonearraybuffer'
	},
	CompletePropertyDescriptor: {
		url: 'https://262.ecma-international.org/7.0/#sec-completepropertydescriptor'
	},
	Completion: {
		url: 'https://262.ecma-international.org/7.0/#sec-completion-record-specification-type'
	},
	CompletionRecord: {
		url: 'https://262.ecma-international.org/7.0/#sec-completion-record-specification-type'
	},
	Construct: {
		url: 'https://262.ecma-international.org/7.0/#sec-construct'
	},
	CopyDataBlockBytes: {
		url: 'https://262.ecma-international.org/7.0/#sec-copydatablockbytes'
	},
	CreateArrayFromList: {
		url: 'https://262.ecma-international.org/7.0/#sec-createarrayfromlist'
	},
	CreateArrayIterator: {
		url: 'https://262.ecma-international.org/7.0/#sec-createarrayiterator'
	},
	CreateBuiltinFunction: {
		url: 'https://262.ecma-international.org/7.0/#sec-createbuiltinfunction'
	},
	CreateByteDataBlock: {
		url: 'https://262.ecma-international.org/7.0/#sec-createbytedatablock'
	},
	CreateDataProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-createdataproperty'
	},
	CreateDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/7.0/#sec-createdatapropertyorthrow'
	},
	CreateDynamicFunction: {
		url: 'https://262.ecma-international.org/7.0/#sec-createdynamicfunction'
	},
	CreateHTML: {
		url: 'https://262.ecma-international.org/7.0/#sec-createhtml'
	},
	CreateIntrinsics: {
		url: 'https://262.ecma-international.org/7.0/#sec-createintrinsics'
	},
	CreateIterResultObject: {
		url: 'https://262.ecma-international.org/7.0/#sec-createiterresultobject'
	},
	CreateListFromArrayLike: {
		url: 'https://262.ecma-international.org/7.0/#sec-createlistfromarraylike'
	},
	CreateListIterator: {
		url: 'https://262.ecma-international.org/7.0/#sec-createlistiterator'
	},
	CreateMapIterator: {
		url: 'https://262.ecma-international.org/7.0/#sec-createmapiterator'
	},
	CreateMappedArgumentsObject: {
		url: 'https://262.ecma-international.org/7.0/#sec-createmappedargumentsobject'
	},
	CreateMethodProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-createmethodproperty'
	},
	CreatePerIterationEnvironment: {
		url: 'https://262.ecma-international.org/7.0/#sec-createperiterationenvironment'
	},
	CreateRealm: {
		url: 'https://262.ecma-international.org/7.0/#sec-createrealm'
	},
	CreateResolvingFunctions: {
		url: 'https://262.ecma-international.org/7.0/#sec-createresolvingfunctions'
	},
	CreateSetIterator: {
		url: 'https://262.ecma-international.org/7.0/#sec-createsetiterator'
	},
	CreateStringIterator: {
		url: 'https://262.ecma-international.org/7.0/#sec-createstringiterator'
	},
	CreateUnmappedArgumentsObject: {
		url: 'https://262.ecma-international.org/7.0/#sec-createunmappedargumentsobject'
	},
	DateFromTime: {
		url: 'https://262.ecma-international.org/7.0/#sec-date-number'
	},
	Day: {
		url: 'https://262.ecma-international.org/7.0/#sec-day-number-and-time-within-day'
	},
	DayFromYear: {
		url: 'https://262.ecma-international.org/7.0/#sec-year-number'
	},
	DaylightSavingTA: {
		url: 'https://262.ecma-international.org/7.0/#sec-daylight-saving-time-adjustment'
	},
	DaysInYear: {
		url: 'https://262.ecma-international.org/7.0/#sec-year-number'
	},
	DayWithinYear: {
		url: 'https://262.ecma-international.org/7.0/#sec-month-number'
	},
	Decode: {
		url: 'https://262.ecma-international.org/7.0/#sec-decode'
	},
	DefinePropertyOrThrow: {
		url: 'https://262.ecma-international.org/7.0/#sec-definepropertyorthrow'
	},
	DeletePropertyOrThrow: {
		url: 'https://262.ecma-international.org/7.0/#sec-deletepropertyorthrow'
	},
	DetachArrayBuffer: {
		url: 'https://262.ecma-international.org/7.0/#sec-detacharraybuffer'
	},
	Encode: {
		url: 'https://262.ecma-international.org/7.0/#sec-encode'
	},
	EnqueueJob: {
		url: 'https://262.ecma-international.org/7.0/#sec-enqueuejob'
	},
	EnumerableOwnNames: {
		url: 'https://262.ecma-international.org/7.0/#sec-enumerableownnames'
	},
	EnumerateObjectProperties: {
		url: 'https://262.ecma-international.org/7.0/#sec-enumerate-object-properties'
	},
	EscapeRegExpPattern: {
		url: 'https://262.ecma-international.org/7.0/#sec-escaperegexppattern'
	},
	EvalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/7.0/#sec-evaldeclarationinstantiation'
	},
	EvaluateCall: {
		url: 'https://262.ecma-international.org/7.0/#sec-evaluatecall'
	},
	EvaluateDirectCall: {
		url: 'https://262.ecma-international.org/7.0/#sec-evaluatedirectcall'
	},
	EvaluateNew: {
		url: 'https://262.ecma-international.org/7.0/#sec-evaluatenew'
	},
	floor: {
		url: 'https://262.ecma-international.org/7.0/#sec-algorithm-conventions'
	},
	ForBodyEvaluation: {
		url: 'https://262.ecma-international.org/7.0/#sec-forbodyevaluation'
	},
	'ForIn/OfBodyEvaluation': {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset'
	},
	'ForIn/OfHeadEvaluation': {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind'
	},
	FromPropertyDescriptor: {
		url: 'https://262.ecma-international.org/7.0/#sec-frompropertydescriptor'
	},
	FulfillPromise: {
		url: 'https://262.ecma-international.org/7.0/#sec-fulfillpromise'
	},
	FunctionAllocate: {
		url: 'https://262.ecma-international.org/7.0/#sec-functionallocate'
	},
	FunctionCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-functioncreate'
	},
	FunctionDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/7.0/#sec-functiondeclarationinstantiation'
	},
	FunctionInitialize: {
		url: 'https://262.ecma-international.org/7.0/#sec-functioninitialize'
	},
	GeneratorFunctionCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-generatorfunctioncreate'
	},
	GeneratorResume: {
		url: 'https://262.ecma-international.org/7.0/#sec-generatorresume'
	},
	GeneratorResumeAbrupt: {
		url: 'https://262.ecma-international.org/7.0/#sec-generatorresumeabrupt'
	},
	GeneratorStart: {
		url: 'https://262.ecma-international.org/7.0/#sec-generatorstart'
	},
	GeneratorValidate: {
		url: 'https://262.ecma-international.org/7.0/#sec-generatorvalidate'
	},
	GeneratorYield: {
		url: 'https://262.ecma-international.org/7.0/#sec-generatoryield'
	},
	Get: {
		url: 'https://262.ecma-international.org/7.0/#sec-get-o-p'
	},
	GetActiveScriptOrModule: {
		url: 'https://262.ecma-international.org/7.0/#sec-getactivescriptormodule'
	},
	GetFunctionRealm: {
		url: 'https://262.ecma-international.org/7.0/#sec-getfunctionrealm'
	},
	GetGlobalObject: {
		url: 'https://262.ecma-international.org/7.0/#sec-getglobalobject'
	},
	GetIdentifierReference: {
		url: 'https://262.ecma-international.org/7.0/#sec-getidentifierreference'
	},
	GetIterator: {
		url: 'https://262.ecma-international.org/7.0/#sec-getiterator'
	},
	GetMethod: {
		url: 'https://262.ecma-international.org/7.0/#sec-getmethod'
	},
	GetModuleNamespace: {
		url: 'https://262.ecma-international.org/7.0/#sec-getmodulenamespace'
	},
	GetNewTarget: {
		url: 'https://262.ecma-international.org/7.0/#sec-getnewtarget'
	},
	GetOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/7.0/#sec-getownpropertykeys'
	},
	GetPrototypeFromConstructor: {
		url: 'https://262.ecma-international.org/7.0/#sec-getprototypefromconstructor'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/7.0/#sec-getsubstitution'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/7.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/7.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/7.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-getthisvalue'
	},
	GetV: {
		url: 'https://262.ecma-international.org/7.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/7.0/#sec-getvaluefrombuffer'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-getviewvalue'
	},
	GlobalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/7.0/#sec-globaldeclarationinstantiation'
	},
	HasOwnProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-hasownproperty'
	},
	HasProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-hasproperty'
	},
	HourFromTime: {
		url: 'https://262.ecma-international.org/7.0/#sec-hours-minutes-second-and-milliseconds'
	},
	IfAbruptRejectPromise: {
		url: 'https://262.ecma-international.org/7.0/#sec-ifabruptrejectpromise'
	},
	ImportedLocalNames: {
		url: 'https://262.ecma-international.org/7.0/#sec-importedlocalnames'
	},
	InitializeBoundName: {
		url: 'https://262.ecma-international.org/7.0/#sec-initializeboundname'
	},
	InitializeHostDefinedRealm: {
		url: 'https://262.ecma-international.org/7.0/#sec-initializehostdefinedrealm'
	},
	InitializeReferencedBinding: {
		url: 'https://262.ecma-international.org/7.0/#sec-initializereferencedbinding'
	},
	InLeapYear: {
		url: 'https://262.ecma-international.org/7.0/#sec-year-number'
	},
	InstanceofOperator: {
		url: 'https://262.ecma-international.org/7.0/#sec-instanceofoperator'
	},
	IntegerIndexedElementGet: {
		url: 'https://262.ecma-international.org/7.0/#sec-integerindexedelementget'
	},
	IntegerIndexedElementSet: {
		url: 'https://262.ecma-international.org/7.0/#sec-integerindexedelementset'
	},
	IntegerIndexedObjectCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-integerindexedobjectcreate'
	},
	InternalizeJSONProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-internalizejsonproperty'
	},
	Invoke: {
		url: 'https://262.ecma-international.org/7.0/#sec-invoke'
	},
	IsAccessorDescriptor: {
		url: 'https://262.ecma-international.org/7.0/#sec-isaccessordescriptor'
	},
	IsAnonymousFunctionDefinition: {
		url: 'https://262.ecma-international.org/7.0/#sec-isanonymousfunctiondefinition'
	},
	IsArray: {
		url: 'https://262.ecma-international.org/7.0/#sec-isarray'
	},
	IsCallable: {
		url: 'https://262.ecma-international.org/7.0/#sec-iscallable'
	},
	IsCompatiblePropertyDescriptor: {
		url: 'https://262.ecma-international.org/7.0/#sec-iscompatiblepropertydescriptor'
	},
	IsConcatSpreadable: {
		url: 'https://262.ecma-international.org/7.0/#sec-isconcatspreadable'
	