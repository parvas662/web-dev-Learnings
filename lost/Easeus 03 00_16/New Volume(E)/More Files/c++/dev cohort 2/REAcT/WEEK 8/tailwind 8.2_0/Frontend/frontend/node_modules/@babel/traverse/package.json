parseBindingList;

function parseAssignableListItem(allowModifiers, isBlockScope) {
  if (allowModifiers) {
    _typescript.tsParseModifiers.call(void 0, [
      _keywords.ContextualKeyword._public,
      _keywords.ContextualKeyword._protected,
      _keywords.ContextualKeyword._private,
      _keywords.ContextualKeyword._readonly,
      _keywords.ContextualKeyword._override,
    ]);
  }

  parseMaybeDefault(isBlockScope);
  parseAssignableListItemTypes();
  parseMaybeDefault(isBlockScope, true /* leftAlreadyParsed */);
}

function parseAssignableListItemTypes() {
  if (_base.isFlowEnabled) {
    _flow.flowParseAssignableListItemTypes.call(void 0, );
  } else if (_base.isTypeScriptEnabled) {
    _typescript.tsParseAssignableListItemTypes.call(void 0, );
  }
}

// Parses assignment pattern around given atom if possible.
 function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {
  if (!leftAlreadyParsed) {
    parseBindingAtom(isBlockScope);
  }
  if (!_index.eat.call(void 0, _types.TokenType.eq)) {
    return;
  }
  const eqIndex = _base.state.tokens.