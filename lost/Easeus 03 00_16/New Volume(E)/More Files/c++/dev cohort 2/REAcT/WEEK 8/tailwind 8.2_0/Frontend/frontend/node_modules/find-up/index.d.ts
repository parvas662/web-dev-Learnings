nt.right and parent.body
                        return false;

                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;
                    case "CallExpression":
                        if (parent.callee !== node) {
                            return false;
                        }
                        break;

                    // EXCLUDES: e.g. cache[foo.a] = 0;
                    case "MemberExpression":
                        if (parent.property === node) {
                            return false;
                        }
                        break;

                    // EXCLUDES: e.g. ({ [foo]: a }) = bar;
                    case "Property":
                        if (parent.key === node) {
                            return false;
                        }

                        break;

                    // EXCLUDES: e.g. (foo ? a : b).c = bar;
                    case "ConditionalExpression":
                        if (parent.test === node) {
                            return false;
                        }

                        break;

                    // no default
                }

                node = parent;
                parent = node.parent;
            }

            return false;
        }

        /**
         * Tests that an identifier name matches any of the ignored property assignments.
         * First we test strings in ignoredPropertyAssignmentsFor.
         * Then we instantiate and test RegExp objects from ignoredPropertyAssignmentsForRegex strings.
         * @param {string} identifierName A string that describes the name of an identifier to
         * ignore property assignments for.
         * @returns {boolean} Whether the string matches an ignored property assignment regular expression or not.
         */
        function isIgnoredPropertyAssignment(identifierName) {
            return ignoredPropertyAssignmentsFor.includes(identifierName) ||
                ignoredPropertyAssignmentsForRegex.some(ignored => new RegExp(ignored, "u").test(identifierName));
        }

        /**
         * Reports a reference if is non initializer and writable.
         * @param {Reference} reference A reference to check.
         * @param {int} index The index of the reference in the references.
         * @param {Reference[]} references The array that the reference belongs to.
         * @returns {void}
         */
        function checkReference(reference, index, references) {
            const identifier = reference.identifier;

            if (identifier &&
                !reference.init &&

                /*
                 * Destructuring assignments can have multiple default value,
                 * so possibly there are multiple writeable references for the same identifier.
                 */
                (index === 0 || references[index - 1].identifier !== identifier)
            ) {
                if (reference.isWrite()) {
                    context.report({
                        node: identifier,
                        messageId: "assignmentToFunctionParam",
                        data: { name: identifier.name }
                    });
                } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {
                    context.report({
                        node: identifier,
                        messageId: "assignmentToFunctionParamProp",
                        data: { name: identifier.name }
                    });
                }
            }
        }

        /**
         * Finds and reports references that are non initializer and writable.
         * @param {Variable} variable A variable to check.
         * @returns {void}
         */
        function