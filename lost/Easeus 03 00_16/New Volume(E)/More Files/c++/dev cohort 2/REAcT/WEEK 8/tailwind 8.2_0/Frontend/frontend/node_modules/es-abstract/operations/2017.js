    continue;
    }
    if (token.type === "MultiLineComment") {
      result += token.value.replace(/[^\n]/g, FILL_COMMENT);
      continue;
    }
    if (token.type === "StringLiteral") {
      if (!token.closed) {
        result += token.value;
        continue;
      }
      const body = token.value.slice(1, -1);
      {
        result += token.value[0] + FILL.repeat(body.length) + token.value[token.value.length - 1];
        continue;
      }
    }
    if (token.type === "NoSubstitutionTemplate") {
      const body = token.value.slice(1, -1);
      {
        result += `\`${body.replace(/[^\n]/g, FILL)}\``;
        continue;
      }
    }
    if (token.type === "RegularExpressionLiteral") {
      const body = token.value;
      {
        result += body.replace(/\/(.*)\/(\w?)$/g, (_, $1, $2) => `/${FILL.repeat($1.length)}/${$2}`);
        continue;
      }
    }
    if (token.type === "TemplateHead") {
      const body = token.value.slice(1, -2);
      {
        result += `\`${body.replace(/[^\n]/g, FILL)}\${`;
        continue;
      }
    }
    if (token.type === "TemplateTail") {
      const body = token.value.slice(0, -2);
      {
        result += `}${body.replace(/[^\n]/g, FILL)}\``;
        continue;
      }
    }
    if (token.type === "TemplateMiddle") {
      const body = token.value.slice(1, -2);
      {
        result += `}${body.replace(/[^\n]/g, FILL)}\${`;
        continue;
      }
    }
    result += token.value;
  }
  return {
    result,
    tokens
  };
}

function stripLiteral(code, options) {
  return stripLiteralDetailed(code).result;
}
function stripLiteralDetailed(code, options) {
  return stripLiteralJsTokens(code);
}

function importGlobPlugin(config) {
  const importGlobMaps = /* @__PURE__ */ new Map();
  return {
    name: "vite:import-glob",
    buildStart() {
      importGlobMaps.clear();
    },
    async transform(code, id) {
      if (!code.includes("import.meta.glob")) return;
      const result = await transformGlobImport(
        code,
        id,
        config.root,
        (im, _, options) => this.resolve(im, id, options).then((i) => i?.id || im),
        config.experimental.importGlobRestoreExtension,
        config.logger
      );
      if (result) {
        const allGlobs = result.matches.map((i) => i.globsResolved);
        if (!importGlobMaps.has(this.environment)) {
          importGlobMaps.set(this.environment, /* @__PURE__ */ new Map());
        }
        const globMatchers = allGlobs.map((globs) => {
          const affirmed = [];
          const negated = [];
          for (const glob2 of globs) {
            (glob2[0] === "!" ? negated : affirmed).push(glob2);
          }
          const affirmedMatcher = picomatch$5(affirmed);
          const negatedMatcher = picomatch$5(negated);
          return (file) => {
            return (affirmed.length === 0 || affirmedMatcher(file)) && !(negated.length > 0 && negatedMatcher(file));
          };
        });
        importGlobMaps.get(this.environment).set(id, globMatchers);
        return transformStableResult(result.s, id, config);
      }
    },
    hotUpdate({ type, file, modules: oldModules }) {
      if (type === "update") return;
      const importGlobMap = importGlobMaps.get(this.environment);
      if (!importGlobMap) return;
      const modules = [];
      for (const [id, globMatchers] of importGlobMap) {
        if (globMatchers.some((matcher) => matcher(file))) {
          const mod = this.environment.moduleGraph.getModuleById(id);
          if (mod) modules.push(mod);
        }
      }
      return modules.length > 0 ? [...oldModules, ...modules] : void 0;
    }
  };
}
const importGlobRE = /\bimport\.meta\.glob(?:<\w+>)?\s*\(/g;
const objectKeysRE = /\bObject\.keys\(\s*$/;
const objectValuesRE = /\bObject\.values\(\s*$/;
const knownOptions = {
  as: ["string"],
  eager: ["boolean"],
  import: ["string"],
  exhaustive: ["boolean"],
  query: ["object", "string"]
};
const forceDefaultAs = ["raw", "url"];
function err$1(e, pos) {
  const error = new Error(e);
  error.pos = pos;
  return error;
}
function parseGlobOptions(rawOpts, optsStartIndex, logger) {
  let opts = {};
  try {
    opts = evalValue(rawOpts);
  } catch {
    throw err$1(
      "Vite is unable to parse the glob options as the value is not static",
      optsStartIndex
    );
  }
  if (opts == null) {
    return {};
  }
  for (const key in opts) {
    if (!(key in knownOptions)) {
      throw err$1(`Unknown glob option "${key}"`, optsStartIndex);
    }
    const allowedTypes = knownOptions[key];
    const valueType = typeof opts[key];
    if (!allowedTypes.includes(valueType)) {
      throw err$1(
        `Expected glob option "${key}" to be of type ${allowedTypes.join(
          " or "
        )}, but got ${valueType}`,
        optsStartIndex
      );
    }
  }
  if (typeof opts.query === "object") {
    for (const key in opts.query) {
      const value = opts.query[key];
      if (!["string", "number", "boolean"].includes(typeof value)) {
        throw err$1(
          `Expected glob option "query.${key}" to be of type string, number, or boolean, but got ${typeof value}`,
          optsStartIndex
        );
      }
    }
    opts.query = stringifyQuery(opts.query);
  }
  if (opts.as && logger) {
    const importSuggestion = forceDefaultAs.includes(opts.as) ? `, import: 'default'` : "";
    logger.warn(
      colors$1.yellow(
        `The glob option "as" has been deprecated in favour of "query". Please update \`as: '${opts.as}'\` to \`query: '?${opts.as}'${importSuggestion}\`.`
      )
    );
  }
  if (opts.as && forceDefaultAs.includes(opts.as)) {
    if (opts.import && opts.import !== "default" && opts.import !== "*")
      throw err$1(
        `Option "import" can only be "default" or "*" when "as" is "${opts.as}", but got "${opts.import}"`,
        optsStartIndex
      );
    opts.import = opts.import || "default";
  }
  if (opts.as && opts.query)
    throw err$1(
      'Options "as" and "query" cannot be used together',
      optsStartIndex
    );
  if (opts.as) opts.query = opts.as;
  if (opts.query && opts.query[0] !== "?") opts.query = `?${opts.query}`;
  return opts;
}
async function parseImportGlob(code, importer, root, resolveId, logger) {
  let cleanCode;
  try {
    cleanCode = stripLiteral(code);
  } catch {
    return [];
  }
  const matches = Array.from(cleanCode.matchAll(importGlobRE));
  const tasks = matches.map(async (match, index) => {
    const start = match.index;
    const err2 = (msg) => {
      const e = new Error(`Invalid glob import syntax: ${msg}`);
      e.pos = start;
      return e;
    };
    const end = findCorrespondingCloseParenthesisPosition(
      cleanCode,
      start + match[0].length
    ) + 1;
    if (end <= 0) {
      throw err2("Close parenthesis not found");
    }
    const statementCode = code.slice(start, end);
    const rootAst = (await parseAstAsync(statementCode)).body[0];
    if (rootAst.type !== "ExpressionStatement") {
      throw err2(`Expect CallExpression, got ${rootAst.type}`);
    }
    const ast = rootAst.expression;
    if (ast.type !== "CallExpression") {
      throw err2(`Expect CallExpression, got ${ast.type}`);
    }
    if (ast.arguments.length < 1 || ast.arguments.length > 2)
      throw err2(`Expected 1-2 arguments, but got ${ast.arguments.length}`);
    const arg1 = ast.arguments[0];
    const arg2 = ast.arguments[1];
    const globs = [];
    const validateLiteral = (element) => {
      if (!element) return;
      if (element.type === "Literal") {
        if (typeof element.value !== "string")
          throw err2(
            `Expected glob to be a string, but got "${typeof element.value}"`
          );
        globs.push(element.value);
      } else if (element.type === "TemplateLiteral") {
        if (element.expressions.length !== 0) {
          throw err2(
            `Expected glob to be a string, but got dynamic template literal`
          );
        }
        globs.push(element.quasis[0].value.raw);
      } else {
        throw err2("Could only use literals");
      }
    };
    if (arg1.type === "ArrayExpression") {
      for (const element of arg1.elements) {
        validateLiteral(element);
      }
    } else {
      validateLiteral(arg1);
    }
    let options = {};
    if (arg2) {
      if (arg2.type !== "ObjectExpression")
        throw err2(
          `Expected the second argument to be an object literal, but got "${arg2.type}"`
        );
      options = parseGlobOptions(
        code.slice(start + arg2.start, start + arg2.end),
        start + arg2.start,
        logger
      );
    }
    const globsResolved = await Promise.all(
      globs.map((glob2) => toAbsoluteGlob(glob2, root, importer, resolveId))
    );
    const isRelative = globs.every((i) => ".!".includes(i[0]));
    const sliceCode = cleanCode.slice(0, start);
    const onlyKeys = objectKeysRE.test(sliceCode);
    let onlyValues = false;
    if (!onlyKeys) {
      onlyValues = objectValuesRE.test(sliceCode);
    }
    return {
      index,
      globs,
      globsResolved,
      isRelative,
      options,
      start,
      end,
      onlyKeys,
      onlyValues
    };
  });
  return (await Promise.all(tasks)).filter(Boolean);
}
function findCorrespondingCloseParenthesisPosition(cleanCode, openPos) {
  const closePos = cleanCode.indexOf(")", openPos);
  if (closePos < 0) return -1;
  if (!cleanCode.slice(openPos, closePos).includes("(")) return closePos;
  let remainingParenthesisCount = 0;
  const cleanCodeLen = cleanCode.length;
  for (let pos = openPos; pos < cleanCodeLen; pos++) {
    switch (cleanCode[pos]) {
      case "(": {
        remainingParenthesisCount++;
        break;
      }
      case ")": {
        remainingParenthesisCount--;
        if (remainingParenthesisCount <= 0) {
          return pos;
        }
      }
    }
  }
  return -1;
}
const importPrefix = "__vite_glob_";
const { basename, dirname, relative } = posix$1;
async function transformGlobImport(code, id, root, resolveId, restoreQueryExtension = false, logger) {
  id = slash$1(id);
  root = slash$1(root);
  const isVirtual = isVirtualModule(id);
  const dir = isVirtual ? void 0 : dirname(id);
  const matches = await parseImportGlob(
    code,
    isVirtual ? void 0 : id,
    root,
    resolveId,
    logger
  );
  const matchedFiles = /* @__PURE__ */ new Set();
  if (!matches.length) return null;
  const s = new MagicString(code);
  const staticImports = (await Promise.all(
    matches.map(
      async ({
        globsResolved,
        isRelative,
        options,
        index,
        start,
        end,
        onlyKeys,
        onlyValues
      }) => {
        const cwd = getCommonBase(globsResolved) ?? root;
        const files = (await glob(globsResolved, {
          absolute: true,
          cwd,
          dot: !!options.exhaustive,
          expandDirectories: false,
          ignore: options.exhaustive ? [] : ["**/node_modules/**"]
        })).filter((file) => file !== id).sort();
        const objectProps = [];
        const staticImports2 = [];
        const resolvePaths = (file) => {
          if (!dir) {
            if (isRelative)
              throw new Error(
                "In virtual modules, all globs must start with '/'"
              );
            const filePath2 = `/${relative(root, file)}`;
            return { filePath: filePath2, importPath: filePath2 };
          }
          let importPath = relative(dir, file);
          if (importPath[0] !== ".") importPath = `./${importPath}`;
          let filePath;
          if (isRelative) {
            filePath = importPath;
          } else {
            filePath = relative(root, file);
            if (filePath[0] !== ".") filePath = `/${filePath}`;
          }
          return { filePath, importPath };
        };
        files.forEach((file, i) => {
          const paths = resolvePaths(file);
          const filePath = paths.filePath;
          let importPath = paths.importPath;
          let importQuery = options.query ?? "";
          if (onlyKeys) {
            objectProps.push(`${JSON.stringify(filePath)}: 0`);
            return;
          }
          if (importQuery && importQuery !== "?raw") {
            const fileExtension = basename(file).split(".").slice(-1)[0];
            if (fileExtension && restoreQueryExtension)
              importQuery = `${importQuery}&lang.${fileExtension}`;
          }
          importPath = `${importPath}${importQuery}`;
          const importKey = options.import && options.import !== "*" ? options.import : void 0;
          if (options.eager) {
            const variableName = `${importPrefix}${index}_${i}`;
            const expression = importKey ? `{ ${importKey} as ${variableName} }` : `* as ${variableName}`;
            staticImports2.push(
              `import ${expression} from ${JSON.stringify(importPath)}`
            );
            objectProps.push(
              onlyValues ? `${variableName}` : `${JSON.stringify(filePath)}: ${variableName}`
            );
          } else {
            let importStatement = `import(${JSON.stringify(importPath)})`;
            if (importKey)
              importStatement += `.then(m => m[${JSON.stringify(importKey)}])`;
            objectProps.push(
              onlyValues ? `() => ${importStatement}` : `${JSON.stringify(filePath)}: () => ${importStatement}`
            );
          }
        });
        files.forEach((i) => matchedFiles.add(i));
        const originalLineBreakCount = code.slice(start, end).match(/\n/g)?.length ?? 0;
        const lineBreaks = originalLineBreakCount > 0 ? "\n".repeat(originalLineBreakCount) : "";
        let replacement = "";
        if (onlyKeys) {
          replacement = `{${objectProps.join(",")}${lineBreaks}}`;
        } else if (onlyValues) {
          replacement = `[${objectProps.join(",")}${lineBreaks}]`;
        } else {
          replacement = `/* #__PURE__ */ Object.assign({${objectProps.join(
            ","
          )}${lineBreaks}})`;
        }
        s.overwrite(start, end, replacement);
        return staticImports2;
      }
    )
  )).flat();
  if (staticImports.length) s.prepend(`${staticImports.join(";")};`);
  return {
    s,
    matches,
    files: matchedFiles
  };
}
function globSafePath(path) {
  return escapePath(normalizePath$3(path));
}
function lastNthChar(str, n) {
  return str.charAt(str.length - 1 - n);
}
function globSafeResolvedPath(resolved, glob2) {
  let numEqual = 0;
  const maxEqual = Math.min(resolved.length, glob2.length);
  while (numEqual < maxEqual && lastNthChar(resolved, numEqual) === lastNthChar(glob2, numEqual)) {
    numEqual += 1;
  }
  const staticPartEnd = resolved.length - numEqual;
  const staticPart = resolved.slice(0, staticPartEnd);
  const dynamicPart = resolved.slice(staticPartEnd);
  return globSafePath(staticPart) + dynamicPart;
}
async function toAbsoluteGlob(glob2, root, importer, resolveId) {
  let pre = "";
  if (glob2[0] === "!") {
    pre = "!";
    glob2 = glob2.slice(1);
  }
  root = globSafePath(root);
  const dir = importer ? globSafePath(dirname(importer)) : root;
  if (glob2[0] === "/") return pre + posix$1.join(root, glob2.slice(1));
  if (glob2.startsWith("./")) return pre + posix$1.join(dir, glob2.slice(2));
  if (glob2.startsWith("../")) return pre + posix$1.join(dir, glob2);
  if (glob2.startsWith("**")) return pre + glob2;
  const isSubImportsPattern = glob2[0] === "#" && glob2.includes("*");
  const resolved = normalizePath$3(
    await resolveId(glob2, importer, {
      custom: { "vite:import-glob": { isSubImportsPattern } }
    }) || glob2
  );
  if (isAbsolute$1(resolved)) {
    return pre + globSafeResolvedPath(resolved, glob2);
  }
  throw new Error(
    `Invalid glob: "${glob2}" (resolved: "${resolved}"). It must start with '/' or './'`
  );
}
function getCommonBase(globsResolved) {
  const bases = globsResolved.filter((g) => g[0] !== "!").map((glob2) => {
    let { base } = picomatch$5.scan(glob2);
    if (posix$1.basename(base).includes(".")) base = posix$1.dirname(base);
    return base;
  });
  if (!bases.length) return null;
  let commonAncestor = "";
  const dirS = bases[0].split("/");
  for (let i = 0; i < dirS.length; i++) {
    const candidate = dirS.slice(0, i + 1).join("/");
    if (bases.every((base) => base.startsWith(candidate)))
      commonAncestor = candidate;
    else break;
  }
  if (!commonAncestor) commonAncestor = "/";
  return commonAncestor;
}
function isVirtualModule(id) {
  return id.startsWith("virtual:") || id[0] === "\0" || !id.includes("/");
}

class ScanEnvironment extends BaseEnvironment {
  mode = "scan";
  get pluginContainer() {
    if (!this._pluginContainer)
      throw new Error(
        `${this.name} environment.pluginContainer called before initialized`
      );
    return this._pluginContainer;
  }
  /**
   * @internal
   */
  _pluginContainer;
  async init() {
    if (this._initiated) {
      return;
    }
    this._initiated = true;
    this._plugins = await resolveEnvironmentPlugins(this);
    this._pluginContainer = await createEnvironmentPluginContainer(
      this,
      this.plugins
    );
    await this._pluginContainer.buildStart();
  }
}
function devToScanEnvironment(environment) {
  return {
    mode: "scan",
    get name() {
      return environment.name;
    },
    getTopLevelConfig() {
      return environment.getTopLevelConfig();
    },
    /**
     * @deprecated use environment.config instead
     **/
    get options() {
      return environment.options;
    },
    get config() {
      return environment.config;
    },
    get logger() {
      return environment.logger;
    },
    get pluginContainer() {
      return environment.pluginContainer;
    },
    get plugins() {
      return environment.plugins;
    }
  };
}
const debug$d = createDebugger("vite:deps");
const htmlTypesRE = /\.(html|vue|svelte|astro|imba)$/;
const importsRE = /(?<!\/\/.*)(?<=^|;|\*\/)\s*import(?!\s+type)(?:[\w*{}\n\r\t, ]+from)?\s*("[^"]+"|'[^']+')\s*(?=$|;|\/\/|\/\*)/gm;
function scanImports(environment) {
  const start = performance.now();
  const deps = {};
  const missing = {};
  let entries;
  const { config } = environment;
  const scanContext = { cancelled: false };
  const esbuildContext = computeEntries(
    environment
  ).then((computedEntries) => {
    entries = computedEntries;
    if (!entries.length) {
      if (!config.optimizeDeps.entries && !config.optimizeDeps.include) {
        environment.logger.warn(
          colors$1.yellow(
            "(!) Could not auto-determine entry point from rollupOptions or html files and there are no explicit optimizeDeps.include patterns. Skipping dependency pre-bundling."
          )
        );
      }
      return;
    }
    if (scanContext.cancelled) return;
    debug$d?.(
      `Crawling dependencies using entries: ${entries.map((entry) => `
  ${colors$1.dim(entry)}`).join("")}`
    );
    return prepareEsbuildScanner(
      environment,
      entries,
      deps,
      missing,
      scanContext
    );
  });
  const result = esbuildContext.then((context) => {
    function disposeContext() {
      return context?.dispose().catch((e) => {
        environment.logger.error("Failed to dispose esbuild context", {
          error: e
        });
      });
    }
    if (!context || scanContext?.cancelled) {
      disposeContext();
      return { deps: {}, missing: {} };
    }
    return context.rebuild().then(() => {
      return {
        // Ensure a fixed order so hashes are stable and improve logs
        deps: orderedDependencies(deps),
        missing
      };
    }).finally(() => {
      return disposeContext();
    });
  }).catch(async (e) => {
    if (e.errors && e.message.includes("The build was canceled")) {
      return { deps: {}, missing: {} };
    }
    const prependMessage = colors$1.red(`  Failed to scan for dependencies from entries:
  ${entries.join("\n")}

  `);
    if (e.errors) {
      const msgs = await formatMessages(e.errors, {
        kind: "error",
        color: true
      });
      e.message = prependMessage + msgs.join("\n");
    } else {
      e.message = prependMessage + e.message;
    }
    throw e;
  }).finally(() => {
    if (debug$d) {
      const duration = (performance.now() - start).toFixed(2);
      const depsStr = Object.keys(orderedDependencies(deps)).sort().map((id) => `
  ${colors$1.cyan(id)} -> ${colors$1.dim(deps[id])}`).join("") || colors$1.dim("no dependencies found");
      debug$d(`Scan completed in ${duration}ms: ${depsStr}`);
    }
  });
  return {
    cancel: async () => {
      scanContext.cancelled = true;
      return esbuildContext.then((context) => context?.cancel());
    },
    result
  };
}
async function computeEntries(environment) {
  let entries = [];
  const explicitEntryPatterns = environment.config.optimizeDeps.entries;
  const buildInput = environment.config.build.rollupOptions?.input;
  if (explicitEntryPatterns) {
    entries = await globEntries(explicitEntryPatterns, environment);
  } else if (buildInput) {
    const resolvePath = async (p) => {
      const id = (await environment.pluginContainer.resolveId(p, void 0, {
        scan: true
      }))?.id;
      if (id === void 0) {
        throw new Error(
          `failed to resolve rollupOptions.input value: ${JSON.stringify(p)}.`
        );
      }
      return id;
    };
    if (typeof buildInput === "string") {
      entries = [await resolvePath(buildInput)];
    } else if (Array.isArray(buildInput)) {
      entries = await Promise.all(buildInput.map(resolvePath));
    } else if (isObject$2(buildInput)) {
      entries = await Promise.all(Object.values(buildInput).map(resolvePath));
    } else {
      throw new Error("invalid rollupOptions.input value.");
    }
  } else {
    entries = await globEntries("**/*.html", environment);
  }
  entries = entries.filter(
    (entry) => isScannable(entry, environment.config.optimizeDeps.extensions) && fs__default.existsSync(entry)
  );
  return entries;
}
async function prepareEsbuildScanner(environment, entries, deps, missing, scanContext) {
  if (scanContext?.cancelled) return;
  const plugin = esbuildScanPlugin(environment, deps, missing, entries);
  const { plugins = [], ...esbuildOptions } = environment.config.optimizeDeps.esbuildOptions ?? {};
  let tsconfigRaw = esbuildOptions.tsconfigRaw;
  if (!tsconfigRaw && !esbuildOptions.tsconfig) {
    const { tsconfig } = await loadTsconfigJsonForFile(
      path$d.join(environment.config.root, "_dummy.js")
    );
    if (tsconfig.compilerOptions?.experimentalDecorators) {
      tsconfigRaw = { compilerOptions: { experimentalDecorators: true } };
    }
  }
  return await esbuild.context({
    absWorkingDir: process.cwd(),
    write: false,
    stdin: {
      contents: entries.map((e) => `import ${JSON.stringify(e)}`).join("\n"),
      loader: "js"
    },
    bundle: true,
    format: "esm",
    logLevel: "silent",
    plugins: [...plugins, plugin],
    ...esbuildOptions,
    tsconfigRaw
  });
}
function orderedDependencies(deps) {
  const depsList = Object.entries(deps);
  depsList.sort((a, b) => a[0].localeCompare(b[0]));
  return Object.fromEntries(depsList);
}
function globEntries(pattern, environment) {
  const resolvedPatterns = arraify(pattern);
  if (resolvedPatterns.every((str) => !isDynamicPattern(str))) {
    return resolvedPatterns.map(
      (p) => normalizePath$3(path$d.resolve(environment.config.root, p))
    );
  }
  return glob(pattern, {
    absolute: true,
    cwd: environment.config.root,
    ignore: [
      "**/node_modules/**",
      `**/${environment.config.build.outDir}/**`,
      // if there aren't explicit entries, also ignore other common folders
      ...environment.config.optimizeDeps.entries ? [] : [`**/__tests__/**`, `**/coverage/**`]
    ]
  });
}
const scriptRE = /(<script(?:\s+[a-z_:][-\w:]*(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^"'<>=\s]+))?)*\s*>)(.*?)<\/script>/gis;
const commentRE$1 = /<!--.*?-->/gs;
const srcRE = /\bsrc\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const typeRE = /\btype\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const langRE = /\blang\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const svelteScriptModuleRE = /\bcontext\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const svelteModuleRE = /\smodule\b/i;
function esbuildScanPlugin(environment, depImports, missing, entries) {
  const seen = /* @__PURE__ */ new Map();
  async function resolveId(id, importer, options) {
    return environment.pluginContainer.resolveId(
      id,
      importer && normalizePath$3(importer),
      {
        ...options,
        scan: true
      }
    );
  }
  const resolve = async (id, importer, options) => {
    const key = id + (importer && path$d.dirname(importer));
    if (seen.has(key)) {
      return seen.get(key);
    }
    const resolved = await resolveId(id, importer, options);
    const res = resolved?.id;
    seen.set(key, res);
    return res;
  };
  const optimizeDepsOptions = environment.config.optimizeDeps;
  const include = optimizeDepsOptions.include;
  const exclude = [
    ...optimizeDepsOptions.exclude ?? [],
    "@vite/client",
    "@vite/env"
  ];
  const isUnlessEntry = (path2) => !entries.includes(path2);
  const externalUnlessEntry = ({ path: path2 }) => ({
    path: path2,
    external: isUnlessEntry(path2)
  });
  const doTransformGlobImport = async (contents, id, loader) => {
    let transpiledContents;
    if (loader !== "js") {
      transpiledContents = (await transform$1(contents, { loader })).code;
    } else {
      transpiledContents = contents;
    }
    const result = await transformGlobImport(
      transpiledContents,
      id,
      environment.config.root,
      resolve
    );
    return result?.s.toString() || transpiledContents;
  };
  return {
    name: "vite:dep-scan",
    setup(build) {
      const scripts = {};
      build.onResolve({ filter: externalRE }, ({ path: path2 }) => ({
        path: path2,
        external: true
      }));
      build.onResolve({ filter: dataUrlRE }, ({ path: path2 }) => ({
        path: path2,
        external: true
      }));
      build.onResolve({ filter: virtualModuleRE }, ({ path: path2 }) => {
        return {
          // strip prefix to get valid filesystem path so esbuild can resolve imports in the file
          path: path2.replace(virtualModulePrefix, ""),
          namespace: "script"
        };
      });
      build.onLoad({ filter: /.*/, namespace: "script" }, ({ path: path2 }) => {
        return scripts[path2];
      });
      build.onResolve({ filter: htmlTypesRE }, async ({ path: path2, importer }) => {
        const resolved = await resolve(path2, importer);
        if (!resolved) return;
        if (isInNodeModules$1(resolved) && isOptimizable(resolved, optimizeDepsOptions))
          return;
        return {
          path: resolved,
          namespace: "html"
        };
      });
      const htmlTypeOnLoadCallback = async ({ path: p }) => {
        let raw = await fsp.readFile(p, "utf-8");
        raw = raw.replace(commentRE$1, "<!---->");
        const isHtml = p.endsWith(".html");
        let js = "";
        let scriptId = 0;
        const matches = raw.matchAll(scriptRE);
        for (const [, openTag, content] of matches) {
          const typeMatch = typeRE.exec(openTag);
          const type = typeMatch && (typeMatch[1] || typeMatch[2] || typeMatch[3]);
          const langMatch = langRE.exec(openTag);
          const lang = langMatch && (langMatch[1] || langMatch[2] || langMatch[3]);
          if (isHtml && type !== "module") {
            continue;
          }
          if (type && !(type.includes("javascript") || type.includes("ecmascript") || type === "module")) {
            continue;
          }
          let loader = "js";
          if (lang === "ts" || lang === "tsx" || lang === "jsx") {
            loader = lang;
          } else if (p.endsWith(".astro")) {
            loader = "ts";
          }
          const srcMatch = srcRE.exec(openTag);
          if (srcMatch) {
            const src = srcMatch[1] || srcMatch[2] || srcMatch[3];
            js += `import ${JSON.stringify(src)}
`;
          } else if (content.trim()) {
            const contents = content + (loader.startsWith("ts") ? extractImportPaths(content) : "");
            const key = `${p}?id=${scriptId++}`;
            if (contents.includes("import.meta.glob")) {
              scripts[key] = {
                loader: "js",
                // since it is transpiled
                contents: await doTransformGlobImport(contents, p, loader),
                resolveDir: normalizePath$3(path$d.dirname(p)),
                pluginData: {
                  htmlType: { loader }
                }
              };
            } else {
              scripts[key] = {
                loader,
                contents,
                resolveDir: normalizePath$3(path$d.dirname(p)),
                pluginData: {
                  htmlType: { loader }
                }
              };
            }
            const virtualModulePath = JSON.stringify(virtualModulePrefix + key);
            let addedImport = false;
            if (p.endsWith(".svelte")) {
              let isModule = svelteModuleRE.test(openTag);
              if (!isModule) {
                const contextMatch = svelteScriptModuleRE.exec(openTag);
                const context = contextMatch && (contextMatch[1] || contextMatch[2] || contextMatch[3]);
                isModule = context === "module";
              }
              if (!isModule) {
                addedImport = true;
                js += `import ${virtualModulePath}
`;
              }
            }
            if (!addedImport) {
              js += `export * from ${virtualModulePath}
`;
            }
          }
        }
        if (!p.endsWith(".vue") || !js.includes("export default")) {
          js += "\nexport default {}";
        }
        return {
          loader: "js",
          contents: js
        };
      };
      build.onLoad(
        { filter: htmlTypesRE, namespace: "html" },
        htmlTypeOnLoadCallback
      );
      build.onLoad(
        { filter: htmlTypesRE, namespace: "file" },
        htmlTypeOnLoadCallback
      );
      build.onResolve(
        {
          // avoid matching windows volume
          filter: /^[\w@][^:]/
        },
        async ({ path: id, importer, pluginData }) => {
          if (moduleListContains(exclude, id)) {
            return externalUnlessEntry({ path: id });
          }
          if (depImports[id]) {
            return externalUnlessEntry({ path: id });
          }
          const resolved = await resolve(id, importer, {
            custom: {
              depScan: { loader: pluginData?.htmlType?.loader }
            }
          });
          if (resolved) {
            if (shouldExternalizeDep(resolved, id)) {
              return externalUnlessEntry({ path: id });
            }
      