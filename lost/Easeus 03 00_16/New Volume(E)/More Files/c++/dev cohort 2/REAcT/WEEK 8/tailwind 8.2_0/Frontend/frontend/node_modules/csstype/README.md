{"version":3,"names":["_renamer","require","_index","_binding","_globals","_t","t","_cache","_visitors","NOT_LOCAL_BINDING","assignmentExpression","callExpression","cloneNode","getBindingIdentifiers","identifier","isArrayExpression","isBinary","isCallExpression","isClass","isClassBody","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isFunctionDeclaration","isIdentifier","isImportDeclaration","isLiteral","isMemberExpression","isMethod","isModuleSpecifier","isNullLiteral","isObjectExpression","isProperty","isPureish","isRegExpLiteral","isSuper","isTaggedTemplateExpression","isTemplateLiteral","isThisExpression","isUnaryExpression","isVariableDeclaration","expressionStatement","matchesPattern","memberExpression","numericLiteral","toIdentifier","variableDeclaration","variableDeclarator","isRecordExpression","isTupleExpression","isObjectProperty","isTopicReference","isMetaProperty","isPrivateName","isExportDeclaration","buildUndefinedNode","sequenceExpression","gatherNodeParts","node","parts","type","_node$specifiers","source","specifiers","length","e","declaration","local","push","value","object","property","name","callee","properties","argument","key","left","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","ForStatement","path","declar","get","isVar","scope","parentScope","getFunctionParent","getProgramParent","registerBinding","Declaration","isBlockScoped","parent","registerDeclaration","ImportDeclaration","getBlockParent","ReferencedIdentifier","state","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","binding","getBinding","reference","decl","declarations","Object","keys","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","BlockScoped","bindings","CatchClause","Function","params","param","isFunctionExpression","ClassExpression","TSTypeAnnotation","skip","uid","Scope","constructor","block","inited","labels","globals","uids","data","crawling","cached","scopeCache","set","Map","_parent","_path","shouldSkip","listKey","parentPath","isScope","generateDeclaredUidIdentifier","generateUidIdentifier","generateUid","replace","i","hasLabel","hasBinding","hasGlobal","hasReference","program","generateUidBasedOnNode","defaultName","join","slice","generateUidIdentifierBasedOnNode","isStatic","constant","maybeGenerateMemoised","dontPush","checkBlockScopedCollisions","kind","duplicate","hub","buildError","TypeError","rename","oldName","newName","renamer","Renamer","arguments","dump","sep","repeat","console","log","violations","getLabel","registerLabel","label","isLabeledStatement","declare","isTypeDeclaration","importKind","specifier","isTypeSpecifier","isImportSpecifier","registerConstantViolation","ids","getAssignmentIdentifiers","_this$getBinding","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","Binding","addGlobal","hasUid","isPure","constantsOnly","_node$decorators","superClass","decorators","body","method","right","elem","elements","prop","_node$decorators2","computed","_node$decorators3","static","expressions","tag","noGlobals","quasi","isStringLiteral","setData","val","getData","removeData","init","crawl","create","programParent","isExplodedVisitor","visit","enter","call","typeVisitors","traverse","ref","opts","getPatternParent","isBlockStatement","isProgram","isSwitchStatement","unique","isFunction","pushContainer","isLoop","isCatchClause","ensureBlock","blockHoist","_blockHoist","dataKey","declarPath","unshiftContainer","declarator","len","Error","isFunctionParent","isBlockParent","getAllBindings","bindingIdentifierEquals","getBindingIdentifier","previousPath","_previousPath","isArrowFunctionExpression","_this$getBinding2","getOwnBindingIdentifier","hasOwnBinding","noUids","includes","contextVariables","parentHasBinding","_this$parent","moveBindingTo","info","removeOwnBinding","removeBinding","_this$getBinding3","hoistVariables","emit","seen","Set","isVariableDeclarator","has","add","firstId","_firstId","isFor","replaceWith","remove","expr","isForStatement","exports","default","builtin","prototype","_renameFromMap","map","_generateUid","toArray","arrayLikeIsIterable","isGenericType","helperName","args","unshift","addHelper","getAllBindingsOfKind","kinds","defineProperties","parentBlock","configurable","enumerable"],"sources":["../../src/scope/index.ts"],"sourcesContent":["import Renamer from \"./lib/renamer.ts\";\nimport type NodePath from \"../path/index.ts\";\nimport traverse from \"../index.ts\";\nimport Binding from \"./binding.ts\";\nimport type { BindingKind } from \"./binding.ts\";\nimport globals from \"globals\";\nimport {\n  NOT_LOCAL_BINDING,\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isCallExpression,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMemberExpression,\n  isMethod,\n  isModuleSpecifier,\n  isNullLiteral,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isRegExpLiteral,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  expressionStatement,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  variableDeclaration,\n  variableDeclarator,\n  isRecordExpression,\n  isTupleExpression,\n  isObjectProperty,\n  isTopicReference,\n  isMetaProperty,\n  isPrivateName,\n  isExportDeclaration,\n  buildUndefinedNode,\n  sequenceExpression,\n} from \"@babel/types\";\nimport * as t from \"@babel/types\";\nimport { scope as scopeCache } from \"../cache.ts\";\nimport type { Visitor } from \"../types.ts\";\nimport { isExplodedVisitor } from \"../visitors.ts\";\n\ntype NodePart = string | number | boolean;\n// Recursively gathers the identifying names of a node.\nfunction gatherNodeParts(node: t.Node, parts: NodePart[]) {\n  switch (node?.type) {\n    default:\n      if (isImportDeclaration(node) || isExportDeclaration(node)) {\n        if (\n          (isExportAllDeclaration(node) ||\n            isExportNamedDeclaration(node) ||\n            isImportDeclaration(node)) &&\n          node.source\n        ) {\n          gatherNodeParts(node.source, parts);\n        } else if (\n          (isExportNamedDeclaration(node) || isImportDeclaration(node)) &&\n          node.specifiers?.length\n        ) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if (\n          (isExportDefaultDeclaration(node) ||\n            isExportNamedDeclaration(node)) &&\n          node.declaration\n        ) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        // todo(flow->ts): should condition instead be:\n        //    ```\n        //    t.isExportSpecifier(node) ||\n        //    t.isImportDefaultSpecifier(node) ||\n        //    t.isImportNamespaceSpecifier(node) ||\n        //    t.isImportSpecifier(node)\n        //    ```\n        //    allowing only nodes with `.local`?\n        // @ts-expect-error todo(flow->ts)\n        gatherNodeParts(node.local, parts);\n      } else if (\n        isLiteral(node) &&\n        !isNullLiteral(node) &&\n        !isRegExpLiteral(node) &&\n        !isTemplateLiteral(node)\n      ) {\n        parts.push(node.value);\n      }\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      gatherNodeParts(node.name, parts);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\n//\ninterface CollectVisitorState {\n  assignments: 