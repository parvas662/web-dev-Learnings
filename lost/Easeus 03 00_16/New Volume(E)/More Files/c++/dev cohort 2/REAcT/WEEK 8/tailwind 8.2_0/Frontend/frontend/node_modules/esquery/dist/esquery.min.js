ndefined, opts?: object | null): node is TSIndexSignature;
export function assertTSIndexSignature(node: object | null | undefined, opts?: object | null): void;
export function isTSIndexedAccessType(node: object | null | undefined, opts?: object | null): node is TSIndexedAccessType;
export function assertTSIndexedAccessType(node: object | null | undefined, opts?: object | null): void;
export function isTSInferType(node: object | null | undefined, opts?: object | null): node is TSInferType;
export function assertTSInferType(node: object | null | undefined, opts?: object | null): void;
export function isTSInstantiationExpression(node: object | null | undefined, opts?: object | null): node is TSInstantiationExpression;
export function assertTSInstantiationExpression(node: object | null | undefined, opts?: object | null): void;
export function isTSInterfaceBody(node: object | null | undefined, opts?: object | null): node is TSInterfaceBody;
export function assertTSInterfaceBody(node: object | null | undefined, opts?: object | null): void;
export function isTSInterfaceDeclaration(node: object | null | undefined, opts?: object | null): node is TSInterfaceDeclaration;
export function assertTSInterfaceDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isTSIntersectionType(node: object | null | undefined, opts?: object | null): node is TSIntersectionType;
export function assertTSIntersectionType(node: object | null | undefined, opts?: object | null): void;
export function isTSIntrinsicKeyword(node: object | null | undefined, opts?: object | null): node is TSIntrinsicKeyword;
export function assertTSIntrinsicKeyword(node: object | null | undefined, opts?: object | null): void;
export function isTSLiteralType(node: object | null | undefined, opts?: object | null): node is TSLiteralType;
export function assertTSLiteralType(node: object | null | undefined, opts?: object | null): void;
export function isTSMappedType(node: object | null | undefined, opts?: object | null): node is TSMappedType;
export function assertTSMappedType(node: object | null | undefined, opts?: object | null): void;
export function isTSMethodSignature(node: object | null | undefined, opts?: object | null): node is TSMethodSignature;
export function assertTSMethodSignature(node: object | null | undefined, opts?: object | null): void;
export function isTSModuleBlock(node: object | null | undefined, opts?: object | null): node is TSModuleBlock;
export function assertTSModuleBlock(node: object | null | undefined, opts?: object | null): void;
export function isTSModuleDeclaration(node: object | null | undefined, opts?: object | null): node is TSModuleDeclaration;
export function assertTSModuleDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isTSNamedTupleMember(node: object | null | undefined, opts?: object | null): node is TSNamedTupleMember;
export function assertTSNamedTupleMember(node: object | null | undefined, opts?: object | null): void;
export function isTSNamespaceExportDeclaration(node: object | null | undefined, opts?: object | null): node is TSNamespaceExportDeclaration;
export function assertTSNamespaceExportDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isTSNeverKeyword(node: object | null | undefined, opts?: object | null): node is TSNeverKeyword;
export function assertTSNeverKeyword(node: object | null | undefined, opts?: object | null): void;
export function isTSNonNullExpression(node: object | null | undefined, opts?: object | null): node is TSNonNullExpression;
export function assertTSNonNullExpression(node: object | null | undefined, opts?: object | null): void;
export function isTSNullKeyword(node: object | null | undefined, opts?: object | null): node is TSNullKeyword;
export function assertTSNullKeyword(node: object | null | undefined, opts?: object | null): void;
export function isTSNumberKeyword(node: object | null | undefined, opts?: object | null): node is TSNumberKeyword;
export function assertTSNumberKeyword(node: object | null | undefined, opts?: object | null): void;
export function isTSObjectKeyword(node: object | null | undefined, opts?: object | null): node is TSObjectKeyword;
export function assertTSObjectKeyword(node: object | null | undefined, opts?: object | null): void;
export function isTSOptionalType(node: object | null | undefined, opts?: object | null): node is TSOptionalType;
export function assertTSOptionalType(node: object | null | undefined, opts?: object | null): void;
export function isTSParameterProperty(node: object | null | undefined, opts?: object | null): node is TSParameterProperty;
export function assertTSParameterProperty(node: object | null | undefined, opts?: object | null): void;
export function isTSParenthesizedType(node: object | null | undefined, opts?: object | null): node is TSParenthesizedType;
export function assertTSParenthesizedType(node: object | null | undefined, opts?: object | null): void;
export function isTSPropertySignature(node: object | null | undefined, opts?: object | null): node is TSPropertySignature;
export function assertTSPropertySignature(node: object | null | undefined, opts?: object | null): void;
export function isTSQualifiedName(node: object | null | undefined, opts?: object | null): node is TSQualifiedName;
export function assertTSQualifiedName(node: object | null | undefined, opts?: object | null): void;
export function isTSRestType(node: object | null | undefined, opts?: object | null): node is TSRestType;
export function assertTSRestType(node: object | null | undefined, opts?: object | null): void;
export function isTSSatisfiesExpression(node: object | null | undefined, opts?: object | null): node is TSSatisfiesExpression;
export function assertTSSatisfiesExpression(node: object | null | undefined, opts?: object | null): void;
export function isTSStringKeyword(node: object | null | undefined, opts?: object | null): node is TSStringKeyword;
export function assertTSStringKeyword(node: object | null | undefined, opts?: object | null): void;
export function isTSSymbolKeyword(node: object | null | undefined, opts?: object | null): node is TSSymbolKeyword;
export function assertTSSymbolKeyword(node: object | null | undefined, opts?: object | null): void;
export function isTSThisType(node: object | null | undefined, opts?: object | null): node is TSThisType;
export function assertTSThisType(node: object | null | undefined, opts?: object | null): void;
export function isTSTupleType(node: object | null | undefined, opts?: object | null): node is TSTupleType;
export function assertTSTupleType(node: object | null | undefined, opts?: object | null): void;
export function isTSType(node: object | null | undefined, opts?: object | null): node is TSType;
export function assertTSType(node: object | null | undefined, opts?: object | null): void;
export function isTSTypeAliasDeclaration(node: object | null | undefined, opts?: object | null): node is TSTypeAliasDeclaration;
export function assertTSTypeAliasDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isTSTypeAnnotation(node: object | null | undefined, opts?: object | null): node is TSTypeAnnotation;
export function assertTSTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isTSTypeAssertion(node: object | null | undefined, opts?: object | null): node is TSTypeAssertion;
export function assertTSTypeAssertion(node: object | null | undefined, opts?: object | null): void;
export function isTSTypeElement(node: object | null | undefined, opts?: object | null): node is TSTypeElement;
export function assertTSTypeElement(node: object | null | undefined, opts?: object | null): void;
export function isTSTypeLiteral(node: object | null | undefined, opts?: object | null): node is TSTypeLiteral;
export function assertTSTypeLiteral(node: object | null | undefined, opts?: object | null): void;
export function isTSTypeOperator(node: object | null | undefined, opts?: object | null): node is TSTypeOperator;
export function assertTSTypeOperator(node: object | null | undefined, opts?: object | null): void;
export function isTSTypeParameter(node: object | null | undefined, opts?: object | null): node is TSTypeParameter;
export function assertTSTypeParameter(node: object | null | undefined, opts?: object | null): void;
export function isTSTypeParameterDeclaration(node: object | null | undefined, opts?: object | null): node is TSTypeParameterDeclaration;
export function assertTSTypeParameterDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isTSTypeParameterInstantiation(node: object | null | undefined, opts?: object | null): node is TSTypeParameterInstantiation;
export function assertTSTypeParameterInstantiation(node: object | null | undefined, opts?: object | null): void;
export function isTSTypePredicate(node: object | null | undefined, opts?: object | null): node is TSTypePredicate;
export function assertTSTypePredicate(node: object | null | undefined, opts?: object | null): void;
export function isTSTypeQuery(node: object | null | undefined, opts?: object | null): node is TSTypeQuery;
export function assertTSTypeQuery(node: object | null | undefined, opts?: object | null): void;
export function isTSTypeReference(node: object | null | undefined, opts?: object | null): node is TSTypeReference;
export function assertTSTypeReference(node: object | null | undefined, opts?: object | null): void;
export function isTSUndefinedKeyword(node: object | null | undefined, opts?: object | null): node is TSUndefinedKeyword;
export function assertTSUndefinedKeyword(node: object | null | undefined, opts?: object | null): void;
export function isTSUnionType(node: object | null | undefined, opts?: object | null): node is TSUnionType;
export function assertTSUnionType(node: object | null | undefined, opts?: object | null): void;
export function isTSUnknownKeyword(node: object | null | undefined, opts?: object | null): node is TSUnknownKeyword;
export function assertTSUnknownKeyword(node: object | null | undefined, opts?: object | null): void;
export function isTSVoidKeyword(node: object | null | undefined, opts?: object | null): node is TSVoidKeyword;
export function assertTSVoidKeyword(node: object | null | undefined, opts?: object | null): void;
export function isTaggedTemplateExpression(node: object | null | undefined, opts?: object | null): node is TaggedTemplateExpression;
export function assertTaggedTemplateExpression(node: object | null | undefined, opts?: object | null): void;
export function isTemplateElement(node: object | null | undefined, opts?: object | null): node is TemplateElement;
export function assertTemplateElement(node: object | null | undefined, opts?: object | null): void;
export function isTemplateLiteral(node: object | null | undefined, opts?: object | null): node is TemplateLiteral;
export function assertTemplateLiteral(node: object | null | undefined, opts?: object | null): void;
export function isTerminatorless(node: object | null | undefined, opts?: object | null): node is Terminatorless;
export function assertTerminatorless(node: object | null | undefined, opts?: object | null): void;
export function isThisExpression(node: object | null | undefined, opts?: object | null): node is ThisExpression;
export function assertThisExpression(node: object | null | undefined, opts?: object | null): void;
export function isThisTypeAnnotation(node: object | null | undefined, opts?: object | null): node is ThisTypeAnnotation;
export function assertThisTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isThrowStatement(node: object | null | undefined, opts?: object | null): node is ThrowStatement;
export function assertThrowStatement(node: object | null | undefined, opts?: object | null): void;
export function isTopicReference(node: object | null | undefined, opts?: object | null): node is TopicReference;
export function assertTopicReference(node: object | null | undefined, opts?: object | null): void;
export function isTryStatement(node: object | null | undefined, opts?: object | null): node is TryStatement;
export function assertTryStatement(node: object | null | undefined, opts?: object | null): void;
export function isTupleExpression(node: object | null | undefined, opts?: object | null): node is TupleExpression;
export function assertTupleExpression(node: object | null | undefined, opts?: object | null): void;
export function isTupleTypeAnnotation(node: object | null | undefined, opts?: object | null): node is TupleTypeAnnotation;
export function assertTupleTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isTypeAlias(node: object | null | undefined, opts?: object | null): node is TypeAlias;
export function assertTypeAlias(node: object | null | undefined, opts?: object | null): void;
export function isTypeAnnotation(node: object | null | undefined, opts?: object | null): node is TypeAnnotation;
export function assertTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isTypeCastExpression(node: object | null | undefined, opts?: object | null): node is TypeCastExpression;
export function assertTypeCastExpression(node: object | null | undefined, opts?: object | null): void;
export function isTypeParameter(node: object | null | undefined, opts?: object | null): node is TypeParameter;
export function assertTypeParameter(node: object | null | undefined, opts?: object | null): void;
export function isTypeParameterDeclaration(node: object | null | undefined, opts?: object | null): node is TypeParameterDeclaration;
export function assertTypeParameterDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isTypeParameterInstantiation(node: object | null | undefined, opts?: object | null): node is TypeParameterInstantiation;
export function assertTypeParameterInstantiation(node: object | null | undefined, opts?: object | null): void;
export function isTypeScript(node: object | null | undefined, opts?: object | null): node is TypeScript;
export function assertTypeScript(node: object | null | undefined, opts?: object | null): void;
export function isTypeofTypeAnnotation(node: object | null | undefined, opts?: object | null): node is TypeofTypeAnnotation;
export function assertTypeofTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isUnaryExpression(node: object | null | undefined, opts?: object | null): node is UnaryExpression;
export function assertUnaryExpression(node: object | null | undefined, opts?: object | null): void;
export function isUnaryLike(node: object | null | undefined, opts?: object | null): node is UnaryLike;
export function assertUnaryLike(node: object | null | undefined, opts?: object | null): void;
export function isUnionTypeAnnotation(node: object | null | undefined, opts?: object | null): node is UnionTypeAnnotation;
export function assertUnionTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isUpdateExpression(node: object | null | undefined, opts?: object | null): node is UpdateExpression;
export function assertUpdateExpression(node: object | null | undefined, opts?: object | null): void;
export function isUserWhitespacable(node: object | null | undefined, opts?: object | null): node is UserWhitespacable;
export function assertUserWhitespacable(node: object | null | undefined, opts?: object | null): void;
export function isV8IntrinsicIdentifier(node: object | null | undefined, opts?: object | null): node is V8IntrinsicIdentifier;
export function assertV8IntrinsicIdentifier(node: object | null | undefined, opts?: object | null): void;
export function isVariableDeclaration(node: object | null | undefined, opts?: object | null): node is VariableDeclaration;
export function assertVariableDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isVariableDeclarator(node: object | null | undefined, opts?: object | null): node is VariableDeclarator;
export function assertVariableDeclarator(node: object | null | undefined, opts?: object | null): void;
export function isVariance(node: object | null | undefined, opts?: object | null): node is Variance;
export function assertVariance(node: object | null | undefined, opts?: object | null): void;
export function isVoidTypeAnnotation(node: object | null | undefined, opts?: object | null): node is VoidTypeAnnotation;
export function assertVoidTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isWhile(node: object | null | undefined, opts?: object | null): node is While;
export function assertWhile(node: object | null | undefined, opts?: object | null): void;
export function isWhileStatement(node: object | null | undefined, opts?: object | null): node is WhileStatement;
export function assertWhileStatement(node: object | null | undefined, opts?: object | null): void;
export function isWithStatement(node: object | null | undefined, opts?: object | null): node is WithStatement;
export function assertWithStatement(node: object | null | undefined, opts?: object | null): void;
export function isYieldExpression(node: object | null | undefined, opts?: object | null): node is YieldExpression;
export function assertYieldExpression(node: object | null | undefined, opts?: object | null): void;
export function assertNode(obj: any): void
export function createTypeAnnotationBasedOnTypeof(type: 'string' | 'number' | 'undefined' | 'boolean' | 'function' | 'object' | 'symbol'): StringTypeAnnotation | VoidTypeAnnotation | NumberTypeAnnotation | BooleanTypeAnnotation | GenericTypeAnnotation
export function createUnionTypeAnnotation<T extends FlowType>(types: [T]): T
export function createFlowUnionType<T extends FlowType>(types: [T]): T
export function createUnionTypeAnnotation(types: ReadonlyArray<FlowType>): UnionTypeAnnotation
export function createFlowUnionType(types: ReadonlyArray<FlowType>): UnionTypeAnnotation
export function buildChildren(node: { children: ReadonlyArray<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment | JSXEmptyExpression> }): JSXElement['children']
export function clone<T extends Node>(n: T): T;
export function cloneDeep<T extends Node>(n: T): T;
export function cloneDeepWithoutLoc<T extends Node>(n: T): T;
export function cloneNode<T extends Node>(n: T, deep?: boolean, withoutLoc?: boolean): T;
export function cloneWithoutLoc<T extends Node>(n: T): T;
export type CommentTypeShorthand = 'leading' | 'inner' | 'trailing'
export function addComment<T extends Node>(node: T, type: CommentTypeShorthand, content: string, line?: boolean): T
export function addComments<T extends Node>(node: T, type: CommentTypeShorthand, comments: ReadonlyArray<Comment>): T
export function inheritInnerComments(node: Node, parent: Node): void
export function inheritLeadingComments(node: Node, parent: Node): void
export function inheritsComments<T extends Node>(node: T, parent: Node): void
export function inheritTrailingComments(node: Node, parent: Node): void
export function removeComments<T extends Node>(node: T): T
export function ensureBlock(node: Extract<Node, { body: BlockStatement | Statement | Expression }>): BlockStatement
export function ensureBlock<K extends keyof Extract<Node, { body: BlockStatement | Statement | Expression }> = 'body'>(node: Extract<Node, Record<K, BlockStatement | Statement | Expression>>, key: K): BlockStatement
export function toBindingIdentifierName(name: { toString(): string } | null | undefined): string
export function toBlock(node: Statement | Expression, parent?: Function | null): BlockStatement
export function toComputedKey<T extends Extract<Node, { computed: boolean | null }>>(node: T, key?: Expression | Identifier): Expression
export function toExpression(node: Function): FunctionExpression
export function toExpression(node: Class): ClassExpression
export function toExpression(node: ExpressionStatement | Expression | Class | Function): Expression
export function toIdentifier(name: { toString(): string } | null | undefined): string
export function toKeyAlias(node: Method | Property, key?: Node): string
export function toSequenceExpression(nodes: ReadonlyArray<Node>, scope: { push(value: { id: LVal; kind: 'var'; init?: Expression}): void; buildUndefinedNode(): Node }): SequenceExpression | undefined
export function toStatement(node: AssignmentExpression, ignore?: boolean): ExpressionStatement
export function toStatement(node: Statement | AssignmentExpression, ignore?: boolean): Statement
export function toStatement(node: Class, ignore: true): ClassDeclaration | undefined
export function toStatement(node: Class, ignore?: boolean): ClassDeclaration
export function toStatement(node: Function, ignore: true): FunctionDeclaration | undefined
export function toStatement(node: Function, ignore?: boolean): FunctionDeclaration
export function toStatement(node: Statement | Class | Function | AssignmentExpression, ignore: true): Statement | undefined
export function toStatement(node: Statement | Class | Function | AssignmentExpression, ignore?: boolean): Statement
export function valueToNode(value: undefined): Identifier
export function valueToNode(value: boolean): BooleanLiteral
export function valueToNode(value: null): NullLiteral
export function valueToNode(value: string): StringLiteral
export function valueToNode(value: number): NumericLiteral | BinaryExpression | UnaryExpression
export function valueToNode(value: RegExp): RegExpLiteral
export function valueToNode(value: ReadonlyArray<undefined | boolean | null | string | number | RegExp | object>): ArrayExpression
export function valueToNode(value: object): ObjectExpression
export function valueToNode(value: undefined | boolean | null | string | number | RegExp | object): Expression
export function removeTypeDuplicates(types: ReadonlyArray<FlowType | false | null | undefined>): FlowType[]
export function appendToMemberExpression<T extends Pick<MemberExpression, 'object' | 'property'>>(member: T, append: MemberExpression['property'], computed?: boolean): T
export function inherits<T extends Node | null | undefined>(child: T, parent: Node | null | undefined): T
export function prependToMemberExpression<T extends Pick<MemberExpression, 'object' | 'property'>>(member: T, prepend: MemberExpression['object']): T
export function removeProperties(
  n: Node,
  opts?: { preserveComments: boolean } | null
): void;
export function removePropertiesDeep<T extends Node>(
  n: T,
  opts?: { preserveComments: boolean } | null
): T;
export function getBindingIdentifiers(node: Node, duplicates: true, outerOnly?: boolean): Record<string, Array<Identifier>>
export function getBindingIdentifiers(node: Node, duplicates?: false, outerOnly?: boolean): Record<string, Identifier>
export function getBindingIdentifiers(node: Node, duplicates: boolean, outerOnly?: boolean): Record<string, Identifier | Array<Identifier>>
export function getOuterBindingIdentifiers(node: Node, duplicates: true): Record<string, Array<Identifier>>
export function getOuterBindingIdentifiers(node: Node, duplicates?: false): Record<string, Identifier>
export function getOuterBindingIdentifiers(node: Node, duplicates: boolean): Record<string, Identifier | Array<Identifier>>
export type TraversalAncestors = ReadonlyArray<{
  node: Node,
  key: string,
  index?: number,
}>;
export type TraversalHandler<T> = (
  this: undefined, node: Node, parent: TraversalAncestors, type: T
) => void;
export type TraversalHandlers<T> = {
  enter?: TraversalHandler<T>,
  exit?: TraversalHandler<T>,
};
export function traverse<T>(n: Node, h: TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;
export function traverseFast<T>(n: Node, h: TraversalHandler<T>, state?: T): void;
export function shallowEqual<T extends object>(actual: object, expected: T): actual is T
export function buildMatchMemberExpression(match: string, allowPartial?: boolean): (node: Node | null | undefined) => node is MemberExpression
export function is<T extends Node['type']>(type: T, n: Node | null | undefined, required?: undefined): n is Extract<Node, { type: T }>
export function is<T extends Node['type'], P extends Extract<Node, { type: T }>>(type: T, n: Node | null | undefined, required: Partial<P>): n is P
export function is<P extends Node>(typ'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var debugOrig = require('debug');
var fs = require('fs');
var importFresh = require('import-fresh');
var Module = require('module');
var path = require('path');
var stripComments = require('strip-json-comments');
var assert = require('assert');
var ignore = require('ignore');
var util = require('util');
var minimatch = require('minimatch');
var Ajv = require('ajv');
var globals = require('globals');
var os = require('os');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var debugOrig__default = /*#__PURE__*/_interopDefaultLegacy(debugOrig);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var importFresh__default = /*#__PURE__*/_interopDefaultLegacy(importFresh);
var Module__default = /*#__PURE__*/_interopDefaultLegacy(Module);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var stripComments__default = /*#__PURE__*/_interopDefaultLegacy(stripComments);
var assert__default = /*#__PURE__*/_interopDefaultLegacy(assert);
var ignore__default = /*#__PURE__*/_interopDefaultLegacy(ignore);
var util__default = /*#__PURE__*/_interopDefaultLegacy(util);
var minimatch__default = /*#__PURE__*/_interopDefaultLegacy(minimatch);
var Ajv__default = /*#__PURE__*/_interopDefaultLegacy(Ajv);
var globals__default = /*#__PURE__*/_interopDefaultLegacy(globals);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);

/**
 * @fileoverview `IgnorePattern` class.
 *
 * `IgnorePattern` class has the set of glob patterns and the base path.
 *
 * It provides two static methods.
 *
 * - `IgnorePattern.createDefaultIgnore(cwd)`
 *      Create the default predicate function.
 * - `IgnorePattern.createIgnore(ignorePatterns)`
 *      Create the predicate function from multiple `IgnorePattern` objects.
 *
 * It provides two properties and a method.
 *
 * - `patterns`
 *      The glob patterns that ignore to lint.
 * - `basePath`
 *      The base path of the glob patterns. If absolute paths existed in the
 *      glob patterns, those are handled as relative paths to the base path.
 * - `getPatternsRelativeTo(basePath)`
 *      Get `patterns` as modified for a given base path. It modifies the
 *      absolute paths in the patterns as prepending the difference of two base
 *      paths.
 *
 * `ConfigArrayFactory` creates `IgnorePattern` objects when it processes
 * `ignorePatterns` properties.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */

const debug$3 = debugOrig__default["default"]("eslintrc:ignore-pattern");

/** @typedef {ReturnType<import("ignore").default>} Ignore */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Get the path to the common ancestor directory of given paths.
 * @param {string[]} sourcePaths The paths to calculate the common ancestor.
 * @returns {string} The path to the common ancestor directory.
 */
function getCommonAncestorPath(sourcePaths) {
    let result = sourcePaths[0];

    for (let i = 1; i < sourcePaths.length; ++i) {
        const a = result;
        const b = sourcePaths[i];

        // Set the shorter one (it's the common ancestor if one includes the other).
        result = a.length < b.length ? a : b;

        // Set the common ancestor.
        for (let j = 0, lastSepPos = 0; j < a.length && j < b.length; ++j) {
            if (a[j] !== b[j]) {
                result = a.slice(0, lastSepPos);
                break;
            }
            if (a[j] === path__default["default"].sep) {
                lastSepPos = j;
            }
        }
    }

    let resolvedResult = result || path__default["default"].sep;

    // if Windows common ancestor is root of drive must have trailing slash to be absolute.
    if (resolvedResult && resolvedResult.endsWith(":") && process.platform === "win32") {
        resolvedResult += path__default["default"].sep;
    }
    return resolvedResult;
}

/**
 * Make relative path.
 * @param {string} from The source path to get relative path.
 * @param {string} to The destination path to get relative path.
 * @returns {string} The relative path.
 */
function relative(from, to) {
    const relPath = path__default["default"].relative(from, to);

    if (path__default["default"].sep === "/") {
        return relPath;
    }
    return relPath.split(path__default["default"].sep).join("/");
}

/**
 * Get the trailing slash if existed.
 * @param {string} filePath The path to check.
 * @returns {string} The trailing slash if existed.
 */
function dirSuffix(filePath) {
    const isDir = (
        filePath.endsWith(path__default["default"].sep) ||
        (process.platform === "win32" && filePath.endsWith("/"))
    );

    return isDir ? "/" : "";
}

const DefaultPatterns = Object.freeze(["/**/node_modules/*"]);
const DotPatterns = Object.freeze([".*", "!.eslintrc.*", "!../"]);

//------------------------------------------------------------------------------
// Public
//------------------------------------------------------------------------------

class IgnorePattern {

    /**
     * The default patterns.
     * @type {string[]}
     */
    static get DefaultPatterns() {
        return DefaultPatterns;
    }

    /**
     * Create the default predicate function.
     * @param {string} cwd The current working directory.
     * @returns {((filePath:string, dot:boolean) => boolean) & {basePath:string; patterns:string[]}}
     * The preficate function.
     * The first argument is an absolute path that is checked.
     * The second argument is the flag to not ignore dotfiles.
     * If the predicate function returned `true`, it means the path should be ignored.
     */
    static createDefaultIgnore(cwd) {
        return this.createIgnore([new IgnorePattern(DefaultPatterns, cwd)]);
    }

    /**
     * Create the predicate function from multiple `IgnorePattern` objects.
     * @param {IgnorePattern[]} ignorePatterns The list of ignore patterns.
     * @returns {((filePath:string, dot?:boolean) => boolean) & {basePath:string; patterns:string[]}}
     * The preficate function.
     * The first argument is an absolute path that is checked.
     * The second argument is the flag to not ignore dotfiles.
     * If the predicate function returned `true`, it means the path should be ignored.
     */
    static createIgnore(ignorePatterns) {
        debug$3("Create with: %o", ignorePatterns);

        const basePath = getCommonAncestorPath(ignorePatterns.map(p => p.basePath));
        const patterns = [].concat(
            ...ignorePatterns.map(p => p.getPatternsRelativeTo(basePath))
        );
        const ig = ignore__default["default"]({ allowRelativePaths: true }).add([...DotPatterns, ...patterns]);
        const dotIg = ignore__default["default"]({ allowRelativePaths: true }).add(patterns);

        debug$3("  processed: %o", { basePath, patterns });

        return Object.assign(
            (filePath, dot = false) => {
                assert__default["default"](path__default["default"].isAbsolute(filePath), "'filePath' should be an absolute path.");
                const relPathRaw = relative(basePath, filePath);
                const relPath = relPathRaw && (relPathRaw + dirSuffix(filePath));
                const adoptedIg = dot ? dotIg : ig;
                const result = relPath !== "" && adoptedIg.ignores(relPath);

                debug$3("Check", { filePath, dot, relativePath: relPath, result });
                return result;
            },
            { basePath, patterns }
        );
    }

    /**
     * Initialize a new `IgnorePattern` instance.
     * @param {string[]} patterns The glob patterns that ignore to lint.
     * @param {string} basePath The base path of `patterns`.
     */
    constructor(patterns, basePath) {
        assert__default["default"](path__default["default"].isAbsolute(basePath), "'basePath' should be an absolute path.");

        /**
         * The glob patterns that ignore to lint.
         * @type {string[]}
         */
        this.patterns = patterns;

        /**
         * The base path of `patterns`.
         * @type {string}
         */
        this.basePath = basePath;

        /**
         * If `true` then patterns which don't start with `/` will match the paths to the outside of `basePath`. Defaults to `false`.
         *
         * It's set `true` for `.eslintignore`, `package.json`, and `--ignore-path` for backward compatibility.
         * It's `false` as-is for `ignorePatterns` property in config files.
         * @type {boolean}
         */
        this.loose = false;
    }

    /**
     * Get `patterns` as modified for a given base path. It modifies the
     * absolute paths in the patterns as prepending the difference of two base
     * paths.
     * @param {string} newBasePath The base path.
     * @returns {string[]} Modifired patterns.
     */
    getPatternsRelativeTo(newBasePath) {
        assert__default["default"](path__default["default"].isAbsolute(newBasePath), "'newBasePath' should be an absolute path.");
        const { basePath, loose, patterns } = this;

        if (newBasePath === basePath) {
            return patterns;
        }
        const prefix = `/${relative(newBasePath, basePath)}`;

        return patterns.map(pattern => {
            const negative = pattern.startsWith("!");
            const head = negative ? "!" : "";
            const body = negative ? pattern.slice(1) : pattern;

            if (body.startsWith("/") || body.startsWith("../")) {
                return `${head}${prefix}${body}`;
            }
            return loose ? pattern : `${head}${prefix}/**/${body}`;
        });
    }
}

/**
 * @fileoverview `ExtractedConfig` class.
 *
 * `ExtractedConfig` class expresses a final configuration for a specific file.
 *
 * It provides one method.
 *
 * - `toCompatibleObjectAsConfigFileContent()`
 *      Convert this configuration to the compatible object as the content of
 *      config files. It converts the loaded parser and plugins to strings.
 *      `CLIEngine#getConfigForFile(filePath)` method uses this method.
 *
 * `ConfigArray#extractConfig(filePath)` creates a `ExtractedConfig` instance.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */

// For VSCode intellisense
/** @typedef {import("../../shared/types").ConfigData} ConfigData */
/** @typedef {import("../../shared/types").GlobalConf} GlobalConf */
/** @typedef {import("../../shared/types").SeverityConf} SeverityConf */
/** @typedef {import("./config-dependency").DependentParser} DependentParser */
/** @typedef {import("./config-dependency").DependentPlugin} De