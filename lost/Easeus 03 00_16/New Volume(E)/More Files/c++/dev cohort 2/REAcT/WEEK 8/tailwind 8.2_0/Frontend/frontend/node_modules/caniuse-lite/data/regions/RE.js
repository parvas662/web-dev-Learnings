se "AssignmentExpression":
                if (["=", "&&="].includes(node.operator)) {
                    return module.exports.couldBeError(node.right);
                }

                if (["||=", "??="].includes(node.operator)) {
                    return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);
                }

                /**
                 * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).
                 * An assignment expression with a mathematical operator can either evaluate to a primitive value,
                 * or throw, depending on the operands. Thus, it cannot evaluate to an `Error` object.
                 */
                return false;

            case "SequenceExpression": {
                const exprs = node.expressions;

                return exprs.length !== 0 && module.exports.couldBeError(exprs.at(-1));
            }

            case "LogicalExpression":

                /*
                 * If the && operator short-circuits, the left side was falsy and therefore not an error, and if it
                 * doesn't short-circuit, it takes the value from the right side, so the right side must always be
                 * a plausible error. A future improvement could verify that the left side could be truthy by
                 * excluding falsy literals.
                 */
                if (node.operator === "&&") {
                    return module.exports.couldBeError(node.right);
                }

                return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);

            case "ConditionalExpression":
                return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);

            default:
                return false;
        }
    },

    /**
     * Check if a given node is a numeric literal or not.
     * @param {ASTNode} node The node to check.
     * @returns {boolean} `true` if the node is a number or bigint literal.
     */
    isNumericLiteral(node) {
        return (
            node.type === "Literal" &&
            (typeof node.value === "number" || Boolean(node.bigint))
        );
    },

    /**
     * Determines whether two tokens can safely be placed next to each other without merging into a single token
     * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.
     * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.
     * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed
     * next to each other, behavior is undefined (although it should return `true` in most cases).
     */
    canTokensBeAdjacent(leftValue, rightValue) {
        const espreeOptions = {
            ecmaVersion: espree.latestEcmaVersion,
            comment: true,
            range: true
        };

        let leftToken;

        if (typeof leftValue === "string") {
            let tokens;

            try {
                tokens = espree.tokenize(leftValue, espreeOptions);
            } catch {
                return false;
            }

            const comments = tokens.comments;

            leftToken = tokens.at(-1);
            if (comments.length) {
                const lastComment = comments.at(-1);

                if (!leftToken || lastComment.range[0] > leftToken.range[0]) {
                    leftToken = lastComment;
                }
            }
        } else {
            leftToken = leftValue;
        }

        /*
         * If a hashbang comment was passed as a token object from SourceCode,
         * its type will be "Shebang" because of the way ESLint itself handles hashbangs.
         * If a hashbang comment was passed in a string and then tokenized in this function,
         * its type will be "Hashbang" because of the way Espree tokenizes hashbangs.
         */
        if (leftToken.type === "Shebang" || leftToken.type === "Hashbang") {
            return false;
        }

        let rightToken;

        if (typeof rightValue === "string") {
