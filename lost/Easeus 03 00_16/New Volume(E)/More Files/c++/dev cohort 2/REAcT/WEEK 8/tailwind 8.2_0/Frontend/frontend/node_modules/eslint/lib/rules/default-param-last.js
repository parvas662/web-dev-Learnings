
				}
			},
			'obj ends up with expected property descriptors'
		);

		st.end();
	});

	t.test('frozen object, ES5+', { skip: !hasPropertyDescriptors }, function (st) {
		var frozen = Object.freeze({ existing: true });

		st['throws'](
			function () { defineDataProperty(frozen, 'existing', 'new value'); },
			TypeError,
			'frozen object can not modify an existing property'
		);

		st['throws'](
			function () { defineDataProperty(frozen, 'new', 'new property'); },
			TypeError,
			'frozen object can not add a new property'
		);

		st.end();
	});

	t.test('sealed object, ES5+', { skip: !hasPropertyDescriptors }, function (st) {
		var sealed = Object.seal({ existing: true });
		st.deepEqual(
			Object.getOwnPropertyDescriptor(sealed, 'existing'),
			{
				configurable: false,
				enumerable: true,
				value: true,
				writable: true
			},
			'existing value on sealed object has expected descriptor'
		);

		defineDataProperty(sealed, 'existing', 'new value');

		st.deepEqual(
			Object.getOwnPropertyDescriptor(sealed, 'existing'),
			{
				configurable: false,
				enumerable: true,
				value: 'new value',
				writable: true
			},
			'existing value on sealed object has changed descriptor'
		);

		st['throws'](
			function () { defineDataProperty(sealed, 'new', 'new property'); },
			TypeError,
			'sealed object can not add a new property'
		);

		st.end();
	});

	t.test('nonextensible object, ES5+', { skip: !hasPropertyDescriptors }, function (st) {
		var nonExt = Object.preventExtensions({ existing: true });

		st.deepEqual(
			Object.getOwnPropertyDescriptor(nonE