export default function collapseDuplicateDeclarations() {
  return (root) => {
    root.walkRules((node) => {
      let seen = new Map()
      let droppable = new Set([])
      let byProperty = new Map()

      node.walkDecls((decl) => {
        // This could happen if we have nested selectors. In that case the
        // parent will loop over all its declarations but also the declarations
        // of nested rules. With this we ensure that we are shallowly checking
        // declarations.
        if (decl.parent !== node) {
          return
        }

        if (seen.has(decl.prop)) {
          // Exact same value as what we have seen so far
          if (seen.get(decl.prop).value === decl.value) {
            // Keep the last one, drop the one we've seen so far
            droppable.add(seen.get(decl.prop))
            // Override the existing one with the new value. This is necessary
            // so that if we happen to have more than one declaration with the
            // same value, that we keep removing the previous one. Otherwise we
            // will only remove the *first* one.
            seen.set(decl.prop,