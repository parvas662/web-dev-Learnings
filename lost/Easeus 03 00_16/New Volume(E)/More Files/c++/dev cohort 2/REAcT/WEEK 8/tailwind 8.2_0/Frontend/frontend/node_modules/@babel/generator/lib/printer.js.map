ult;

type TraversalAncestors = Array<{
    node: Node;
    key: string;
    index?: number;
}>;
type TraversalHandler<T> = (this: undefined, node: Node, parent: TraversalAncestors, state: T) => void;
type TraversalHandlers<T> = {
    enter?: TraversalHandler<T>;
    exit?: TraversalHandler<T>;
};
/**
 * A general AST traversal with both prefix and postfix handlers, and a
 * state object. Exposes ancestry data to each handler so that more complex
 * AST data can be taken into account.
 */
declare function traverse<T>(node: Node, handlers: TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;

/**
 * A prefix AST traversal implementation meant for simple searching
 * and processing.
 */
declare function traverseFast<Options = object>(node: Node | null | undefined, enter: (node: Node, opts?: Options) => void, opts?: Options): void;

declare function shallowEqual<T extends object>(actual: object, expected: T): actual is T;

declare function is<T extends Node["type"]>(type: T, node: Node | null | undefined, opts?: undefined): node is Extract<Node, {
    type: T;
}>;
declare function is<T extends Node["type"], P extends Extract<Node, {
    type: T;
}>>(type: T, n: Node | null | undefined, required: Partial<P>): n is P;
declare function is<P extends Node>(type: string, node: Node | null | undefined, opts: Partial<P>): node is P;
declare function is(type: string, node: Node | null | undefined, opts?: Partial<Node>): node is Node;

/**
 * Check if the input `node` is a binding identifier.
 */
declare function isBinding(node: Node, parent: Node, grandparent?: Node): boolean;

/**
 * Check if the input `node` is block scoped.
 */
declare function isBlockScoped(node: Node): boolean;

/**
 * Check if the input `node` is definitely immutable.
 */
declare function isImmutable(node: Node): boolean;

/**
 * Check if the input `node` is a `let` variable declaration.
 */
declare function isLet(node: Node): boolean;

declare function isNode(node: any): node is Node;

/**
 * Check if two nodes are equivalent
 */
declare function isNodesEquivalent<T extends Partial<Node>>(a: T, b: any): b is T;

/**
 * Test if a `placeholderType` is a `targetType` or if `targetType` is an alias of `placeholderType`.
 */
declare function isPlaceholderType(placeholderType: string, targetType: string): boolean;

/**
 * Check if the input `node` is a reference to a bound variable.
 */
declare function isReferenced(node: Node, parent: Node, grandparent?: Node): boolean;

/**
 * Check if the input `node` is a scope.
 */
declare function isScope(node: Node, parent: Node): boolean;

/**
 * Check if the input `specifier` is a `default` import or export.
 */
declare function isSpecifierDefault(specifier: ModuleSpecifier): boolean;

declare function isType<T extends Node["type"]>(nodeType: string, targetType: T): nodeType is T;
declare function isType(nodeType: string | null | undefined, targetType: string): boolean;

/**
 * Check if the input `name` is a valid identifier name according to the ES3 specification.
 *
 * Additional ES3 reserved words are
 */
declare function isValidES3Identifier(name: string): boolean;

/**
 * Check if the input `name` is a valid identifier name
 * and isn't a reserved word.
 */
declare function isValidIdentifier(name: string, reserved?: boolean): boolean;

/**
 * Check if the input `node` is a variable declaration.
 */
declare function isVar(node: Node): boolean;

/**
 * Determines whether or not the input node `member` matches the
 * input `match`.
 *
 * For example, given the match `React.createClass` it would match the
 * parsed nodes of `React.createClass` and `React["createClass"]`.
 */
declare function matchesPattern(member: Node | null | undefined, match: string | string[], allowPartial?: boolean): boolean;

declare function validate(node: Node | undefined | null, key: string, val: unknown): void;

/**
 * Build a function that when called will return whether or not the
 * input `node` `MemberExpression` matches the input `match`.
 *
 * For example, given the match `React.createClass` it would match the
 * parsed nodes of `React.createClass` and `React["createClass"]`.
 */
declare function buildMatchMemberExpression(match: string, allowPartial?: boolean): (member: Node) => boolean;

type Opts<Obj> = Partial<{
    [Prop in keyof Obj]: Obj[Prop] extends Node ? Node : Obj[Prop] extends Node[] ? Node[] : Obj[Prop];
}>;
declare function isArrayExpression(node: Node | null | undefined, opts?: Opts<ArrayExpression> | null): node is ArrayExpression;
declare function isAssignmentExpression(node: Node | null | undefined, opts?: Opts<AssignmentExpression> | null): node is AssignmentExpression;
declare function isBinaryExpression(node: Node | null | undefined, opts?: Opts<BinaryExpression> | null): node is BinaryExpression;
declare function isInterpreterDirective(node: Node | null | undefined, opts?: Opts<InterpreterDirective> | null): node is InterpreterDirective;
declare function isDirective(node: Node | null | undefined, opts?: Opts<Directive> | null): node is Directive;
declare function isDirectiveLiteral(node: Node | null | undefined, opts?: Opts<DirectiveLiteral> | null): node is DirectiveLiteral;
declare function isBlockStatement(node: Node | null | undefined, opts?: Opts<BlockStatement> | null): node is BlockStatement;
declare function isBreakStatement(node: Node | null | undefined, opts?: Opts<BreakStatement> | null): node is BreakStatement;
declare function isCallExpression(node: Node | null | undefined, opts?: Opts<CallExpression> | null): node is CallExpression;
declare function isCatchClause(node: Node | null | undefined, opts?: Opts<CatchClause> | null): node is CatchClause;
declare function isConditionalExpression(node: Node | null | undefined, opts?: Opts<ConditionalExpression> | null): node is ConditionalExpression;
declare function isContinueStatement(node: Node | null | undefined, opts?: Opts<ContinueStatement> | null): node is ContinueStatement;
declare function isDebuggerStatement(node: Node | null | undefined, opts?: Opts<DebuggerStatement> | null): node is DebuggerStatement;
declare function isDoWhileStatement(node: Node | null | undefined, opts?: Opts<DoWhileStatement> | null): node is DoWhileStatement;
declare function isEmptyStatement(node: Node | null | undefined, opts?: Opts<EmptyStatement> | null): node is EmptyStatement;
declare function isExpressionStatement(node: Node | null | undefined, opts?: Opts<ExpressionStatement> | null): node is ExpressionStatement;
declare function isFile(node: Node | null | undefined, opts?: Opts<File> | null): node is File;
declare function isForInStatement(node: Node | null | undefined, opts?: Opts<ForInStatement> | null): node is ForInStatement;
declare function isForStatement(node: Node | null | undefined, opts?: Opts<ForStatement> | null): node is ForStatement;
declare function isFunctionDeclaration(node: Node | null | undefined, opts?: Opts<FunctionDeclaration> | null): node is FunctionDeclaration;
declare function isFunctionExpression(node: Node | null | undefined, opts?: Opts<FunctionExpression> | null): node is FunctionExpression;
declare function isIdentifier(node: Node | null | undefined, opts?: Opts<Identifier> | null): node is Identifier;
declare function isIfStatement(node: Node | null | undefined, opts?: Opts<IfStatement> | null): node is IfStatement;
declare function isLabeledStatement(node: Node | null | undefined, opts?: Opts<LabeledStatement> | null): node is LabeledStatement;
declare function isStringLiteral(node: Node | null | undefined, opts?: Opts<StringLiteral> | null): node is StringLiteral;
declare function isNumericLiteral(node: Node | null | undefined, opts?: Opts<NumericLiteral> | null): node is NumericLiteral;
declare function isNullLiteral(node: Node | null | undefined, opts?: Opts<NullLiteral> | null): node is NullLiteral;
declare function isBooleanLiteral(node: Node | null | undefined, opts?: Opts<BooleanLiteral> | null): node is BooleanLiteral;
declare function isRegExpLiteral(node: Node | null | undefined, opts?: Opts<RegExpLiteral> | null): node is RegExpLiteral;
declare function isLogicalExpression(node: Node | null | undefined, opts?: Opts<LogicalExpression> | null): node is LogicalExpression;
declare function isMemberExpression(node: Node | null | undefined, opts?: Opts<MemberExpression> | null): node is MemberExpression;
declare function isNewExpression(node: Node | null | undefined, opts?: Opts<NewExpression> | null): node is NewExpression;
declare function isProgram(node: Node | null | undefined, opts?: Opts<Program> | null): node is Program;
declare function isObjectExpression(node: Node | null | undefined, opts?: Opts<ObjectExpression> | null): node is ObjectExpression;
declare function isObjectMethod(node: Node | null | undefined, opts?: Opts<ObjectMethod> | null): node is ObjectMethod;
declare function isObjectProperty(node: Node | null | undefined, opts?: Opts<ObjectProperty> | null): node is ObjectProperty;
declare function isRestElement(node: Node | null | undefined, opts?: Opts<RestElement> | null): node is RestElement;
declare function isReturnStatement(node: Node | null | undefined, opts?: Opts<ReturnStatement> | null): node is ReturnStatement;
declare function isSequenceExpression(node: Node | null | undefined, opts?: Opts<SequenceExpression> | null): node is SequenceExpression;
declare function isParenthesizedExpression(node: Node | null | undefined, opts?: Opts<ParenthesizedExpression> | null): node is ParenthesizedExpression;
declare function isSwitchCase(node: Node | null | undefined, opts?: Opts<SwitchCase> | null): node is SwitchCase;
declare function isSwitchStatement(node: Node | null | undefined, opts?: Opts<SwitchStatement> | null): node is SwitchStatement;
declare function isThisExpression(node: Node | null | undefined, opts?: Opts<ThisExpression> | null): node is ThisExpression;
declare function isThrowStatement(node: Node | null | undefined, opts?: Opts<ThrowStatement> | null): node is ThrowStatement;
declare function isTryStatement(node: Node | null | undefined, opts?: Opts<TryStatement> | null): node is TryStatement;
declare function isUnaryExpression(node: Node | null | undefined, opts?: Opts<UnaryExpression> | null): node is UnaryExpression;
declare function isUpdateExpression(node: Node | null | undefined, opts?: Opts<UpdateExpression> | null): node is UpdateExpression;
declare function isVariableDeclaration(node: Node | null | undefined, opts?: Opts<VariableDeclaration> | null): node is VariableDeclaration;
declare function isVariableDeclarator(node: Node | null | undefined, opts?: Opts<VariableDeclarator> | null): node is VariableDeclarator;
declare function isWhileStatement(node: Node | null | undefined, opts?: Opts<WhileStatement> | null): node is WhileStatement;
declare function isWithStatement(node: Node | null | undefined, opts?: Opts<WithStatement> | null): node is WithStatement;
declare function isAssignmentPattern(node: Node | null | undefined, opts?: Opts<AssignmentPattern> | null): node is AssignmentPattern;
declare function isArrayPattern(node: Node | null | undefined, opts?: Opts<ArrayPattern> | null): node is ArrayPattern;
declare function isArrowFunctionExpression(node: Node | null | undefined, opts?: Opts<ArrowFunctionExpression> | null): node is ArrowFunctionExpression;
declare function isClassBody(node: Node | null | undefined, opts?: Opts<ClassBody> | null): node is ClassBody;
declare function isClassExpression(node: Node | null | undefined, opts?: Opts<ClassExpression> | null): node is ClassExpression;
declare function isClassDeclaration(node: Node | null | undefined, opts?: Opts<ClassDeclaration> | null): node is ClassDeclaration;
declare function isExportAllDeclaration(node: Node | null | undefined, opts?: Opts<ExportAllDeclaration> | null): node is ExportAllDeclaration;
declare function isExportDefaultDeclaration(node: Node | null | undefined, opts?: Opts<ExportDefaultDeclaration> | null): node is ExportDefaultDeclaration;
declare function isExportNamedDeclaration(node: Node | null | undefined, opts?: Opts<ExportNamedDeclaration> | null): node is ExportNamedDeclaration;
declare function isExportSpecifier(node: Node | null | undefined, opts?: Opts<ExportSpecifier> | null): node is ExportSpecifier;
declare function isForOfStatement(node: Node | null | undefined, opts?: Opts<ForOfStatement> | null): node is ForOfStatement;
declare function isImportDeclaration(node: Node | null | undefined, opts?: Opts<ImportDeclaration> | null): node is ImportDeclaration;
declare function isImportDefaultSpecifier(node: Node | null | undefined, opts?: Opts<ImportDefaultSpecifier> | null): node is ImportDefaultSpecifier;
declare function isImportNamespaceSpecifier(node: Node | null | undefined, opts?: Opts<ImportNamespaceSpecifier> | null): node is ImportNamespaceSpecifier;
declare function isImportSpecifier(node: Node | null | undefined, opts?: Opts<ImportSpecifier> | null): node is ImportSpecifier;
declare function isImportExpression(node: Node | null | undefined, opts?: Opts<ImportExpression> | null): node is ImportExpression;
declare function isMetaProperty(node: Node | null | undefined, opts?: Opts<MetaProperty> | null): node is MetaProperty;
declare function isClassMethod(node: Node | null | undefined, opts?: Opts<ClassMethod> | null): node is ClassMethod;
declare function isObjectPattern(node: Node | null | undefined, opts?: Opts<ObjectPattern> | null): node is ObjectPattern;
declare function isSpreadElement(node: Node | null | undefined, opts?: Opts<SpreadElement> | null): node is SpreadElement;
declare function isSuper(node: Node | null | undefined, opts?: Opts<Super> | null): node is Super;
declare function isTaggedTemplateExpression(node: Node | null | undefined, opts?: Opts<TaggedTemplateExpression> | null): node is TaggedTemplateExpression;
declare function isTemplateElement(node: Node | null | undefined, opts?: Opts<TemplateElement> | null): node is TemplateElement;
declare function isTemplateLiteral(node: Node | null | undefined, opts?: Opts<TemplateLiteral> | null): node is TemplateLiteral;
declare function isYieldExpression(node: Node | null | undefined, opts?: Opts<YieldExpression> | null): node is YieldExpression;
declare function isAwaitExpression(node: Node | null | undefined, opts?: Opts<AwaitExpression> | null): node is AwaitExpression;
declare function isImport(node: Node | null | undefined, opts?: Opts<Import> | null): node is Import;
declare function isBigIntLiteral(node: Node | null | undefined, opts?: Opts<BigIntLiteral> | null): node is BigIntLiteral;
declare function isExportNamespaceSpecifier(node: Node | null | undefined, opts?: Opts<ExportNamespaceSpecifier> | null): node is ExportNamespaceSpecifier;
declare function isOptionalMemberExpression(node: Node | null | undefined, opts?: Opts<OptionalMemberExpression> | null): node is OptionalMemberExpression;
declare function isOptionalCallExpression(node: Node | null | undefined, opts?: Opts<OptionalCallExpression> | null): node is OptionalCallExpression;
declare function isClassProperty(node: Node | null | undefined, opts?: Opts<ClassProperty> | null): node is ClassProperty;
declare function isClassAccessorProperty(node: Node | null | undefined, opts?: Opts<ClassAccessorProperty> | null): node is ClassAccessorProperty;
declare function isClassPrivateProperty(node: Node | null | undefined, opts?: Opts<ClassPrivateProperty> | null): node is ClassPrivateProperty;
declare function isClassPrivateMethod(node: Node | null | undefined, opts?: Opts<ClassPrivateMethod> | null): node is ClassPrivateMethod;
declare function isPrivateName(node: Node | null | undefined, opts?: Opts<PrivateName> | null): node is PrivateName;
declare function isStaticBlock(node: Node | null | undefined, opts?: Opts<StaticBlock> | null): node is StaticBlock;
declare function isAnyTypeAnnotation(node: Node | null | undefined, opts?: Opts<AnyTypeAnnotation> | null): node is AnyTypeAnnotation;
declare function isArrayTypeAnnotation(node: Node | null | undefined, opts?: Opts<ArrayTypeAnnotation> | null): node is ArrayTypeAnnotation;
declare function isBooleanTypeAnnotation(node: Node | null | undefined, opts?: Opts<BooleanTypeAnnotation> | null): node is BooleanTypeAnnotation;
declare function isBooleanLiteralTypeAnnotation(node: Node | null | undefined, opts?: Opts<BooleanLiteralTypeAnnotation> | null): node is BooleanLiteralTypeAnnotation;
declare function isNullLiteralTypeAnnotation(node: Node | null | undefined, opts?: Opts<NullLiteralTypeAnnotation> | null): node is NullLiteralTypeAnnotation;
declare function isClassImplements(node: Node | null | undefined, opts?: Opts<ClassImplements> | null): node is ClassImplements;
declare function isDeclareClass(node: Node | null | undefined, opts?: Opts<DeclareClass> | null): node is DeclareClass;
declare function isDeclareFunction(node: Node | null | undefined, opts?: Opts<DeclareFunction> | null): node is DeclareFunction;
declare function isDeclareInterface(node: Node | null | undefined, opts?: Opts<DeclareInterface> | null): node is DeclareInterface;
declare function isDeclareModule(node: Node | null | undefined, opts?: Opts<DeclareModule> | null): node is DeclareModule;
declare function isDeclareModuleExports(node: Node | null | undefined, opts?: Opts<DeclareModuleExports> | null): node is DeclareModuleExports;
declare function isDeclareTypeAlias(node: Node | null | undefined, opts?: Opts<DeclareTypeAlias> | null): node is DeclareTypeAlias;
declare function isDeclareOpaqueType(node: Node | null | undefined, opts?: Opts<DeclareOpaqueType> | null): node is DeclareOpaqueType;
declare function isDeclareVariable(node: Node | null | undefined, opts?: Opts<DeclareVariable> | null): node is DeclareVariable;
declare function isDeclareExportDeclaration(node: Node | null | undefined, opts?: Opts<DeclareExportDeclaration> | null): node is DeclareExportDeclaration;
declare function isDeclareExportAllDeclaration(node: Node | null | undefined, opts?: Opts<DeclareExportAllDeclaration> | null): node is DeclareExportAllDeclaration;
declare function isDeclaredPredicate(node: Node | null | undefined, opts?: Opts<DeclaredPredicate> | null): node is DeclaredPredicate;
declare function isExistsTypeAnnotation(node: Node | null | undefined, opts?: Opts<ExistsTypeAnnotation> | null): node is ExistsTypeAnnotation;
declare function isFunctionTypeAnnotation(node: Node | null | undefined, opts?: Opts<FunctionTypeAnnotation> | null): node is FunctionTypeAnnotation;
declare function isFunctionTypeParam(node: Node | null | undefined, opts?: Opts<FunctionTypeParam> | null): node is FunctionTypeParam;
declare function isGenericTypeAnnotation(node: Node | null | undefined, opts?: Opts<GenericTypeAnnotation> | null): node is GenericTypeAnnotation;
declare function isInferredPredicate(node: Node | null | undefined, opts?: Opts<InferredPredicate> | null): node is InferredPredicate;
declare function isInterfaceExtends(node: Node | null | undefined, opts?: Opts<InterfaceExtends> | null): node is InterfaceExtends;
declare function isInterfaceDeclaration(node: Node | null | undefined, opts?: Opts<InterfaceDeclaration> | null): node is InterfaceDeclaration;
declare function isInterfaceTypeAnnotation(node: Node | null | undefined, opts?: Opts<InterfaceTypeAnnotation> | null): node is InterfaceTypeAnnotation;
declare function isIntersectionTypeAnnotation(node: Node | null | undefined, opts?: Opts<IntersectionTypeAnnotation> | null): node is IntersectionTypeAnnotation;
declare function isMixedTypeAnnotation(node: Node | null | undefined, opts?: Opts<MixedTypeAnnotation> | null): node is MixedTypeAnnotation;
declare function isEmptyTypeAnnotation(node: Node | null | undefined, opts?: Opts<EmptyTypeAnnotation> | null): node is EmptyTypeAnnotation;
declare function isNullableTypeAnnotation(node: Node | null | undefined, opts?: Opts<NullableTypeAnnotation> | null): node is NullableTypeAnnotation;
declare function isNumberLiteralTypeAnnotation(node: Node | null | undefined, opts?: Opts<NumberLiteralTypeAnnotation> | null): node is NumberLiteralTypeAnnotation;
declare function isNumberTypeAnnotation(node: Node | null | undefined, opts?: Opts<NumberTypeAnnotation> | null): node is NumberTypeAnnotation;
declare function isObjectTypeAnnotation(node: Node | null | undefined, opts?: Opts<ObjectTypeAnnotation> | null): node is ObjectTypeAnnotation;
declare function isObjectTypeInternalSlot(node: Node | null | undefined, opts?: Opts<ObjectTypeInternalSlot> | null): node is ObjectTypeInternalSlot;
declare function isObjectTypeCallProperty(node: Node | null | undefined, opts?: Opts<ObjectTypeCallProperty> | null): node is ObjectTypeCallProperty;
declare function isObjectTypeIndexer(node: Node | null | undefined, opts?: Opts<ObjectTypeIndexer> | null): node is ObjectTypeIndexer;
declare function isObjectTypeProperty(node: Node | null | undefined, opts?: Opts<ObjectTypeProperty> | null): node is ObjectTypeProperty;
declare function isObjectTypeSpreadProperty(node: Node | null | undefined, opts?: Opts<ObjectTypeSpreadProperty> | null): node is ObjectTypeSpreadProperty;
declare function isOpaqueType(node: Node | null | undefined, opts?: Opts<OpaqueType> | null): node is OpaqueType;
declare function isQualifiedTypeIdentifier(node: Node | null | undefined, opts?: Opts<QualifiedTypeIdentifier> | null): node is QualifiedTypeIdentifier;
declare function isStringLiteralTypeAnnotation(node: Node | null | undefined, opts?: Opts<StringLiteralTypeAnnotation> | null): node is StringLiteralTypeAnnotation;
declare function isStringTypeAnnotation(node: Node | null | undefined, opts?: Opts<StringTypeAnnotation> | null): node is StringTypeAnnotation;
declare function isSymbolTypeAnnotation(node: Node | null | undefined, opts?: Opts<SymbolTypeAnnotation> | null): node is SymbolTypeAnnotation;
declare function isThisTypeAnnotation(node: Node | null | undefined, opts?: Opts<ThisTypeAnnotation> | null): node is ThisTypeAnnotation;
declare function isTupleTypeAnnotation(node: Node | null | undefined, opts?: Opts<TupleTypeAnnotation> | null): node is TupleTypeAnnotation;
declare function isTypeofTypeAnnotation(node: Node | null | undefined, opts?: Opts<TypeofTypeAnnotation> | null): node is TypeofTypeAnnotation;
declare function isTypeAlias(node: Node | null | undefined, opts?: Opts<TypeAlias> | null): node is TypeAlias;
declare function isTypeAnnotation(node: Node | null | undefined, opts?: Opts<TypeAnnotation> | null): node is TypeAnnotation;
declare function isTypeCastExpression(node: Node | null | undefined, opts?: Opts<TypeCastExpression> | null): node is TypeCastExpression;
declare function isTypeParameter(node: Node | null | undefined, opts?: Opts<TypeParameter> | null): node is TypeParameter;
declare function isTypeParameterDeclaration(node: Node | null | undefined, opts?: Opts<TypeParameterDeclaration> | null): node is TypeParameterDeclaration;
declare function isTypeParameterInstantiation(node: Node | null | undefined, opts?: Opts<TypeParameterInstantiation> | null): node is TypeParameterInstantiation;
declare function isUnionTypeAnnotation(node: Node | null | undefined, opts?: Opts<UnionTypeAnnotation> | null): node is UnionTypeAnnotation;
declare function isVariance(node: Node | null | undefined, opts?: Opts<Variance> | null): node is Variance;
declare function isVoidTypeAnnotation(node: Node | null | undefined, opts?: Opts<VoidTypeAnnotation> | null): node is VoidTypeAnnotation;
declare function isEnumDeclaration(node: Node | null | undefined, opts?: Opts<EnumDeclaration> | null): node is EnumDeclaration;
declare function isEnumBooleanBody(node: Node | null | undefined, opts?: Opts<EnumBooleanBody> | null): node is EnumBooleanBody;
declare function isEnumNumberBody(node: Node | null | undefined, opts?: Opts<EnumNumberBody> | null): node is EnumNumberBody;
declare function isEnumStringBody(node: Node | null | undefined, opts?: Opts<EnumStringBody> | null): node is EnumStringBody;
declare function isEnumSymbolBody(node: Node | null | undefined, opts?: Opts<EnumSymbolBody> | null): node is EnumSymbolBody;
declare function isEnumBooleanMember(node: Node | null | undefined, opts?: Opts<EnumBooleanMember> | null): node is EnumBooleanMember;
declare function isEnumNumberMember(node: Node | null | undefined, opts?: Opts<EnumNumberMember> | null): node is EnumNumberMember;
declare function isEnumStringMember(node: Node | null | undefined, opts?: Opts<EnumStringMember> | null): node is EnumStringMember;
declare function isEnumDefaultedMember(node: Node | null | undefined, opts?: Opts<EnumDefaultedMember> | null): node is EnumDefaultedMember;
declare function isIndexedAccessType(node: Node | null | undefined, opts?: Opts<IndexedAccessType> | null): node is IndexedAccessType;
declare function isOptionalIndexedAccessType(node: Node | null | undefined, opts?: Opts<OptionalIndexedAccessType> | null): node is OptionalIndexedAccessType;
declare function isJSXAttribute(node: Node | null | undefined, opts?: Opts<JSXAttribute> | null): node is JSXAttribute;
declare function isJSXClosingElement(node: Node | null | undefined, opts?: Opts<JSXClosingElement> | null): node is JSXClosingElement;
declare function isJSXElement(node: Node | null | undefined, opts?: Opts<JSXElement> | null): node is JSXElement;
declare function isJSXEmptyExpression(node: Node | null | undefined, opts?: Opts<JSXEmptyExpression> | null): node is JSXEmptyExpression;
declare function isJSXExpressionContainer(node: Node | null | undefined, opts?: Opts<JSXExpressionContainer> | null): node is JSXExpressionContainer;
declare function isJSXSpreadChild(node: Node | null | undefined, opts?: Opts<JSXSpreadChild> | null): node is JSXSpreadChild;
declare function isJSXIdentifier(node: Node | null | undefined, opts?: Opts<JSXIdentifier> | null): node is JSXIdentifier;
declare function isJSXMemberExpression(node: Node | null | undefined, opts?: Opts<JSXMemberExpression> | null): node is JSXMemberExpression;
declare function isJSXNamespacedName(node: Node | null | undefined, opts?: Opts<JSXNamespacedName> | null): node is JSXNamespacedName;
declare function isJSXOpeningElement(node: Node | null | undefined, opts?: Opts<JSXOpeningElement> | null): node is JSXOpeningElement;
declare function isJSXSpreadAttribute(node: Node | null | undefined, opts?: Opts<JSXSpreadAttribute> | null): node is JSXSpreadAttribute;
declare function isJSXText(node: Node | null | undefined, opts?: Opts<JSXText> | null): node is JSXText;
declare function isJSXFragment(node: Node | null | undefined, opts?: Opts<JSXFragment> | null): node is JSXFragment;
declare function isJSXOpeningFragment(node: Node | null | undefined, opts?: Opts<JSXOpeningFragment> | null): node is JSXOpeningFragment;
declare function isJSXClosingFragment(node: Node | null | undefined, opts?: Opts<JSXClosingFragment> | null): node is JSXClosingFragment;
declare function isNoop(node: Node | null | undefined, opts?: Opts<Noop> | null): node is Noop;
declare function isPlaceholder(node: Node | null | undefined, opts?: Opts<Placeholder> | null): node is Placeholder;
declare function isV8IntrinsicIdentifier(node: Node | null | undefined, opts?: Opts<V8IntrinsicIdentifier> | null): node is V8IntrinsicIdentifier;
declare function isArgumentPlaceholder(node: Node | null | undefined, opts?: Opts<ArgumentPlaceholder> | null): node is ArgumentPlaceholder;
declare function isBindExpression(node: Node | null | undefined, opts?: Opts<BindExpression> | null): node is BindExpression;
declare function isImportAttribute(node: Node | null | undefined, opts?: Opts<ImportAttribute> | null): node is ImportAttribute;
declare function isDecorator(node: Node | null | undefined, opts?: Opts<Decorator> | null): node is Decorator;
declare function isDoExpression(node: Node | null | undefined, opts?: Opts<DoExpression> | null): node is DoExpression;
declare function isExportDefaultSpecifier(node: Node | null | undefined, opts?: Opts<ExportDefaultSpecifier> | null): node is ExportDefaultSpecifier;
declare function isRecordExpression(node: Node | null | undefined, opts?: Opts<RecordExpression> | null): node is RecordExpression;
declare function isTupleExpression(node: Node | null | undefined, opts?: Opts<TupleExpression> | null): node is TupleExpression;
declare function isDecimalLiteral(node: Node | null | undefined, opts?: Opts<DecimalLiteral> | null): node is DecimalLiteral;
declare function isModuleExpression(node: Node | null | undefined, opts?: Opts<ModuleExpression> | null): node is ModuleExpression;
declare function isTopicReference(node: Node | null | undefined, opts?: Opts<TopicReference> | null): node is TopicReference;
declare function isPipelineTopicExpression(node: Node | null | undefined, opts?: Opts<PipelineTopicExpression> | null): node is PipelineTopicExpression;
declare function isPipelineBareFunction(node: Node | null | undefined, opts?: Opts<PipelineBareFunction> | null): node is PipelineBareFunction;
declare function isPipelinePrimaryTopicReference(node: Node | null | undefined, opts?: Opts<PipelinePrimaryTopicReference> | null): node is PipelinePrimaryTopicReference;
declare function isTSParameterProperty(node: Node | null | undefined, opts?: Opts<TSParameterProperty> | null): node is TSParameterProperty;
declare function isTSDeclareFunction(node: Node | null | undefined, opts?: Opts<TSDeclareFunction> | null): node is TSDeclareFunction;
declare function isTSDeclareMethod(node: Node | null | undefined, opts?: Opts<TSDeclareMethod> | null): node is TSDeclareMethod;
declare function isTSQualifiedName(node: Node | null | undefined, opts?: Opts<TSQualifiedName> | null): node is TSQualifiedName;
declare function isTSCallSignatureDeclaration(node: Node | null | undefined, opts?: Opts<TSCallSignatureDeclaration> | null): node is TSCallSignatureDeclaration;
declare function isTSConstructSignatureDeclaration(node: Node | null | undefined, opts?: Opts<TSConstructSignatureDeclaration> | null): node is TSConstructSignatureDeclaration;
declare function isTSPropertySignature(node: Node | null | undefined, opts?: Opts<TSPropertySignature> | null): node is TSPropertySignature;
declare function isTSMethodSignature(node: Node | null | undefined, opts?: Opts<TSMethodSignature> | null): node is TSMethodSignature;
declare function isTSIndexSignature(node: Node | null | undefined, opts?: Opts<TSIndexSignature> | null): node is TSIndexSignature;
declare function isTSAnyKeyword(node: Node | null | undefined, opts?: Opts<TSAnyKeyword> | null): node is TSAnyKeyword;
declare function isTSBooleanKeyword(node: Node | null | undefined, opts?: Opts<TSBooleanKeyword> | null): node is TSBooleanKeyword;
declare function isTSBigIntKeyword(node: Node | null | undefined, opts?: Opts<TSBigIntKeyword> | null): node is TSBigIntKeyword;
declare function isTSIntrinsicKeyword(node: Node | null | undefined, opts?: Opts<TSIntrinsicKeyword> | null): node is TSIntrinsicKeyword;
declare function isTSNeverKeyword(node: Node | null | undefined, opts?: Opts<TSNeverKeyword> | null): node is TSNeverKeyword;
declare function isTSNullKeyword(node: Node | null | undefined, opts?: Opts<TSNullKeyword> | null): node is TSNullKeyword;
declare function isTSNumberKeyword(node: Node | null | undefined, opts?: Opts<TSNumberKeyword> | null): node is TSNumberKeyword;
declare function isTSObjectKeyword(node: Node | null | undefined, opts?: Opts<TSObjectKeyword> | null): node is TSObjectKeyword;
declare function isTSStringKeyword(node: Node | null | undefined, opts?: Opts<TSStringKeyword> | null): node is TSStringKeyword;
declare function isTSSymbolKeyword(node: Node | null | undefined, opts?: Opts<TSSymbolKeyword> | null): node is TSSymbolKeyword;
declare function isTSUndefinedKeyword(node: Node | null | undefined, opts?: Opts<TSUndefinedKeyword> | null): node is TSUndefinedKeyword;
declare function isTSUnknownKeyword(node: Node | null | undefined, opts?: Opts<TSUnknownKeyword> | null): node is TSUnknownKeyword;
declare function isTSVoidKeyword(node: Node | null | undefined, opts?: Opts<TSVoidKeyword> | null): node is TSVoidKeyword;
declare function isTSThisType(node: Node | null | undefined, opts?: Opts<TSThisType> | null): node is TSThisType;
declare function isTSFunctionType(node: Node | null | undefined, opts?: Opts<TSFunctionType> | null): node is TSFunctionType;
declare function isTSConstructorType(node: Node | null | undefined, opts?: Opts<TSConstructorType> | null): node is TSConstructorType;
declare function isTSTypeReference(node: Node | null | undefined, opts?: Opts<TSTypeReference> | null): node is TSTypeReference;
declare function isTSTypePredicate(node: Node | null | undefined, opts?: Opts<TSTypePredicate> | null): node is TSTypePredicate;
declare function isTSTypeQuery(node: Node | null | undefined, opts?: Opts<TSTypeQuery> | null): node is TSTypeQuery;
declare function isTSTypeLiteral(node: Node | null | undefined, opts?: Opts<TSTypeLiteral> | null): node is TSTypeLiteral;
declare function isTSArrayType(node: Node | null | undefined, opts?: Opts<TSArrayType> | null): node is TSArrayType;
declare function isTSTupleType(node: Node | null | undefined, opts?: Opts<TSTupleType> | null): node is TSTupleType;
declare function isTSOptionalType(node: Node | null | undefined, opts?: Opts<TSOptionalType> | null): node is TSOptionalType;
declare function isTSRestType(node: Node | null | undefined, opts?: Opts<TSRestType> | null): node is TSRestType;
declare function isTSNamedTupleMember(node: Node | null | undefined, opts?: Opts<TSNamedTupleMember> | null): node is TSNamedTupleMember;
declare function isTSUnionType(node: Node | null | undefined, opts?: Opts<TSUnionType> | null): node is TSUnionType;
declare function isTSIntersectionType(node: Node | null | undefined, opts?: Opts<TSIntersectionType> | null): node is TSIntersectionType;
declare function isTSConditionalType(node: Node | null | undefined, opts?: Opts<TSConditionalType> | null): node is TSConditionalType;
declare function isTSInferType(node: Node | null | undefined, opts?: Opts<TSInferType> | null): node is TSInferType;
declare function isTSParenthesizedType(node: Node | null | undefined, opts?: Opts<TSParenthesizedType> | null): node is TSParenthesizedType;
declare function isTSTypeOperator(node: Node | null | undefined, opts?: Opts<TSTypeOperator> | null): node is TSTypeOperator;
declare function isTSIndexedAccessType(node: Node | null | undefined, opts?: Opts<TSIndexedAccessType> | null): node is TSIndexedAccessType;
declare function isTSMappedType(node: Node | null | undefined, opts?: Opts<TSMappedType> | null): node is TSMappedType;
declare function isTSLiteralType(node: Node | null | undefined, opts?: Opts<TSLiteralType> | null): node is TSLiteralType;
declare function isTSExpressionWithTypeArguments(node: Node | null | undefined, opts?: Opts<TSExpressionWithTypeArguments> | null): node is TSExpressionWithTypeArguments;
declare function isTSInterfaceDeclaration(node: Node | null | undefined, opts?: Opts<TSInterfaceDeclaration> | null): node is TSInterfaceDeclaration;
declare function isTSInterfaceBody(node: Node | null | undefined, opts?: Opts<TSInterfaceBody> | null): node is TSInterfaceBody;
declare function isTSTypeAliasDeclaration(node: Node | null | undefined, opts?: Opts<TSTypeAliasDeclaration> | null): node is TSTypeAliasDeclaration;
declare function isTSInstantiationExpression(node: Node | null | undefined, opts?: Opts<TSInstantiationExpression> | null): node is TSInstantiationExpression;
declare function isTSAsExpression(node: Node | null | undefined, opts?: Opts<TSAsExpression> | null): node is TSAsExpression;
declare function isTSSatisfiesExpression(node: Node | null | undefined, opts?: Opts<TSSatisfiesExpression> | null): node is TSSatisfiesExpression;
declare function isTSTypeAssertion(node: Node | null | undefined, opts?: Opts<TSTypeAssertion> | null): node is TSTypeAssertion;
declare function isTSEnumDeclaration(node: Node | null | undefined, opts?: Opts<TSEnumDeclaration> | null): node is TSEnumDeclaration;
declare function isTSEnumMember(node: Node | null | undefined, opts?: Opts<TSEnumMember> | null): node is TSEnumMember;
declare function isTSModuleDeclaration(node: Node | null | undefined, opts?: Opts<TSModuleDeclaration> | null): node is TSModuleDeclaration;
declare function isTSModuleBlock(node: Node | null | undefined, opts?: Opts<TSModuleBlock> | null): node is TSModuleBlock;
declare function isTSImportType(node: Node | null | undefined, opts?: Opts<TSImportType> | null): node is TSImportType;
declare function isTSImportEqualsDeclaration(node: Node | null | undefined, opts?: Opts<TSImportEqualsDeclaration> | null): node is TSImportEqualsDeclaration;
declare function isTSExternalModuleReference(node: Node | null | undefined, opts?: Opts<TSExternalModuleReference> | null): node is TSExternalModuleReference;
declare function isTSNonNullExpression(node: Node | null | undefined, opts?: Opts<TSNonNullExpression> | null): node is TSNonNullExpression;
declare function isTSExportAssignment(node: Node | null | undefined, opts?: Opts<TSExportAssignment> | null): node is TSExportAssignment;
declare function isTSNamespaceExportDeclaration(node: Node | null | undefined, opts?: Opts<TSNamespaceExportDeclaration> | null): node is TSNamespaceExportDeclaration;
declare function isTSTypeAnnotation(node: Node | null | undefined, opts?: Opts<TSTypeAnnotation> | null): node is TSTypeAnnotation;
declare function isTSTypeParameterInstantiation(node: Node | null | undefined, opts?: Opts<TSTypeParameterInstantiation> | null): node is TSTypeParameterInstantiation;
declare function isTSTypeParameterDeclaration(node: Node | null | undefined, opts?: Opts<TSTypeParameterDeclaration> | null): node is TSTypeParameterDeclaration;
declare function isTSTypeParameter(node: Node | null | undefined, opts?: Opts<TSTypeParameter> | null): node is TSTypeParameter;
declare function isStandardized(node: Node | null | undefined, opts?: Opts<Standardized> | null): node is Standardized;
declare function isExpression(node: Node | null | undefined, opts?: Opts<Expression> | null): node is Expression;
declare function isBinary(node: Node | null | undefined, opts?: Opts<Binary> | null): node is Binary;
declare function isScopable(node: Node | null | undefined, opts?: Opts<Scopable> | null): node is Scopable;
declare function isBlockParent(node: Node | null | undefined, opts?: Opts<BlockParent> | null): node is BlockParent;
declare function isBlock(node: Node | null | undefined, opts?: Opts<Block> | null): node is Block;
declare function isStatement(node: Node | null | undefined, opts?: Opts<Statement> | null): node is Statement;
declare function isTerminatorless(node: Node | null | undefined, opts?: Opts<Terminatorless> | null): node is Terminatorless;
declare function isCompletionStatement(node: Node | null | undefined, opts?: Opts<CompletionStatement> | null): node is CompletionStatement;
declare function isConditional(node: Node | null | undefined, opts?: Opts<Conditional> | null): node is Conditional;
declare function isLoop(node: Node | null | undefined, opts?: Opts<Loop> | null): node is Loop;
declare function isWhile(node: Node | null | undefined, opts?: Opts<While> | null): node is While;
declare function isExpressionWrapper(node: Node | null | undefined, opts?: Opts<ExpressionWrapper> | null): node is ExpressionWrapper;
declare function isFor(node: Node | null | undefined, opts?: Opts<For> | null): node is For;
declare function isForXStatement(node: Node | null | undefined, opts?: Opts<ForXStatement> | null): node is ForXStatement;
declare function isFunction(node: Node | null | undefined, opts?: Opts<Function> | null): node is Function;
declare function isFunctionParent(node: Node | null | undefined, opts?: Opts<FunctionParent> | null): node is FunctionParent;
declare function isPureish(node: Node | null | undefined, opts?: Opts<Pureish> | null): node is Pureish;
declare function isDeclaration(node: Node | null | undefined, opts?: Opts<Declaration> | null): node is Declaration;
declare function isPatternLike(node: Node | null | undefined, opts?: Opts<PatternLike> | null): node is PatternLike;
declare function isLVal(node: Node | null | undefined, opts?: Opts<LVal> | null): node is LVal;
declare function isTSEntityName(node: Node | null | undefined, opts?: Opts<TSEntityName> | null): node is TSEntityName;
declare function isLiteral(node: Node | null | undefined, opts?: Opts<Literal> | null): node is Literal;
declare function isUserWhitespacable(node: Node | null | undefined, opts?: Opts<UserWhitespacable> | null): node is UserWhitespacable;
declare function isMethod(node: Node | null | undefined, opts?: Opts<Method> | null): node is Method;
declare function isObjectMember(node: Node | null | undefined, opts?: Opts<ObjectMember> | null): node is ObjectMember;
declare function isProperty(node: Node | null | undefined, opts?: Opts<Property> | null): node is Property;
declare function isUnaryLike(node: Node | null | undefined, opts?: Opts<UnaryLike> | null): node is UnaryLike;
declare function isPattern(node: Node | null | undefined, opts?: Opts<Pattern> | null): node is Pattern;
declare function isClass(node: Node | null | undefined, opts?: Opts<Class> | null): node is Class;
declare function isImportOrExportDeclaration(node: Node | null | undefined, opts?: Opts<ImportOrExportDeclaration> | null): node is ImportOrExportDeclaration;
declare function isExportDeclaration(node: Node | null | undefined, opts?: Opts<ExportDeclaration> | null): node is ExportDeclaration;
declare function isModuleSpecifier(node: Node | null | undefined, opts?: Opts<ModuleSpecifier> | null): node is ModuleSpecifier;
declare function isAccessor(node: Node | null | undefined, opts?: Opts<Accessor> | null): node is Accessor;
declare function isPrivate(node: Node | null | undefined, opts?: Opts<Private> | null): node is Private;
declare function isFlow(node: Node | null | undefined, opts?: Opts<Flow> | null): node is Flow;
declare function isFlowType(node: Node | null | undefined, opts?: Opts<FlowType> | null): node is FlowType;
declare function isFlowBaseAnnotation(node: Node | null | undefined, opts?: Opts<FlowBaseAnnotation> | null): node is FlowBaseAnnotation;
declare function isFlowDeclaration(node: Node | null | undefined, opts?: Opts<FlowDeclaration> | null): node is FlowDeclaration;
declare function isFlowPredicate(node: Node | null | undefined, opts?: Opts<FlowPredicate> | null): node is FlowPredicate;
declare function isEnumBody(node: Node | null | undefined, opts?: Opts<EnumBody> | null): node is EnumBody;
declare function isEnumMember(node: Node | null | undefined, opts?: Opts<EnumMember> | null): node is EnumMember;
declare function isJSX(node: Node | null | undefined, opts?: Opts<JSX> | null): node is JSX;
declare function isMiscellaneous(node: Node | null | undefined, opts?: Opts<Miscellaneous> | null): node is Miscellaneous;
declare function isTypeScript(node: Node | null | undefined, opts?: Opts<TypeScript> | null): node is TypeScript;
declare function isTSTypeElement(node: Node | null | undefined, opts?: Opts<TSTypeElement> | null): node is TSTypeElement;
declare function isTSType(node: Node | null | undefined, opts?: Opts<TSType> | null): node is TSType;
declare function isTSBaseType(node: Node | null | undefined, opts?: Opts<TSBaseType> | null): node is TSBaseType;
/**
 * @deprecated Use `isNumericLiteral`
 */
declare function isNumberLiteral(node: Node | null | undefined, opts?: Opts<NumberLiteral> | null): boolean;
/**
 * @deprecated Use `isRegExpLiteral`
 */
declare function isRegexLiteral(node: Node | null | undefined, opts?: Opts<RegexLiteral> | null): boolean;
/**
 * @deprecated Use `isRestElement`
 */
declare function isRestProperty(node: Node | null | undefined, opts?: Opts<RestProperty> | null): boolean;
/**
 * @deprecated Use `isSpreadElement`
 */
declare function isSpreadProperty(node: Node | null | undefined, opts?: Opts<SpreadProperty> | null): boolean;
/**
 * @deprecated Use `isImportOrExportDeclaration`
 */
declare function isModuleDeclaration(node: Node | null | undefined, opts?: Opts<ModuleDeclaration> | null): node is ImportOrExportDeclaration;

interface BaseComment {
    value: string;
    start?: number;
    end?: number;
    loc?: SourceLocation;
    ignore?: boolean;
    type: "CommentBlock" | "CommentLine";
}
interface Position {
    line: number;
    column: number;
    index: number;
}
interface CommentBlock extends BaseComment {
    type: "CommentBlock";
}
interface CommentLine extends BaseComment {
    type: "CommentLine";
}
type Comment = CommentBlock | CommentLine;
interface SourceLocation {
    start: Position;
    end: Position;
    filename: string;
    identifierName: string | undefined | null;
}
interface BaseNode {
    type: Node["type"];
    leadingComments?: Comment[] | null;
    innerComments?: Comment[] | null;
    trailingComments?: Comment[] | null;
    start?: number | null;
    end?: number | null;
    loc?: SourceLocation | null;
    range?: [number, number];
    extra?: Record<string, unknown>;
}
type CommentTypeShorthand = "leading" | "inner" | "trailing";
type Node = AnyTypeAnnotation | ArgumentPlaceholder | ArrayExpression | ArrayPattern | ArrayTypeAnnotation | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BigIntLiteral | BinaryExpression | BindExpression | BlockStatement | BooleanLiteral | BooleanLiteralTypeAnnotation | BooleanTypeAnnotation | BreakStatement | CallExpression | CatchClause | ClassAccessorProperty | ClassBody | ClassDeclaration | ClassExpression | ClassImplements | ClassMethod | ClassPrivateMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | ContinueStatement | DebuggerStatement | DecimalLiteral | DeclareClass | DeclareExportAllDeclaration | DeclareExportDeclaration | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareOpaqueType | DeclareTypeAlias | DeclareVariable | DeclaredPredicate | Decorator | Directive | DirectiveLiteral | DoExpression | DoWhileStatement | EmptyStatement | EmptyTypeAnnotation | EnumBooleanBody | EnumBooleanMember | EnumDeclaration | EnumDefaultedMember | EnumNumberBody | EnumNumberMember | EnumStringBody | EnumStringMember | EnumSymbolBody | ExistsTypeAnnotation | ExportAllDeclaration | ExportDefaultDeclaration | ExportDefaultSpecifier | ExportNamedDeclaration | ExportNamespaceSpecifier | ExportSpecifier | ExpressionStatement | File | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | FunctionTypeAnnotation | FunctionTypeParam | GenericTypeAnnotation | Identifier | IfStatement | Import | ImportAttribute | ImportDeclaration | ImportDefaultSpecifier | ImportExpression | ImportNamespaceSpecifier | ImportSpecifier | IndexedAccessType | InferredPredicate | InterfaceDeclaration | InterfaceExtends | InterfaceTypeAnnotation | InterpreterDirective | IntersectionTypeAnnotation | JSXAttribute | JSXClosingElement | JSXClosingFragment | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXFragment | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXOpeningFragment | JSXSpreadAttribute | JSXSpreadChild | JSXText | LabeledStatement | LogicalExpression | MemberExpression | MetaProperty | MixedTypeAnnotation | ModuleExpression | NewExpression | Noop | NullLiteral | NullLiteralTypeAnnotation | NullableTypeAnnotation | NumberLiteral | NumberLiteralTypeAnnotation | NumberTypeAnnotation | NumericLiteral | ObjectExpression | ObjectMethod | ObjectPattern | ObjectProperty | ObjectTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalCallExpression | OptionalIndexedAccessType | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelinePrimaryTopicReference | PipelineTopicExpression | Placeholder | PrivateName | Program | QualifiedTypeIdentifier | RecordExpression | RegExpLiteral | RegexLiteral | RestElement | RestProperty | ReturnStatement | SequenceExpression | SpreadElement | SpreadProperty | StaticBlock | StringLiteral | StringLiteralTypeAnnotation | StringTypeAnnotation | Super | SwitchCase | SwitchStatement | SymbolTypeAnnotation | TSAnyKeyword | TSArrayType | TSAsExpression | TSBigIntKeyword | TSBooleanKeyword | TSCallSignatureDeclaration | TSConditionalType | TSConstructSignatureDeclaration | TSConstructorType | TSDeclareFunction | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSExpressionWithTypeArguments | TSExternalModuleReference | TSFunctionType | TSImportEqualsDeclaration | TSImportType | TSIndexSignature | TSIndexedAccessType | TSInferType | TSInstantiationExpression | TSInterfaceBody | TSInterfaceDeclaration | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSMethodSignature | TSModuleBlock | TSModuleDeclaration | TSNamedTupleMember | TSNamespaceExportDeclaration | TSNeverKeyword | TSNonNullExpression | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSParameterProperty | TSParenthesizedType | TSPropertySignature | TSQualifiedName | TSRestType | TSSatisfiesExpression | TSStringKeyword | TSSymbolKeyword | TSThisType | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeLiteral | TSTypeOperator | TSTypeParameter | TSTypeParameterDeclaration | TSTypeParameterInstantiation | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword | TaggedTemplateExpression | TemplateElement | TemplateLiteral | ThisExpression | ThisTypeAnnotation | ThrowStatement | TopicReference | TryStatement | TupleExpression | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameter | TypeParameterDeclaration | TypeParameterInstantiation | TypeofTypeAnnotation | UnaryExpression | UnionTypeAnnotation | UpdateExpression | V8IntrinsicIdentifier | VariableDeclaration | VariableDeclarator | Variance | VoidTypeAnnotation | WhileStatement | WithStatement | YieldExpression;
interface ArrayExpression extends BaseNode {
    type: "ArrayExpression";
    elements: Array<null | Expression | SpreadElement>;
}
interface AssignmentExpression extends BaseNode {
    type: "AssignmentExpression";
    operator: string;
    left: LVal | OptionalMemberExpression;
    right: Expression;
}
interface BinaryExpression extends BaseNode {
    type: "BinaryExpression";
    operator: "+" | "-" | "/" | "%" | "*" | "**" | "&" | "|" | ">>" | ">>>" | "<<" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | ">" | "<" | ">=" | "<=" | "|>";
    left: Expression | PrivateName;
    right: Expression;
}
interface InterpreterDirective extends BaseNode {
    type: "InterpreterDirective";
    value: string;
}
interface Directive extends BaseNode {
    type: "Directive";
    value: DirectiveLiteral;
}
interface DirectiveLiteral extends BaseNode {
    type: "DirectiveLiteral";
    value: string;
}
interface BlockStatement extends BaseNode {
    type: "BlockStatement";
    body: Array<Statement>;
    directives: Array<Directive>;
}
interface BreakStatement extends BaseNode {
    type: "BreakStatement";
    label?: Identifier | null;
}
interface CallExpression extends BaseNode {
    type: "CallExpression";
    callee: Expression | Super | V8IntrinsicIdentifier;
    arguments: Array<Expression | SpreadElement | ArgumentPlaceholder>;
    optional?: boolean | null;
    typeArguments?: TypeParameterInstantiation | null;
    typeParameters?: TSTypeParameterInstantiation | null;
}
interface CatchClause extends BaseNode {
    type: "CatchClause";
    param?: Identifier | ArrayPattern | ObjectPattern | null;
    body: BlockStatement;
}
interface ConditionalExpression extends BaseNode {
    type: "ConditionalExpression";
    test: Expression;
    consequent: Expression;
    alternate: Expression;
}
interface ContinueStatement extends BaseNode {
    type: "ContinueStatement";
    label?: Identifier | null;
}
interface DebuggerStatement extends BaseNode {
    type: "DebuggerStatement";
}
interface DoWhileStatement extends BaseNode {
    type: "DoWhileStatement";
    test: Expression;
    body: Statement;
}
interface EmptyStatement extends BaseNode {
    type: "EmptyStatement";
}
interface ExpressionStatement extends BaseNode {
    type: "ExpressionStatement";
    expression: Expression;
}
interface File extends BaseNode {
    type: "File";
    program: Program;
    comments?: Array<CommentBlock | CommentLine> | null;
    tokens?: Array<any> | null;
}
interface ForInStatement extends BaseNode {
    type: "ForInStatement";
    left: VariableDeclaration | LVal;
    right: Expression;
    body: Statement;
}
interface ForStatement extends BaseNode {
    type: "ForStatement";
    init?: VariableDeclaration | Expression | null;
    test?: Expression | null;
    update?: Expression | null;
    body: Statement;
}
interface FunctionDeclaration extends BaseNode {
    type: "FunctionDeclaration";
    id?: Identifier | null;
    params: Array<Identifier | Pattern | RestElement>;
    body: BlockStatement;
    generator: boolean;
    async: boolean;
    declare?: boolean | null;
    predicate?: DeclaredPredicate | InferredPredicate | null;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
    typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
interface FunctionExpression extends BaseNode {
    type: "FunctionExpression";
    id?: Identifier | null;
    params: Array<Identifier | Pattern | RestElement>;
    body: BlockStatement;
    generator: boolean;
    async: boolean;
    predicate?: DeclaredPredicate | InferredPredicate | null;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
    typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
interface Identifier extends BaseNode {
    type: "Identifier";
    name: string;
    decorators?: Array<Decorator> | null;
    optional?: boolean | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
interface IfStatement extends BaseNode {
    type: "IfStatement";
    test: Expression;
    consequent: Statement;
    alternate?: Statement | null;
}
interface LabeledStatement extends BaseNode {
    type: "LabeledStatement";
    label: Identifier;
    body: Statement;
}
interface StringLiteral extends BaseNode {
    type: "StringLiteral";
    value: string;
}
interface NumericLiteral extends BaseNode {
    type: "NumericLiteral";
    value: number;
}
/**
 * @deprecated Use `NumericLiteral`
 */
interface NumberLiteral extends BaseNode {
    type: "NumberLiteral";
    value: number;
}
interface NullLiteral extends BaseNode {
    type: "NullLiteral";
}
interface BooleanLiteral extends BaseNode {
    type: "BooleanLiteral";
    value: boolean;
}
interface RegExpLiteral extends BaseNode {
    type: "RegExpLiteral";
    pattern: string;
    flags: string;
}
/**
 * @deprecated Use `RegExpLiteral`
 */
interface RegexLiteral extends BaseNode {
    type: "RegexLiteral";
    pattern: string;
    flags: string;
}
interface LogicalExpression extends BaseNode {
    type: "LogicalExpression";
    operator: "||" | "&&" | "??";
    left: Expression;
    right: Expression;
}
interface MemberExpression extends BaseNode {
    type: "MemberExpression";
    object: Expression | Super;
    property: Expression | Identifier | PrivateName;
    computed: boolean;
    optional?: boolean | null;
}
interface NewExpression extends BaseNode {
    type: "NewExpression";
    callee: Expression | Super | V8IntrinsicIdentifier;
    arguments: Array<Expression | SpreadElement | ArgumentPlaceholder>;
    optional?: boolean | null;
    typeArguments?: TypeParameterInstantiation | null;
    typeParameters?: TSTypeParameterInstantiation | null;
}
interface Program extends BaseNode {
    type: "Program";
    body: Array<Statement>;
    directives: Array<Directive>;
    sourceType: "script" | "module";
    interpreter?: InterpreterDirective | null;
}
interface ObjectExpression extends BaseNode {
    type: "ObjectExpression";
    properties: Array<ObjectMethod | ObjectProperty | SpreadElement>;
}
interface ObjectMethod extends BaseNode {
    type: "ObjectMethod";
    kind: "method" | "get" | "set";
    key: Expression | Identifier | StringLiteral | NumericLiteral | BigIntLiteral;
    params: Array<Identifier | Pattern | RestElement>;
    body: BlockStatement;
    computed: boolean;
    generator: boolean;
    async: boolean;
    decorators?: Array<Decorator> | null;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
    typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
interface ObjectProperty extends BaseNode {
    type: "ObjectProperty";
    key: Expression | Identifier | StringLiteral | NumericLiteral | BigIntLiteral | DecimalLiteral | PrivateName;
    value: Expression | PatternLike;
    computed: boolean;
    shorthand: boolean;
    decorators?: Array<Decorator> | null;
}
interface RestElement extends BaseNode {
    type: "RestElement";
    argument: LVal;
    decorators?: Array<Decorator> | null;
    optional?: boolean | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
/**
 * @deprecated Use `RestElement`
 */
interface RestProperty extends BaseNode {
    type: "RestProperty";
    argument: LVal;
    decorators?: Array<Decorator> | null;
    optional?: boolean | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
interface ReturnStatement extends BaseNode {
    type: "ReturnStatement";
    argument?: Expression | null;
}
interface SequenceExpression extends BaseNode {
    type: "SequenceExpression";
    expressions: Array<Expression>;
}
interface ParenthesizedExpression extends BaseNode {
    type: "ParenthesizedExpression";
    expression: Expression;
}
interface SwitchCase extends BaseNode {
    type: "SwitchCase";
    test?: Expression | null;
    consequent: Array<Statement>;
}
interface SwitchStatement extends BaseNode {
    type: "SwitchStatement";
    discriminant: Expression;
    cases: Array<SwitchCase>;
}
interface ThisExpression extends BaseNode {
    type: "ThisExpression";
}
interface ThrowStatement extends BaseNode {
    type: "ThrowStatement";
    argument: Expression;
}
interface TryStatement extends BaseNode {
    type: "TryStatement";
    block: BlockStatement;
    handler?: CatchClause | null;
    finalizer?: BlockStatement | null;
}
interface UnaryExpression extends BaseNode {
    type: "UnaryExpression";
    operator: "void" | "throw" | "delete" | "!" | "+" | "-" | "~" | "typeof";
    argument: Expression;
    prefix: boolean;
}
interface UpdateExpression extends BaseNode {
    type: "UpdateExpression";
    operator: "++" | "--";
    argument: Expression;
    prefix: boolean;
}
interface VariableDeclaration extends BaseNode {
    type: "VariableDeclaration";
    kind: "var" | "let" | "const" | "using" | "await using";
    declarations: Array<VariableDeclarator>;
    declare?: boolean | null;
}
interface VariableDeclarator extends BaseNode {
    type: "VariableDeclarator";
    id: LVal;
    init?: Expression | null;
    definite?: boolean | null;
}
interface WhileStatement extends BaseNode {
    type: "WhileStatement";
    test: Expression;
    body: Statement;
}
interface WithStatement extends BaseNode {
    type: "WithStatement";
    object: Expression;
    body: Statement;
}
interface AssignmentPattern extends BaseNode {
    type: "AssignmentPattern";
    left: Identifier | ObjectPattern | ArrayPattern | MemberExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression;
    right: Expression;
    decorators?: Array<Decorator> | null;
    optional?: boolean | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
interface ArrayPattern extends BaseNode {
    type: "ArrayPattern";
    elements: Array<null | PatternLike | LVal>;
    decorators?: Array<Decorator> | null;
    optional?: boolean | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
interface ArrowFunctionExpression extends BaseNode {
    type: "ArrowFunctionExpression";
    params: Array<Identifier | Pattern | RestElement>;
    body: BlockStatement | Expression;
    async: boolean;
    expression: boolean;
    generator?: boolean;
    predicate?: DeclaredPredicate | InferredPredicate | null;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
    typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
interface ClassBody extends BaseNode {
    type: "ClassBody";
    body: Array<ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty | ClassAccessorProperty | TSDeclareMethod | TSIndexSignature | StaticBlock>;
}
interface ClassExpression extends BaseNode {
    type: "ClassExpression";
    id?: Identifier | null;
    superClass?: Expression | null;
    body: ClassBody;
    decorators?: Array<Decorator> | null;
    implements?: Array<TSExpressionWithTypeArguments | ClassImplements> | null;
    mixins?: InterfaceExtends | null;
    superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
    typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
interface ClassDeclaration extends BaseNode {
    type: "ClassDeclaration";
    id?: Identifier | null;
    superClass?: Expression | null;
    body: ClassBody;
    decorators?: Array<Decorator> | null;
    abstract?: boolean | null;
    declare?: boolean | null;
    implements?: Array<TSExpressionWithTypeArguments | ClassImplements> | null;
    mixins?: InterfaceExtends | null;
    superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
    typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
interface ExportAllDeclaration extends BaseNode {
    type: "ExportAllDeclaration";
    source: StringLiteral;
    /** @deprecated */
    assertions?: Array<ImportAttribute> | null;
    attributes?: Array<ImportAttribute> | null;
    exportKind?: "type" | "value" | null;
}
interface ExportDefaultDeclaration extends BaseNode {
    type: "ExportDefaultDeclaration";
    declaration: TSDeclareFunction | FunctionDeclaration | ClassDeclaration | Expression;
    exportKind?: "value" | null;
}
interface ExportNamedDeclaration extends BaseNode {
    type: "ExportNamedDeclaration";
    declaration?: Declaration | null;
    specifiers: Array<Export