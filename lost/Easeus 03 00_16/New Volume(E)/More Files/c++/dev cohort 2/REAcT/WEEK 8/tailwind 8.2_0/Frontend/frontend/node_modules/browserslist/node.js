AssignmentPattern = {\n    type: \"AssignmentPattern\",\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.AssignmentPattern;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function arrayPattern(\n  elements: Array<null | t.PatternLike | t.LVal>,\n): t.ArrayPattern {\n  const node: t.ArrayPattern = {\n    type: \"ArrayPattern\",\n    elements,\n  };\n  const defs = NODE_FIELDS.ArrayPattern;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nexport function arrowFunctionExpression(\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  body: t.BlockStatement | t.Expression,\n  async: boolean = false,\n): t.ArrowFunctionExpression {\n  const node: t.ArrowFunctionExpression = {\n    type: \"ArrowFunctionExpression\",\n    params,\n    body,\n    async,\n    expression: null,\n  };\n  const defs = NODE_FIELDS.ArrowFunctionExpression;\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function classBody(\n  body: Array<\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty\n    | t.TSDeclareMethod\n    | t.TSIndexSignature\n    | t.StaticBlock\n  >,\n): t.ClassBody {\n  const node: t.ClassBody = {\n    type: \"ClassBody\",\n    body,\n  };\n  const defs = NODE_FIELDS.ClassBody;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function classExpression(\n  id: t.Identifier | null | undefined = null,\n  superClass: t.Expression | null | undefined = null,\n  body: t.ClassBody,\n  decorators: Array<t.Decorator> | null = null,\n): t.ClassExpression {\n  const node: t.ClassExpression = {\n    type: \"ClassExpression\",\n    id,\n    superClass,\n    body,\n    decorators,\n  };\n  const defs = NODE_FIELDS.ClassExpression;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nexport function classDeclaration(\n  id: t.Identifier | null | undefined = null,\n  superClass: t.Expression | null | undefined = null,\n  body: t.ClassBody,\n  decorators: Array<t.Decorator> | null = null,\n): t.ClassDeclaration {\n  const node: t.ClassDeclaration = {\n    type: \"ClassDeclaration\",\n    id,\n    superClass,\n    body,\n    decorators,\n  };\n  const defs = NODE_FIELDS.ClassDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nexport function exportAllDeclaration(\n  source: t.StringLiteral,\n): t.ExportAllDeclaration {\n  const node: t.ExportAllDeclaration = {\n    type: \"ExportAllDeclaration\",\n    source,\n  };\n  const defs = NODE_FIELDS.ExportAllDeclaration;\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nexport function exportDefaultDeclaration(\n  declaration:\n    | t.TSDeclareFunction\n    | t.FunctionDeclaration\n    | t.ClassDeclaration\n    | t.Expression,\n): t.ExportDefaultDeclaration {\n  const node: t.ExportDefaultDeclaration = {\n    type: \"ExportDefaultDeclaration\",\n    declaration,\n  };\n  const defs = NODE_FIELDS.ExportDefaultDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  return node;\n}\nexport function exportNamedDeclaration(\n  declaration: t.Declaration | null = null,\n  specifiers: Array<\n    t.ExportSpecifier | t.ExportDefaultSpecifier | t.ExportNamespaceSpecifier\n  > = [],\n  source: t.StringLiteral | null = null,\n): t.ExportNamedDeclaration {\n  const node: t.ExportNamedDeclaration = {\n    type: \"ExportNamedDeclaration\",\n    declaration,\n    specifiers,\n    source,\n  };\n  const defs = NODE_FIELDS.ExportNamedDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nexport function exportSpecifier(\n  local: t.Identifier,\n  exported: t.Identifier | t.StringLiteral,\n): t.ExportSpecifier {\n  const node: t.ExportSpecifier = {\n    type: \"ExportSpecifier\",\n    local,\n    exported,\n  };\n  const defs = NODE_FIELDS.ExportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nexport function forOfStatement(\n  left: t.VariableDeclaration | t.LVal,\n  right: t.Expression,\n  body: t.Statement,\n  _await: boolean = false,\n): t.ForOfStatement {\n  const node: t.ForOfStatement = {\n    type: \"ForOfStatement\",\n    left,\n    right,\n    body,\n    await: _await,\n  };\n  const defs = NODE_FIELDS.ForOfStatement;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.await, node, \"await\", _await);\n  return node;\n}\nexport function importDeclaration(\n  specifiers: Array<\n    t.ImportSpecifier | t.ImportDefaultSpecifier | t.ImportNamespaceSpecifier\n  >,\n  source: t.StringLiteral,\n): t.ImportDeclaration {\n  const node: t.ImportDeclaration = {\n    type: \"ImportDeclaration\",\n    specifiers,\n    source,\n  };\n  const defs = NODE_FIELDS.ImportDeclaration;\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nexport function importDefaultSpecifier(\n  local: t.Identifier,\n): t.ImportDefaultSpecifier {\n  const node: t.ImportDefaultSpecifier = {\n    type: \"ImportDefaultSpecifier\",\n    local,\n  };\n  const defs = NODE_FIELDS.ImportDefaultSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nexport function importNamespaceSpecifier(\n  local: t.Identifier,\n): t.ImportNamespaceSpecifier {\n  const node: t.ImportNamespaceSpecifier = {\n    type: \"ImportNamespaceSpecifier\",\n    local,\n  };\n  const defs = NODE_FIELDS.ImportNamespaceSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nexport function importSpecifier(\n  local: t.Identifier,\n  imported: t.Identifier | t.StringLiteral,\n): t.ImportSpecifier {\n  const node: t.ImportSpecifier = {\n    type: \"ImportSpecifier\",\n    local,\n    imported,\n  };\n  const defs = NODE_FIELDS.ImportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.imported, node, \"imported\", imported, 1);\n  return node;\n}\nexport function importExpression(\n  source: t.Expression,\n  options: t.Expression | null = null,\n): t.ImportExpression {\n  const node: t.ImportExpression = {\n    type: \"ImportExpression\",\n    source,\n    options,\n  };\n  const defs = NODE_FIELDS.ImportExpression;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.options, node, \"options\", options, 1);\n  return node;\n}\nexport function metaProperty(\n  meta: t.Identifier,\n  property: t.Identifier,\n): t.MetaProperty {\n  const node: t.MetaProperty = {\n    type: \"MetaProperty\",\n    meta,\n    property,\n  };\n  const defs = NODE_FIELDS.MetaProperty;\n  validate(defs.meta, node, \"meta\", meta, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  return node;\n}\nexport function classMethod(\n  kind: \"get\" | \"set\" | \"method\" | \"constructor\" | undefined = \"method\",\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  params: Array<\n    t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty\n  >,\n  body: t.BlockStatement,\n  computed: boolean = false,\n  _static: boolean = false,\n  generator: boolean = false,\n  async: boolean = false,\n): t.ClassMethod {\n  const node: t.ClassMethod = {\n    type: \"ClassMethod\",\n    kind,\n snippets) => {
    const { _, n } = snippets;
    return (`${index}if${_}(k${_}!==${_}'default')${_}{${n}` +
        copyOwnPropertyLiveBinding(t, index + t, snippets) +
        `${index}}${n}`);
};
const copyOwnPropertyLiveBinding = (t, index, { _, cnst, getDirectReturnFunction, n }) => {
    const [left, right] = getDirectReturnFunction([], {
        functionReturn: true,
        lineBreakIndent: null,
        name: null
    });
    return (`${index}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +
        `${index}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +
        `${index}${t}enumerable:${_}true,${n}` +
        `${index}${t}get:${_}${left}e[k]${right}${n}` +
        `${index}});${n}`);
};
const copyPropertyLiveBinding = (t, index, { _, cnst, getDirectReturnFunction, n }) => {
    const [left, right] = getDirectReturnFunction([], {
        functionReturn: true,
        lineBreakIndent: null,
        name: null
    });
    return (`${index}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +
        `${index}if${_}(d)${_}{${n}` +
        `${index}${t}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +
        `${index}${t}${t}enumerable:${_}true,${n}` +
        `${index}${t}${t}get:${_}${left}e[k]${right}${n}` +
        `${index}${t}});${n}` +
        `${index}}${n}`);
};
const copyPropertyStatic = (_t, index, { _, n }) => `${index}n[k]${_}=${_}e[k];${n}`;
const getFrozen = (freeze, fragment) => freeze ? `Object.freeze(${fragment})` : fragment;
const getWithToStringTag = (symbols, fragment, { _, getObject }) => symbols
    ? `Object.defineProperty(${fragment},${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)})`
    : fragment;
const HELPER_NAMES = Object.keys(HELPER_GENERATORS);
function getToStringTagValue(getObject) {
    return getObject([['value', "'Module'"]], {
        lineBreakIndent: null
    });
}

class Literal extends NodeBase {
    deoptimizeArgumentsOnInteractionAtPath() { }
    getLiteralValueAtPath(path) {
        if (path.length > 0 ||
            // unknown literals can also be null but do not start with an "n"
            (this.value === null && this.scope.context.code.charCodeAt(this.start) !== 110) ||
            typeof this.value === 'bigint' ||
            // to support shims for regular expressions
            this.scope.context.code.charCodeAt(this.start) === 47) {
            return UnknownValue;
        }
        return this.value;
    }
    getReturnExpressionWhenCalledAtPath(path) {
        if (path.length !== 1)
            return UNKNOWN_RETURN_EXPRESSION;
        return getMemberReturnExpressionWhenCalled(this.members, path[0]);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        switch (interaction.type) {
            case INTERACTION_ACCESSED: {
                return path.length > (this.value === null ? 0 : 1);
            }
            case INTERACTION_ASSIGNED: {
                return true;
            }
            case INTERACTION_CALLED: {
                if (this.included &&
                    this.value instanceof RegExp &&
                    (this.value.global || this.value.sticky)) {
                    return true;
                }
                return (path.length !== 1 ||
                    hasMemberEffectWhenCalled(this.members, path[0], interaction, context));
            }
        }
    }
    initialise() {
        super.initialise();
        this.members = getLiteralMembersForValue(this.value);
    }
    parseNode(esTreeNode) {
        this.value = esTreeNode.value;
        this.regex = esTreeNode.regex;
        return super.parseNode(esTreeNode);
    }
    render(code) {
        if (typeof this.value === 'string') {
            code.indentExclusionRanges.push([this.start + 1, this.end - 1]);
        }
    }
}

function getChainElementLiteralValueAtPath(element, object, path, recursionTracker, origin) {
    if ('getLiteralValueAtPathAsChainElement' in object) {
        const calleeValue = object.getLiteralValueAtPathAsChainElement(EMPTY_PATH, SHAR