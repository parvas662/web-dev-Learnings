zer.getOptimizedDepId(depInfo);
  }
  if (!importer) return;
  let idPkgDir;
  const nestedIdMatch = `> ${id}`;
  for (const optimizedData of metadata.depInfoList) {
    if (!optimizedData.src) continue;
    if (!optimizedData.id.endsWith(nestedIdMatch)) continue;
    if (idPkgDir == null) {
      const pkgName = getNpmPackageName(id);
      if (!pkgName) break;
      idPkgDir = resolvePackageData(
        pkgName,
        importer,
        preserveSymlinks,
        packageCache
      )?.dir;
      if (idPkgDir == null) break;
      idPkgDir = normalizePath$3(idPkgDir);
    }
    if (optimizedData.src.startsWith(withTrailingSlash(idPkgDir))) {
      return depsOptimizer.getOptimizedDepId(optimizedData);
    }
  }
}
function resolvePackageEntry(id, { dir, data, setResolvedCache, getResolvedCache }, options) {
  const { file: idWithoutPostfix, postfix } = splitFileAndPostfix(id);
  const cached = getResolvedCache(".", options);
  if (cached) {
    return cached + postfix;
  }
  try {
    let entryPoint;
    if (data.exports) {
      entryPoint = resolveExportsOrImports(data, ".", options, "exports");
    }
    if (!entryPoint) {
      for (const field of options.mainFields) {
        if (field === "browser") {
          entryPoint = tryResolveBrowserEntry(dir, data, options);
          if (entryPoint) {
            break;
          }
        } else if (typeof data[field] === "string") {
          entryPoint = data[field];
          break;
        }
      }
    }
    entryPoint ||= data.main;
    const entryPoints = entryPoint ? [entryPoint] : ["index.js", "index.json", "index.node"];
    for (let entry of entryPoints) {
      let skipPackageJson = false;
      if (options.mainFields[0] === "sass" && !options.extensions.includes(path$d.extname(entry))) {
        entry = "";
        skipPackageJson = true;
      } else {
        const { browser: browserField } = data;
        if (options.mainFields.includes("browser") && isObject$2(browserField)) {
          entry = mapWithBrowserField(entry, browserField) || entry;
        }
      }
      const entryPointPath = path$d.join(dir, entry);
      const resolvedEntryPoint = tryFsResolve(
        entryPointPath,
        options,
        true,
        skipPackageJson
      );
      if (resolvedEntryPoint) {
        debug$e?.(
          `[package entry] ${colors$1.cyan(idWithoutPostfix)} -> ${colors$1.dim(
            resolvedEntryPoint
          )}${postfix !== "" ? ` (postfix: ${postfix})` : ""}`
        );
        setResolvedCache(".", resolvedEntryPoint, options);
        return resolvedEntryPoint + postfix;
      }
    }
  } catch (e) {
    packageEntryFailure(id, e.message);
  }
  packageEntryFailure(id);
}
function packageEntryFailure(id, details) {
  const err = new Error(
    `Failed to resolve entry for package "${id}". The package may have incorrect main/module/exports specified in its package.json` + (details ? ": " + details : ".")
  );
  err.code = ERR_RESOLVE_PACKAGE_ENTRY_FAIL;
  throw err;
}
function resolveExportsOrImports(pkg, key, options, type) {
  const conditions = options.conditions.map((condition) => {
    if (condition === DEV_PROD_CONDITION) {
      return options.isProduction ? "production" : "development";
    }
    return condition;
  });
  if (options.isRequire) {
    conditions.push("require");
  } else {
    conditions.push("import");
  }
  const fn = type === "imports" ? f : o;
  const result = fn(pkg, key, { conditions, unsafe: true });
  return result ? result[0] : void 0;
}
function resolveDeepImport(id, { setResolvedCache, getResolvedCache, dir, data }, options) {
  const cache = getResolvedCache(id, options);
  if (cache) {
    return cache;
  }
  let relativeId = id;
  const { exports: exportsField, browser: browserField } = data;
  if (exportsField) {
    if (isObject$2(exportsField) && !Array.isArray(exportsField)) {
      const { file, postfix } = splitFileAndPostfix(relativeId);
      const exportsId = resolveExportsOrImports(data, file, options, "exports");
      if (exportsId !== void 0) {
        relativeId = exportsId + postfix;
      } else {
        relativeId = void 0;
      }
    } else {
      relativeId = void 0;
    }
    if (!relativeId) {
      throw new Error(
        `Package subpath '${relativeId}' is not defined by "exports" in ${path$d.join(dir, "package.json")}.`
      );
    }
  } else if (options.mainFields.includes("browser") && isObject$2(browserField)) {
    const { file, postfix } = splitFileAndPostfix(relativeId);
    const mapped = mapWithBrowserField(file, browserField);
    if (mapped) {
      relativeId = mapped + postfix;
    } else if (mapped === false) {
      setResolvedCache(id, browserExternalId, options);
      return browserExternalId;
    }
  }
  if (relativeId) {
    const resolved = tryFsResolve(
      path$d.join(dir, relativeId),
      options,
      !exportsField
      // try index only if no exports field
    );
    if (resolved) {
      debug$e?.(
        `[node/deep-import] ${colors$1.cyan(id)} -> ${colors$1.dim(resolved)}`
      );
      setResolvedCache(id, resolved, options);
      return resolved;
    }
  }
}
function tryResolveBrowserMapping(id, importer, options, isFilePath, externalize) {
  let res;
  const pkg = importer && findNearestPackageData(path$d.dirname(importer), options.packageCache);
  if (pkg && isObject$2(pkg.data.browser)) {
    const mapId = isFilePath ? "./" + slash$1(path$d.relative(pkg.dir, id)) : id;
    const browserMappedPath = mapWithBrowserField(mapId, pkg.data.browser);
    if (browserMappedPath) {
      if (res = bareImportRE.test(browserMappedPath) ? tryNodeResolve(
        browserMappedPath,
        importer,
        options,
        void 0,
        void 0
      )?.id : tryFsResolve(path$d.join(pkg.dir, browserMappedPath), options)) {
        debug$e?.(`[browser mapped] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
        let result = { id: res };
        if (options.idOnly) {
          return result;
        }
        if (!options.scan && options.isBuild) {
          const resPkg = findNearestPackageData(
            path$d.dirname(res),
            options.packageCache
          );
          if (resPkg) {
            result = {
              id: res,
              moduleSideEffects: resPkg.hasSideEffects(res)
            };
          }
        }
        return externalize ? { ...result, external: true } : result;
      }
    } else if (browserMappedPath === false) {
      return browserExternalId;
    }
  }
}
function tryResolveBrowserEntry(dir, data, options) {
  const browserEntry = typeof data.browser === "string" ? data.browser : isObject$2(data.browser) && data.browser["."];
  if (browserEntry) {
    if (!options.isRequire && options.mainFields.includes("module") && typeof data.module === "string" && data.module !== browserEntry) {
      const resolvedBrowserEntry = tryFsResolve(
        path$d.join(dir, browserEntry),
        options
      );
      if (resolvedBrowserEntry) {
        const content = fs__default.readFileSync(resolvedBrowserEntry, "utf-8");
        if (hasESMSyntax(content)) {
          return browserEntry;
        } else {
          return data.module;
        }
      }
    } else {
      return browserEntry;
    }
  }
}
function mapWithBrowserField(relativePathInPkgDir, map) {
  const normalizedPath = path$d.posix.normalize(relativePathInPkgDir);
  for (const key in map) {
    const normalizedKey = path$d.posix.normalize(key);
    if (normalizedPath === normalizedKey || equalWithoutSuffix(normalizedPath, normalizedKey, ".js") || equalWithoutSuffix(normalizedPath, normalizedKey, "/index.js")) {
      return map[key];
    }
  }
}
function equalWithoutSuffix(path2, key, suffix) {
  return key.endsWith(suffix) && key.slice(0, -suffix.length) === path2;
}
function tryResolveRealFile(file, preserveSymlinks) {
  const stat = tryStatSync(file);
  if (stat?.isFile()) return getRealPath(file, preserveSymlinks);
}
function tryResolveRealFileWithExtensions(filePath, extensions, preserveSymlinks) {
  for (const ext of extensions) {
    const res = tryResolveRealFile(filePath + ext, preserveSymlinks);
    if (res) return res;
  }
}
function tryResolveRealFileOrType(file, preserveSymlinks) {
  const fileStat = tryStatSync(file);
  if (fileStat?.isFile()) {
    return { path: getRealPath(file, preserveSymlinks), type: "file" };
  }
  if (fileStat?.isDirectory()) {
    return { type: "directory" };
  }
  return;
}
function getRealPath(resolved, preserveSymlinks) {
  if (!preserveSymlinks) {
    resolved = safeRealpathSync(resolved);
  }
  return normalizePath$3(resolved);
}
function isDirectory(path2) {
  const stat = tryStatSync(path2);
  return stat?.isDirectory() ?? false;
}

const externalWithConversionNamespace = "vite:dep-pre-bundle:external-conversion";
const convertedExternalPrefix = "vite-dep-pre-bundle-external:";
const cjsExternalFacadeNamespace = "vite:cjs-external-facade";
const nonFacadePrefix = "vite-cjs-external-facade:";
const externalTypes = [
  "css",
  // supported pre-processor types
  "less",
  "sass",
  "scss",
  "styl",
  "stylus",
  "pcss",
  "postcss",
  // wasm
  "wasm",
  // known SFC types
  "vue",
  "svelte",
  "marko",
  "astro",
  "imba",
  // JSX/TSX may be configured to be compiled differently from how esbuild
  // handles it by default, so exclude them as well
  "jsx",
  "tsx",
  ...KNOWN_ASSET_TYPES
];
function esbuildDepPlugin(environment, qualified, external) {
  const { isProduction } = environment.config;
  const { extensions } = environment.config.optimizeDeps;
  const allExternalTypes = extensions ? externalTypes.filter((type) => !extensions?.includes("." + type)) : externalTypes;
  const esmPackageCache = /* @__PURE__ */ new Map();
  const cjsPackageCache = /* @__PURE__ */ new Map();
  const _resolve = createBackCompatIdResolver(environment.getTopLevelConfig(), {
    asSrc: false,
    scan: true,
    packageCache: esmPackageCache
  });
  const _resolveRequire = createBackCompatIdResolver(
    environment.getTopLevelConfig(),
    {
      asSrc: false,
      isRequire: true,
      scan: true,
      packageCache: cjsPackageCache
    }
  );
  const resolve = (id, importer, kind, resolveDir) => {
    let _importer;
    {
      _importer = importer in qualified ? qualified[importer] : importer;
    }
    const resolver = kind.startsWith("require") ? _resolveRequire : _resolve;
    return resolver(environment, id, _importer);
  };
  const resolveResult = (id, resolved) => {
    if (resolved.startsWith(browserExternalId)) {
      return {
        path: id,
        namespace: "browser-external"
      };
    }
    if (resolved.startsWith(optionalPeerDepId)) {
      return {
        path: resolved,
        namespace: "optional-peer-dep"
      };
    }
    if (environment.config.consumer === "server" && isBuiltin(resolved)) {
      return;
    }
    if (isExternalUrl(resolved)) {
      return {
        path: resolved,
        external: true
      };
    }
    return {
      path: path$d.resolve(resolved)
    };
  };
  return {
    name: "vite:dep-pre-bundle",
    setup(build) {
      build.onEnd(() => {
        esmPackageCache.clear();
        cjsPackageCache.clear();
      });
      build.onResolve(
        {
          filter: new RegExp(
            `\\.(` + allExternalTypes.join("|") + `)(\\?.*)?$`
          )
        },
        async ({ path: id, importer, kind }) => {
          if (id.startsWith(convertedExternalPrefix)) {
            return {
              path: id.slice(convertedExternalPrefix.length),
              external: true
            };
          }
          const resolved = await resolve(id, importer, kind);
          if (resolved) {
            if (JS_TYPES_RE.test(resolved)) {
              return {
                path: resolved,
                external: false
              };
            }
            if (kind === "require-call") {
              return {
                path: resolved,
                namespace: externalWithConversionNamespace
              };
            }
            return {
              path: resolved,
              external: true
            };
          }
        }
      );
      build.onLoad(
        { filter: /./, namespace: externalWithConversionNamespace },
        (args) => {
          const modulePath = `"${convertedExternalPrefix}${args.path}"`;
          return {
            contents: isCSSRequest(args.path) && !isModuleCSSRequest(args.path) ? `import ${modulePath};` : `export { default } from ${modulePath};export * from ${modulePath};`,
            loader: "js"
          };
        }
      );
      function resolveEntry(id) {
        const flatId = flattenId(id);
        if (flatId in qualified) {
          return {
            path: qualified[flatId]
          };
        }
      }
      build.onResolve(
        { filter: /^[\w@][^:]/ },
        async ({ path: id, importer, kind }) => {
          if (moduleListContains(external, id)) {
            return {
              path: id,
              external: true
            };
          }
          let entry;
          if (!importer) {
            if (entry = resolveEntry(id)) return entry;
            const aliased = await _resolve(environment, id, void 0, true);
            if (aliased && (entry = resolveEntry(aliased))) {
              return entry;
            }
          }
          const resolved = await resolve(id, importer, kind);
          if (resolved) {
            return resolveResult(id, resolved);
          }
        }
      );
      build.onLoad(
        { filter: /.*/, namespace: "browser-external" },
        ({ path: path2 }) => {
          if (isProduction) {
            return {
              contents: "module.exports = {}"
            };
          } else {
            return {
              // Return in CJS to intercept named imports. Use `Object.create` to
              // create the Proxy in the prototype to workaround esbuild issue. Why?
              //
              // In short, esbuild cjs->esm flow:
              // 1. Create empty object using `Object.create(Object.getPrototypeOf(module.exports))`.
              // 2. Assign props of `module.exports` to the object.
              // 3. Return object for ESM use.
              //
              // If we do `module.exports = new Proxy({}, {})`, step 1 returns empty object,
              // step 2 does nothing as there's no props for `module.exports`. The final object
              // is just an empty object.
              //
              // Creating the Proxy in the prototype satisfies step 1 immediately, which means
              // the returned object is a Proxy that we can intercept.
              //
              // Note: Skip keys that are accessed by esbuild and browser devtools.
              contents: `module.exports = Object.create(new Proxy({}, {
  get(_, key) {
    if (
      key !== '__esModule' &&
      key !== '__proto__' &&
      key !== 'constructor' &&
      key !== 'splice'
    ) {
      console.warn(\`Module "${path2}" has been externalized for browser compatibility. Cannot access "${path2}.\${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.\`)
    }
  }
}))`
            };
          }
        }
      );
      build.onLoad(
        { filter: /.*/, namespace: "optional-peer-dep" },
        ({ path: path2 }) => {
          if (isProduction) {
            return {
              contents: "module.exports = {}"
            };
          } else {
            const [, peerDep, parentDep] = path2.split(":");
            return {
              contents: `throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}". Is it installed?\`)`
            };
          }
        }
      );
    }
  };
}
const matchesEntireLine = (text) => `^${escapeRegex(text)}$`;
function esbuildCjsExternalPlugin(externals, platform) {
  return {
    name: "cjs-external",
    setup(build) {
      const filter = new RegExp(externals.map(matchesEntireLine).join("|"));
      build.onResolve({ filter: new RegExp(`^${nonFacadePrefix}`) }, (args) => {
        return {
          path: args.path.slice(nonFacadePrefix.length),
          external: true
        };
      });
      build.onResolve({ filter }, (args) => {
        if (args.kind === "require-call" && platform !== "node") {
          return {
            path: args.path,
            namespace: cjsExternalFacadeNamespace
          };
        }
        return {
          path: args.path,
          external: true
        };
      });
      build.onLoad(
        { filter: /.*/, namespace: cjsExternalFacadeNamespace },
        (args) => ({
          contents: `import * as m from ${JSON.stringify(
            nonFacadePrefix + args.path
          )};module.exports = m;`
        })
      );
    }
  };
}

const environmentColors = [
  colors$1.blue,
  colors$1.magenta,
  colors$1.green,
  colors$1.gray
];
function getDefaultResolvedEnvironmentOptions(config) {
  return {
    define: config.define,
    resolve: config.resolve,
    consumer: "server",
    optimizeDeps: config.optimizeDeps,
    dev: config.dev,
    build: config.build
  };
}
class PartialEnvironment {
  name;
  getTopLevelConfig() {
    return this._topLevelConfig;
  }
  config;
  /**
   * @deprecated use environment.config instead
   **/
  get options() {
    return this._options;
  }
  logger;
  /**
   * @internal
   */
  _options;
  /**
   * @internal
   */
  _topLevelConfig;
  constructor(name, topLevelConfig, options = topLevelConfig.environments[name]) {
    if (!/^[\w$]+$/.test(name)) {
      throw new Error(
        `Invalid environment name "${name}". Environment names must only contain alphanumeric characters and "$", "_".`
      );
    }
    this.name = name;
    this._topLevelConfig = topLevelConfig;
    this._options = options;
    this.config = new Proxy(
      options,
      {
        get: (target, prop) => {
          if (prop === "logger") {
            return this.logger;
          }
          if (prop in target) {
            return this._options[prop];
          }
          return this._topLevelConfig[prop];
        }
      }
    );
    const environment = colors$1.dim(`(${this.name})`);
    const colorIndex = [...this.name].reduce((acc, c) => acc + c.charCodeAt(0), 0) % environmentColors.length;
    const infoColor = environmentColors[colorIndex || 0];
    this.logger = {
      get hasWarned() {
        return topLevelConfig.logger.hasWarned;
      },
      info(msg, opts) {
        return topLevelConfig.logger.info(msg, {
          ...opts,
          environment: infoColor(environment)
        });
      },
      warn(msg, opts) {
        return topLevelConfig.logger.warn(msg, {
          ...opts,
          environment: colors$1.yellow(environment)
        });
      },
      warnOnce(msg, opts) {
        return topLevelConfig.logger.warnOnce(msg, {
          ...opts,
          environment: colors$1.yellow(environment)
        });
      },
      error(msg, opts) {
        return topLevelConfig.logger.error(msg, {
          ...opts,
          environment: colors$1.red(environment)
        });
      },
      clearScreen(type) {
        return topLevelConfig.logger.clearScreen(type);
      },
      hasErrorLogged(error) {
        return topLevelConfig.logger.hasErrorLogged(error);
      }
    };
  }
}
class BaseEnvironment extends PartialEnvironment {
  get plugins() {
    if (!this._plugins)
      throw new Error(
        `${this.name} environment.plugins called before initialized`
      );
    return this._plugins;
  }
  /**
   * @internal
   */
  _plugins;
  /**
   * @internal
   */
  _initiated = false;
  constructor(name, config, options = config.environments[name]) {
    super(name, config, options);
  }
}

// Copyright 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023 Simon Lydell
// License: MIT.
var HashbangComment, Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]?|[^\/[\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu;
Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu;
StringLiteral = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y;
NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
Template = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y;
WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu;
LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
MultiLineComment = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y;
SingleLineComment = /\/\/.*/y;
HashbangComment = /^#!.*/;
JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y;
JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu;
JSXString = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y;
JSXText = /[^<>{}]+/y;
TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
Newline = RegExp(LineTerminatorSequence.source);
var jsTokens_1 = function*(input, {jsx = false} = {}) {
	var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;
	({length} = input);
	lastIndex = 0;
	lastSignificantToken = "";
	stack = [
		{tag: "JS"}
	];
	braces = [];
	parenNesting = 0;
	postfixIncDec = false;
	if (match = HashbangComment.exec(input)) {
		yield ({
			type: "HashbangComment",
			value: match[0]
		});
		lastIndex = match[0].length;
	}
	while (lastIndex < length) {
		mode = stack[stack.length - 1];
		switch (mode.tag) {
			case "JS":
			case "JSNonExpressionParen":
			case "InterpolationInTemplate":
			case "InterpolationInJSX":
				if (input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
					RegularExpressionLiteral.lastIndex = lastIndex;
					if (match = RegularExpressionLiteral.exec(input)) {
						lastIndex = RegularExpressionLiteral.lastIndex;
						lastSignificantToken = match[0];
						postfixIncDec = true;
						yield ({
							type: "RegularExpressionLiteral",
							value: match[0],
							closed: match[1] !== void 0 && match[1] !== "\\"
						});
						continue;
					}
				}
				Punctuator.lastIndex = lastIndex;
				if (match = Punctuator.exec(input)) {
					punctuator = match[0];
					nextLastIndex = Punctuator.lastIndex;
					nextLastSignificantToken = punctuator;
					switch (punctuator) {
						case "(":
							if (lastSignificantToken === "?NonExpressionParenKeyword") {
								stack.push({
									tag: "JSNonExpressionParen",
									nesting: parenNesting
								});
							}
							parenNesting++;
							postfixIncDec = false;
							break;
						case ")":
							parenNesting--;
							postfixIncDec = true;
							if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
								stack.pop();
								nextLastSignificantToken = "?NonExpressionParenEnd";
								postfixIncDec = false;
							}
							break;
						case "{":
							Punctuator.lastIndex = 0;
							isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
							braces.push(isExpression);
							postfixIncDec = false;
							break;
						case "}":
							switch (mode.tag) {
								case "InterpolationInTemplate":
									if (braces.length === mode.nesting) {
										Template.lastIndex = lastIndex;
										match = Template.exec(input);
										lastIndex = Template.lastIndex;
										lastSignificantToken = match[0];
										if (match[1] === "${") {
											lastSignificantToken = "?InterpolationInTemplate";
											postfixIncDec = false;
											yield ({
												type: "TemplateMiddle",
												value: match[0]
											});
										} else {
											stack.pop();
											postfixIncDec = true;
											yield ({
												type: "TemplateTail",
												value: match[0],
												closed: match[1] === "`"
											});
										}
										continue;
									}
									break;
								case "InterpolationInJSX":
									if (braces.length === mode.nesting) {
										stack.pop();
										lastIndex += 1;
										lastSignificantToken = "}";
										yield ({
											type: "JSXPunctuator",
											value: "}"
										});
										continue;
									}
							}
							postfixIncDec = braces.pop();
							nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
							break;
						case "]":
							postfixIncDec = true;
							break;
						case "++":
						case "--":
							nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
							break;
						case "<":
							if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
								stack.push({tag: "JSXTag"});
								lastIndex += 1;
								lastSignificantToken = "<";
								yield ({
									type: "JSXPunctuator",
									value: punctuator
								});
								continue;
							}
							postfixIncDec = false;
							break;
						default:
							postfixIncDec = false;
					}
					lastIndex = nextLastIndex;
					lastSignificantToken = nextLastSignificantToken;
					yield ({
						type: "Punctuator",
						value: punctuator
					});
					continue;
				}
				Identifier.lastIndex = lastIndex;
				if (match = Identifier.exec(input)) {
					lastIndex = Identifier.lastIndex;
					nextLastSignificantToken = match[0];
					switch (match[0]) {
						case "for":
						case "if":
						case "while":
						case "with":
							if (lastSignificantToken !== "." && lastSignificantToken !== "?.") {
								nextLastSignificantToken = "?NonExpressionParenKeyword";
							}
					}
					lastSignificantToken = nextLastSignificantToken;
					postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
					yield ({
						type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
						value: match[0]
					});
					continue;
				}
				StringLiteral.lastIndex = lastIndex;
				if (match = StringLiteral.exec(input)) {
					lastIndex = StringLiteral.lastIndex;
					lastSignificantToken = match[0];
					postfixIncDec = true;
					yield ({
						type: "StringLiteral",
						value: match[0],
						closed: match[2] !== void 0
					});
					continue;
				}
				NumericLiteral.lastIndex = lastIndex;
				if (match = NumericLiteral.exec(input)) {
					lastIndex = NumericLiteral.lastIndex;
					lastSignificantToken = match[0];
					postfixIncDec = true;
					yield ({
						type: "NumericLiteral",
						value: match[0]
					});
					continue;
				}
				Template.lastIndex = lastIndex;
				if (match = Template.exec(input)) {
					lastIndex = Template.lastIndex;
					lastSignificantToken = match[0];
					if (match[1] === "${") {
						lastSignificantToken = "?InterpolationInTemplate";
						stack.push({
							tag: "InterpolationInTemplate",
							nesting: braces.length
						});
						postfixIncDec = false;
						yield ({
							type: "TemplateHead",
							value: match[0]
						});
					} else {
						postfixIncDec = true;
						yield ({
							type: "NoSubstitutionTemplate",
							value: match[0],
							closed: match[1] === "`"
						});
					}
					continue;
				}
				break;
			case "JSXTag":
			case "JSXTagEnd":
				JSXPunctuator.lastIndex = lastIndex;
				if (match = JSXPunctuator.exec(input)) {
					lastIndex = JSXPunctuator.lastIndex;
					nextLastSignificantToken = match[0];
					switch (match[0]) {
						case "<":
							stack.push({tag: "JSXTag"});
							break;
						case ">":
							stack.pop();
							if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
								nextLastSignificantToken = "?JSX";
								postfixIncDec = true;
							} else {
								stack.push({tag: "JSXChildren"});
							}
							break;
						case "{":
							stack.push({
								tag: "InterpolationInJSX",
								nesting: braces.length
							});
							nextLastSignificantToken = "?InterpolationInJSX";
							postfixIncDec = false;
							break;
						case "/":
							if (lastSignificantToken === "<") {
								stack.pop();
								if (stack[stack.length - 1].tag === "JSXChildren") {
									stack.pop();
								}
								stack.push({tag: "JSXTagEnd"});
							}
					}
					lastSignificantToken = nextLastSignificantToken;
					yield ({
						type: "JSXPunctuator",
						value: match[0]
					});
					continue;
				}
				JSXIdentifier.lastIndex = lastIndex;
				if (match = JSXIdentifier.exec(input)) {
					lastIndex = JSXIdentifier.lastIndex;
					lastSignificantToken = match[0];
					yield ({
						type: "JSXIdentifier",
						value: match[0]
					});
					continue;
				}
				JSXString.lastIndex = lastIndex;
				if (match = JSXString.exec(input)) {
					lastIndex = JSXString.lastIndex;
					lastSignificantToken = match[0];
					yield ({
						type: "JSXString",
						value: match[0],
						closed: match[2] !== void 0
					});
					continue;
				}
				break;
			case "JSXChildren":
				JSXText.lastIndex = lastIndex;
				if (match = JSXText.exec(input)) {
					lastIndex = JSXText.lastIndex;
					lastSignificantToken = match[0];
					yield ({
						type: "JSXText",
						value: match[0]
					});
					continue;
				}
				switch (input[lastIndex]) {
					case "<":
						stack.push({tag: "JSXTag"});
						lastIndex++;
						lastSignificantToken = "<";
						yield ({
							type: "JSXPunctuator",
							value: "<"
						});
						continue;
					case "{":
						stack.push({
							tag: "InterpolationInJSX",
							nesting: braces.length
						});
						lastIndex++;
						lastSignificantToken = "?InterpolationInJSX";
						postfixIncDec = false;
						yield ({
							type: "JSXPunctuator",
							value: "{"
						});
						continue;
				}
		}
		WhiteSpace.lastIndex = lastIndex;
		if (match = WhiteSpace.exec(input)) {
			lastIndex = WhiteSpace.lastIndex;
			yield ({
				type: "WhiteSpace",
				value: match[0]
			});
			continue;
		}
		LineTerminatorSequence.lastIndex = lastIndex;
		if (match = LineTerminatorSequence.exec(input)) {
			lastIndex = LineTerminatorSequence.lastIndex;
			postfixIncDec = false;
			if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
				lastSignificantToken = "?NoLineTerminatorHere";
			}
			yield ({
				type: "LineTerminatorSequence",
				value: match[0]
			});
			continue;
		}
		MultiLineComment.lastIndex = lastIndex;
		if (match = MultiLineComment.exec(input)) {
			lastIndex = MultiLineComment.lastIndex;
			if (Newline.test(match[0])) {
				postfixIncDec = false;
				if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
					lastSignificantToken = "?NoLineTerminatorHere";
				}
			}
			yield ({
				type: "MultiLineComment",
				value: match[0],
				closed: match[1] !== void 0
			});
			continue;
		}
		SingleLineComment.lastIndex = lastIndex;
		if (match = SingleLineComment.exec(input)) {
			lastIndex = SingleLineComment.lastIndex;
			postfixIncDec = false;
			yield ({
				type: "SingleLineComm