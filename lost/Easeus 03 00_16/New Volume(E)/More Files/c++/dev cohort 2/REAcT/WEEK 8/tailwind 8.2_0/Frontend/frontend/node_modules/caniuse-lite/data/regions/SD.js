turns {boolean} `true` if the node is `??`.
 */
function isCoalesceExpression(node) {
    return node.type === "LogicalExpression" && node.operator === "??";
}

/**
 * Check if given two nodes are the pair of a logical expression and a coalesce expression.
 * @param {ASTNode} left A node to check.
 * @param {ASTNode} right Another node to check.
 * @returns {boolean} `true` if the two nodes are the pair of a logical expression and a coalesce expression.
 */
function isMixedLogicalAndCoalesceExpressions(left, right) {
    return (
        (isLogicalExpression(left) && isCoalesceExpression(right)) ||
            (isCoalesceExpression(left) && isLogicalExpression(right))
    );
}

/**
 * Checks if the given operator is a logical assignment operator.
 * @param {string} operator The operator to check.
 * @returns {boolean} `true` if the operator is a logical assignment operator.
 */
function isLogicalAssignmentOperator(operator) {
    return LOGICAL_ASSIGNMENT_OPERATORS.has(operator);
}

/**
 * Get the colon token of the given SwitchCase node.
 * @param {ASTNode} node The SwitchCase node to get.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {Token} The colon token of the node.
 */
function getSwitchCaseColonToken(node, sourceCode) {
    if (node.test) {
        return sourceCode.getTokenAfter(node.test, isColonToken);
    }
    return sourceCode.getFirstToken(node, 1);
}

/**
 * Gets ESM module export name represented by the given node.
 * @param {ASTNode} node `Identifier` or string `Literal` node in a position
 * that represents a module export name:
 *   - `ImportSpecifier#imported`
 *   - `ExportSpecifier#local` (if it is a re-export from another module)
 *   - `ExportSpecifier#exported`
 *   - `ExportAllDeclaration#exported`
 * @returns {string} The module export name.
 */
function getModuleExportName(node) {
    if (node.type === "Identifier") {
        return node.name;
    }

    // string literal
    return node.value;
}

/**
 * Returns literal's value converted to the Boolean type
 * @param {ASTNode} node any `Literal` node
 * @returns {boolean | null} `true` when node is truthy, `false` when node is falsy,
 *  `null` when it cannot be determined.
 */
function getBooleanValue(node) {
    if (node.value === null) {

        /*
         * it might be a null literal or bigint/regex literal in unsupported environments .
         * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es5.md#regexpliteral
         * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es2020.md#bigintliteral
         */

        if (node.raw === "null") {
            return false;
        }

        // regex is always truthy
        if (typeof node.regex === "object") {
            return true;
        }

        return null;
    }

    return !!node.value;
}

/**
 * Checks if a branch node of LogicalExpression short circuits the whole condition
 * @param {ASTNode} node The branch of main condition which needs to be checked
 * @param {string} operator The operator of the main LogicalExpression.
 * @returns {boolean} true when condition short circuits whole condition
 */
function isLogicalIdentity(node, operator) {
    switch (node.type) {
        case "Literal":
            return (operator === "||" && getBooleanValue(node) === true) ||
                  (operator === "&&" && getBooleanValue(node) === false);

        case "UnaryExpression":
            return (operator === "&&" && node.operator === "void");

        case "LogicalExpression":

            /*
             * handles `a && false || b`
             * `false` is an identity element of `&&` but not `||`
             */
            return operator === node.operator &&
                    (
                        isLogicalIdentity(node.left, operator) ||
                        isLogicalIdentity(node.right, operator)
                    );

        case "AssignmentExpression":
            return ["||=", "&&="].includes(node.operator) &&
               operator === node.operator.slice(0, -1) &&
               isLogicalIdentity(node.right, operator);

       // no default
    }
    return false;
}

/**
 * Checks if an identifier is a reference to a global variable.
 * @param {Scope} scope The scope in which the identifier is referenced.
 * @param {ASTNode} node An identifier node to check.
 * @returns {boolean} `true` if the identifier is a reference to a global variable.
 */
function isReferenceToGlobalVariable(scope, node) {
    const reference = scope.references.find(ref => ref.identifier === node);

    return Boolean(
        reference &&
            reference.resolved &&
            reference.resolved.scope.type === "global" &&
            reference.resolved.defs.length === 0
    );
}


/**
 * Checks if a  node has a constant truthiness value.
 * @param {Scope} scope Scope in which the node appears.
 * @param {ASTNode} node The AST node to check.
 * @param {boolean} inBooleanPosition `true` if checking the test of a
 * condition. `false` in all other cases. When `false`, checks if -- for
 * both string and number -- if coerced to that type, the value will
 * be constant.
 * @returns {boolean} true when node's truthiness is constant
 * @private
 */
function isConstan