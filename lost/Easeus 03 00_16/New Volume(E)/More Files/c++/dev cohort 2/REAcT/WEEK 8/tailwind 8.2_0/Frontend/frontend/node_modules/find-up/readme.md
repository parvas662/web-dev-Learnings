{

                        /*
                         * The assignment was followed by another assignment in the same segment.
                         * Therefore, there is no need to check the next segment.
                         */
                        continue;
                    }

                    // Check subsequent segments.
                    for (const subsequentSegment of getSubsequentSegments()) {
                        if (isIdentifierUsedInSegment(subsequentSegment.segment, reference.identifier)) {
                            if (
                                subsequentSegment.assignment &&
                                isIdentifierEvaluatedAfterAssignment(subsequentSegment.assignment, reference.identifier)
                            ) {

                                // There was another assignment before the reference. Therefore, it has not been used yet.
                                continue;
                            }

                            // It is used
                            return;
                        }
                    }
                }
                context.report({
                    node: targetAssignment.identifier,
                    messageId: "unnecessaryAssignment"
                });
            }

            // Verify that each assignment in the code path is used.
            for (const assignments of target.assignments.values()) {
                assignments.sort((a, b) => a.identifier.range[0] - b.identifier.range[0]);
                for (const assignment of assignments) {
                    verifyAssignmentIsUsed(assignment, assignments);
                }
            }
        }

        return {
            onCodePathStart(codePath, node) {
                const scope = sourceCode.getScope(node);

                scopeStack = {
                    upper: scopeStack,
                    codePath,
                    scope,
                    segments: Object.create(null),
                    currentSegments: new Set(),
                    assignments: new Map()
                };
                codePathStartScopes.add(scopeStack.scope);
            },
            onCodePathEnd() {
                verify(scopeStack);

                scopeStack = scopeStack.upper;
            },
            onCodePathSegmentStart(segment) {
                const segmentInfo = { segment, first: null, last: null };

                scopeStack.segments[segment.id] = segmentInfo;
                scopeStack.currentSegments.add(segment);
            },
            onCodePathSegmentEnd(segment) {
                scopeStack.currentSegments.delete(segment);
            },
            Identifier(node) {
                for (const segment of scopeStack.currentSegments) {
                    const segmentInfo = scopeStack.segments[segment.id];

                    if (!segmentInfo.first) {
                        segmentInfo.first = node;
                    }
                    segmentInfo.last = node;
                }
            },
            ":matches(VariableDeclarator[init!=null], AssignmentExpression, UpdateExpression):exit"(node) {
                if (scopeStack.currentSegments.size === 0) {

                    // Ignore unreachable segments
                    return;
                }

                const assignments = scopeStack.assignments;

                let pattern;
                let expression = null;

                if (node.type === "VariableDeclarator") {
                    pattern = node.id;
                    expression = node.init;
                } else if (node.type === "AssignmentExpression") {
                    pattern = node.left;
                    expression = node.right;
                } else { // UpdateExpression
                    pattern = node.argument;
                }

                for (const identifier of extractIdentifiersFromPattern(pattern)) {
                    const scope = sourceCode.getScope(identifier);

                    /