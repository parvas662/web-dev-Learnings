 }

            /*
             * We won't try to reason about +, -, ~, or delete
             * In theory, for the mathematical operators, we could look at the
             * argument and try to determine if it coerces to a constant numeric
             * value.
             */
            return false;
        case "NewExpression": // Objects might have custom `.valueOf` or `.toString`.
            return false;
        case "CallExpression": {
            if (node.callee.type === "Identifier" &&
                node.callee.name === "Boolean" &&
                isReferenceToGlobalVariable(scope, node.callee)
            ) {
                return node.arguments.length === 0 || isConstant(scope, node.arguments[0], true);
            }
            return false;
        }
        case "Literal": // True or false, literals never change
            return true;
        case "Identifier":
            return node.name === "undefined" && isReferenceToGlobalVariable(scope, node);
        case "TemplateLiteral":

            /*
             * In theory we could try to check if the quasi are sufficient to
             * prove that the expression will always be true, but it would be
             * tricky to get right. For example: `000.${foo}000`
             */
            return node.expressions.length === 0;
        case "AssignmentExpression":
            if (node.operator === "=") {
                return hasConstantLooseBooleanComparison(scope, node.right);
            }

            /*
             * Handling short-circuiting assignment operators would require
             * walking the scope. We won't attempt that (for now...)
             *
             * The remaining assignment expressions all result in a numeric or
             * string (non-nullish) values which could be truthy or falsy:
             *   "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&="
             */
            return false;
        case "SequenceExpression": {
            const last = node.expressions.at(-1);

            return hasConstantLooseBooleanComparison(scope, last);
        }
        case "JSXElement": // ESLint has a policy of not assuming any specific JSX behavior.
        case "JSXFragment":
            return false;
        default:
            return false;
    }
}


/**
 * Test if an AST node will always give the same result when _strictly_ compared
 * to a boolean value. This can happen if the expression can never be boolean, or
 * if it is always the same boolean value.
 * @param {Scope} scope The scope in which the node was found.
 * @param {ASTNode} node The node to test
 * @returns {boolean} Will `node` always give the same result when compared to a
 * static boolean value?
 */
function hasConstantStrictBooleanComparison(scope, node) {
    switch (node.type) {
        case "ObjectExpression": // Objects are not booleans
        case "ArrayExpression": // Arrays are not booleans
        case "ArrowFunctionExpression": // Functions are not booleans
        case "FunctionExpression":
        case "ClassExpression": // Classes are not booleans
        case "NewExpression": // Objects are not booleans
        case "TemplateLiteral": // Strings are not booleans
        case "Literal": // True, false, or not boolean, literals never change.
        case "UpdateExpression": // Numbers are not booleans
            return true;
        case "BinaryExpression":
            return NUMERIC_OR_STRING_BINARY_OPERATORS.has(node.operator);
        case "UnaryExpression": {
            if (node.operator === "delete") {
                return false;
            }
            if (node.operator === "!") {
                return isConstant(scope, node.argument, true);
            }

            /*
             * The remaining operators return either strings or numbers, neither
             * of which are boolean.
             */
            return true;
        }
        case "SequenceExpression": {
            const last = node.expressions.at(-1);

            return hasConstantStrictBooleanComparison(scope, last);
        }
        case "Identifier":
            return node.name === "undefined" && isReferenceToGlobalVariable(scope, node);
        case "AssignmentExpression":
            if (node.operator === "=") {
                return hasConstantStrictBooleanComparison(scope, node.right);
            }

            /*
             * Handling short-circuiting assignment operators would require
             * walking the scope. We won't attempt that (for now...)
             */
            if (isLogicalAssignmentOperator(node.operator)) {
                return false;
            }

            /*
             * The remaining assignment expressions all result in either a number
             * or a string, neither of which can ever be boolean.
             */
            return true;
        case "CallExpression": {
            if (node.callee.type !== "Identifier") {
                return false;
            }
            const functionName = node.callee.name;

            if (
                (functionName === "String" || functionName === "Number") &&
                isReferenceToGlobalVariable(scope, node.callee)
            ) {
                return true;
            }
            if (functionName === "Boolean" && isReferenceToGlobalVariable(scope, node.callee)) {
                return (
                    node.arguments.length === 0 || isConstant(scope, node.arguments[0], true));
            }
            return false;
        }
        case "JSXElement": // ESLint has a policy of not assuming any specific JSX behavior.
        case "JSXFragment":
            return false;
        default:
            return false;
    }
}

/**
 * Test if an AST node will always result in a newly constructed object
 * @param {Scope} scope The scope in which the node was found.
 * @param {ASTNode} node The node to test
 * @returns {boolean} Will `node` always be new?
 */
function isAlwaysNew(scope, node) {
    switch (node.type) {
        case "ObjectExpression":
        case "ArrayExpression":
        case "ArrowFunctionExpression":
        case "FunctionExpression":
        case "ClassExpression":
            return true;
        case "NewExpression": {
            if (node.callee.type !== "Identifier") {
                return false;
            }

            /*
             * All the built-in constructors are always new, but
             * user-defined constructors could return a sentinel
             * object.
             *
             * Catching these is especially useful for primitive constructors
             * which return boxed values, a surprising gotcha' in JavaScript.
             */
            return Object.hasOwn(ECMASCRIPT_GLOBALS, node.callee.name) &&
              isReferenceToGlobalVariable(scope, node.callee);
        }
        case "Literal":

            // Regular expressions are objects, and thus always new
            return typeof node.regex === "object";
        case "SequenceExpression": {
            const last = node.expressions.at(-1);

            return isAlwaysNew(scope, last);
        }
        case "AssignmentExpression":
            if (node.operator === "=") {
                return isAlwaysNew(scope, node.right);
            }
            return false;
        case "ConditionalExpression":
            return isAlwaysNew(scope, node.consequent) && isAlwaysNew(scope, node.alternate);
        case "JSXElement": // ESLint has a policy of not assuming any specific JSX behavior.
        case "JSXFragment":
            return false;
        default:
            return false;
    }
}

/**
 * Checks if one operand will cause the result to be constant.
 * @param {Scope} scope Scope in which the expression was found.
 * @param {ASTNode} a One side of the expression
 * @param {ASTNode} b The other side of the expression
 * @param {string} operator The binary expression operator
 * @returns {ASTNode | null} The node which will cause the expression to have a constant result.
 */
function findBinaryExpressionConstantOperand(scope, a, b, operator) {
    if (operator === "==" || operator === "!=") {
        if (
            (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b, false)) ||
            (isStaticBoolean(scope, a) && hasConstantLooseBooleanComparison(scope, b))
        ) {
            return b;
        }
    } else if (operator === "===" || operator === "!==") {
        if (
            (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b, false)) ||
            (isStaticBoolean(scope, a) && hasConstantStrictBooleanComparison(scope, b))
        ) {
            return b;
        }
    }
    return null;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        type: "problem",
        docs: {
            description: "Disallow expressions where the operation doesn't affect the value",
            recommended: true,
            url: "https://eslint.org/docs/latest/rules/no-constant-binary-expression"
        },
        schema: [],
        messages: {
            constantBinaryOperand: "Unexpected constant binary expression. Compares constantly with the {{otherSide}}-hand side of the `{{operator}}`.",
            constantShortCircuit: "Unexpected constant {{property}} on the left-hand side of a `{{operator}}` expression.",
            alwaysNew: "Unexpected comparison to newly constructed object. These two values can never be equal.",
            bothAlwaysNew: "Unexpected comparison of two newly constructed objects. These two values can never be equal."
        }
    },

    create(context) {
        const sourceCode = context.sourceCode;

        return {
            LogicalExpression(node) {
                const { operator, left } = node;
                const scope = sourceCode.getScope(node);

                if ((operator === "&&" || operator === "||") && isConstant(scope, left, true)) {
                    context.report({ node: left, messageId: "constantShortCircuit", data: { property: "truthiness", operator } });
                } else if (operator === "??" && hasConstantNullishness(scope, left, false)) {
                    context.report({ node: left, messageId: "constantShortCircuit", data: { property: "nullishness", operator } });
                }
            },
            BinaryExpression(node) {
                const scope = sourceCode.getScope(node);
                const { right, left, operator } = node;
                const rightConstantOperand = findBinaryExpressionConstantOperand(scope, left, right, operator);
                const leftConstantOperand = findBinaryExpressionConstantOperand(scope, right, left, operator);

                if (rightConstantOperand) {
                    context.report({ node: rightConstantOperand, messageId: "constantBinaryOperand", data: { operator, otherSide: "left" } });
                } else if (leftConstantOperand) {
                    context.report({ node: leftConstantOperand, messageId: "constantBinaryOperand", data: { operator, otherSide: "right" } });
                } else if (operator === "===" || operator === "!==") {
                    if (isAlwaysNew(scope, left)) {
                        context.report({ node: left, messageId: "alwaysNew" });
                    } else if (isAlwaysNew(scope, right)) {
                        context.report({ node: right, messageId: "alwaysNew" });
                    }
                } else if (operator === "==" || operator === "!=") {

                    /*
                     * If both sides are "new", then both sides are objects and
                     * therefore they will be compared by reference even with `==`
                     * equality.
                     */
                    if (isAlwaysNew(scope, left) && isAlwaysNew(scope, right)) {
                        context.report({ node: left, messageId: "bothAlwaysNew" });
                    }
                }

            }

            /*
             * In theory we could handle short-circuiting assignment operators,
             * for some constant values, but that would require walking the
             * scope to find the value of the variable being assigned. This is
             * dependant on https://github.com/eslint/eslint/issues/13776
             *
             * AssignmentExpression() {},
             */
        };
    }
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            SSING_CHAR', 'Missing directives-end indicator line');
            doc.range = [0, endOffset, endOffset];
            this.decorate(doc, false);
            yield doc;
        }
    }
}

export { Composer };
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /**
 * @fileoverview Rule to flag use of console object
 * @author Nicholas C. Zakas
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        type: "suggestion",

        defaultOptions: [{}],

        docs: {
            description: "Disallow the use of `console`",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/no-console"
        },

        schema: [
            {
                type: "object",
                properties: {
                    allow: {
                        type: "array",
                        items: {
                            type: "string"
                        },
                        minItems: 1,
                        uniqueItems: true
                    }
                },
                additionalProperties: false
            }
        ],

        hasSuggestions: true,

        messages: {
            unexpected: "Unexpected console statement.",
            removeConsole: "Remove the console.{{ propertyName }}()."
        }
    },

    create(context) {
        const [{ allow: allowed = [] }] = context.options;
        const sourceCode = context.sourceCode;

        /**
         * Checks whether the given reference is 'console' or not.
         * @param {eslint-scope.Reference} reference The reference to check.
         * @returns {boolean} `true` if the reference is 'console'.
         */
        function isConsole(reference) {
            const id = reference.identifier;

            return id && id.name === "console";
        }

        /**
         * Checks whether the property name of the given MemberExpression node
         * is allowed by options or not.
         * @param {ASTNode} node The MemberExpression node to check.
         * @returns {boolean} `true` if the property name of the node is allowed.
         */
        function isAllowed(node) {
            const propertyName = astUtils.getStaticPropertyName(node);

            return propertyName && allowed.includes(propertyName);
        }

        /**
         * Checks whether the given reference is a member access which is not
         * allowed by options or not.
         * @param {eslint-scope.Reference} reference The reference to check.
         * @returns {boolean} `true` if the reference is a member access which
         *      is not allowed by options.
         */
        function isMemberAccessExceptAllowed(reference) {
            const node = reference.identifier;
            const parent = node.parent;

            return (
                parent.type === "MemberExpression" &&
                parent.object === node &&
                !isAllowed(parent)
            );
        }

        /**
         * Checks if removing the ExpressionStatement node will cause ASI to
         * break.
         * eg.
         * foo()
         * console.log();
         * [1, 2, 3].forEach(a => doSomething(a))
         *
         * Removing the console.log(); statement should leave two statements, but
         * here the two statements will become one because [ causes continuation after
         * foo().
         * @param {ASTNode} node The ExpressionStatement node to check.
         * @returns {boolean} `true` if ASI will break after removing the ExpressionStatement
         *      node.
         */
        function maybeAsiHazard(node) {
            const SAFE_TOKENS_BEFORE = /^[:;{]$/u; // One of :;{
            const UNSAFE_CHARS_AFTER = /^[-[(/+`]/u; // One of [(/+-`

            const tokenBefore = sourceCode.getTokenBefore(node);
            const tokenAfter = sourceCode.getTokenAfter(node);

            return (
                Boolean(tokenAfter) &&
                UNSAFE_CHARS_AFTER.test(tokenAfter.value) &&
                tokenAfter.value !== "++" &&
                tokenAfter.value !== "--" &&
                Boolean(tokenBefore) &&
                !SAFE_TOKENS_BEFORE.test(tokenBefore.value)
            );
        }

        /**
         * Checks if the MemberExpression node's parent.parent.parent is a
         * Program, BlockStatement, StaticBlock, or SwitchCase node. This check
         * is necessary to avoid providing a suggestion that might cause a syntax error.
         *
         * eg. if (a) console.log(b), removing console.log() here will lead to a
         *     syntax error.
         *     if (a) { console.log(b) }, removing console.log() here is acceptable.
         *
         * Additionally, it checks if the callee of the CallExpression node is
         * the node itself.
         *
         * eg. foo(console.log), cannot provide a suggestion here.
         * @param {ASTNode} node The MemberExpression node to check.
         * @returns {boolean} `true` if a suggestion can be provided for a node.
         */
        function canProvideSuggestions(node) {
            return (
                node.parent.type === "CallExpression" &&
                node.parent.callee === node &&
                node.parent.parent.type === "ExpressionStatement" &&
                astUtils.STATEMENT_LIST_PARENTS.has(node.parent.parent.parent.type) &&
                !maybeAsiHazard(node.parent.parent)
            );
        }

        /**
         * Reports the given reference as a violation.
         * @param {eslint-scope.Reference} reference The reference to report.
         * @returns {void}
         */
        function report(reference) {
            const node = reference.identifier.parent;

            const propertyName = astUtils.getStaticPropertyName(node);

            context.report({
                node,
                loc: node.loc,
                messageId: "unexpected",
                suggest: canProvideSuggestions(node)
                    ? [{
                        messageId: "removeConsole",
                        data: { propertyName },
                        fix(fixer) {
                            return fixer.remove(node.parent.parent);
                        }
                    }]
                    : []
            });
        }

        return {
            "Program:exit"(node) {
                const scope = sourceCode.getScope(node);
                const consoleVar = astUtils.getVariableByName(scope, "console");
                const shadowed = consoleVar && consoleVar.defs.length > 0;

                /*
                 * 'scope.through' includes all references to undefined
                 * variables. If the variable 'console' is not defined, it uses
                 * 'scope.through'.
                 */
                const references = consoleVar
                    ? consoleVar.references
                    : scope.through.filter(isConsole);

                if (!shadowed) {
                    references
                        .filter(isMemberAccessExceptAllowed)
                        .forEach(report);
                }
            }
        };
    }
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         "use strict";Object.defineProperty(exports, "__esModule", {value: true});var _index = require('../tokenizer/index');
var _types = require('../tokenizer/types');
var _base = require('../traverser/base');
var _expression = require('../traverser/expression');
var _flow = require('./flow');
var _typescript = require('./typescript');

/**
 * Common parser code for TypeScript and Flow.
 */

// An apparent conditional expression could actually be an optional parameter in an arrow function.
 function typedParseConditional(noIn) {
  // If we see ?:, this can't possibly be a valid conditional. typedParseParenItem will be called
  // later to finish off the arrow parameter. We also need to handle bare ? tok                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               13)

### Commits

- chore(release): 1.2.1 [`f4c7f02`](https://github.com/inspect-js/is-async-function/commit/f4c7f02ecb1ca02772890552797da3b39883ed43)

## [v1.2.0](https://github.com/inspect-js/is-async-function/compare/v1.1.5...v1.2.0) - 2016-10-27

### Merged

- Revert "Update arr-includes to version 2.0.0 ðŸš€" [`#12`](https://github.com/inspect-js/is-async-function/pull/12)
- chore(package): update arr-includes to version 2.0.0 [`#11`](https://github.com/inspect-js/is-async-function/pull/11)

### Commits

- feat(strict): introduce strict mode [`ef8526f`](https://github.com/inspect-js/is-async-function/commit/ef8526ffa8ba2b4cf37f6bd2dae21aee871e6e6a)
- docs(update): api docs [`739eb54`](https://github.com/inspect-js/is-async-function/commit/739eb5482ba560ad2de153a29fc16778f4d3ef3f)
- chore(release): 1.2.0 [`3222afe`](https://github.com/inspect-js/is-async-function/commit/3222afed47c9b5d2fa12490aff2d7c9887183ea2)

## [v1.1.5](https://github.com/inspect-js/is-async-function/compare/v1.1.4...v1.1.5) - 2016-09-21

### Commits

- chore(tests): simplify tests [`be112bb`](https://github.com/inspect-js/is-async-function/commit/be112bb3dec204f174bf745056b7c0fc7377aef5)
- Release v1.1.5 [`577d96c`](https://github.com/inspect-js/is-async-function/commit/577d96c9f0fb6288e6bc88d8e51703b98f19b20c)

## [v1.1.4](https://github.com/inspect-js/is-async-function/compare/v1.1.3...v1.1.4) - 2016-09-21

### Fixed

- chore(package): update deps, use lazy-cache - closes #10 [`#10`](https://github.com/inspect-js/is-async-function/issues/10)

### Commits

- chore(package/tests): update to use `mukla` instead of `assertit` lib [`83011b1`](https://github.com/inspect-js/is-async-function/commit/83011b1e2820e239c606d872468582f5a9249c47)
- chore(package): update npm scripts, add coveralls/standard/nyc to devDeps [`631acbd`](https://github.com/inspect-js/is-async-function/commit/631acbdcf9fd9aa6d56ac98e10f3092e7e5be485)
- chore(gitignore): update gitignore [`7f09f8f`](https://github.com/inspect-js/is-async-function/commit/7f09f8f40777879e70315dfeef0805755a44a293)
- chore(editorconfig): update editorconfig [`8bb8593`](https://github.com/inspect-js/is-async-function/commit/8bb85939f87e6738c5ca35b5e5f5d8cca67353c9)
- docs(readme): run verb to update readme [`cf15044`](https://github.com/inspect-js/is-async-function/commit/cf150446dc4e948f2629377d7f369824bfda8b3b)
- Release v1.1.4 [`41190e1`](https://github.com/inspect-js/is-async-function/commit/41190e1da3aeb787921b3ea5d834634295c31de8)

## [v1.1.3](https://github.com/inspect-js/is-async-function/compare/v1.1.2...v1.1.3) - 2016-04-21

### Merged

- chore(package): update is-match to version 0.4.1 [`#7`](https://github.com/inspect-js/is-async-function/pull/7)

### Commits

- use `common-callback-names` [`37c253f`](https://github.com/inspect-js/is-async-function/commit/37c253f9a34b68acd5651075a3f1b74cd30ed8fd)
- Release v1.1.3 [`f212193`](https://github.com/inspect-js/is-async-function/commit/f212193a00790ccae387e2d7a373076fcbbb9d8f)

## [v1.1.2](https://github.com/inspect-js/is-async-function/compare/v1.1.1...v1.1.2) - 2016-03-18

### Commits

- cleanup and update metadata [`e09ab8b`](https://github.com/inspect-js/is-async-function/commit/e09ab8b98e6aecd28d38ba4ff4c1f17c26549a06)
- update docs [`42920c6`](https://github.com/inspect-js/is-async-function/commit/42920c699f706fcf1048e0c039b335d7bbaf34ed)
- Release v1.1.2 [`19d77d6`](https://github.com/inspect-js/is-async-function/commit/19d77d6ba7abe87ecf4d2765cd8536fca140b3bd)

## [v1.1.1](https://github.com/inspect-js/is-async-function/compare/v1.1.0...v1.1.1) - 2016-03-18

### Commits

- run update [`27b21bf`](https://github.com/inspect-js/is-async-function/commit/27b21bf76254635d6c5c18f896b6f151938ae810)
- add docs [`ab38f94`](https://github.com/inspect-js/is-async-function/commit/ab38f947707182e0ea165e3bee90bd46b8dbfaf9)
- update docs [`90654c9`](https://github.com/inspect-js/is-async-function/commit/90654c93e8ff9d0cfd1443ae3609cd898b57ef11)
- refactor, allow passing custom array of argument names [`a1787c7`](https://github.com/inspect-js/is-async-function/commit/a1787c757f522cb5e1c568ec5270be14a38c4cc9)
- add related libs [`868f423`](https://github.com/inspect-js/is-async-function/commit/868f4235a449d610a87351e5a5070f42a0c6e7ce)
- Release v1.1.1 [`bc7d85e`](https://github.com/inspect-js/is-async-function/commit/bc7d85e2a115163d3b09f78be5196f21adce1a7c)
- update description [`ce2e97b`](https://github.com/inspect-js/is-async-function/commit/ce2e97b34762f2087699a5b9910e498ec7062090)

## [v1.1.0](https://github.com/inspect-js/is-async-function/compare/v1.0.0...v1.1.0) - 2015-06-25

### Commits

- Release v1.1.0 [`b3f3704`](https://github.com/inspect-js/is-async-function/commit/b3f3704f13a32664a08b3d55162925e37626f5e8)
- update metadata [`95e6bc2`](https://github.com/inspect-js/is-async-function/commit/95e6bc2cc195ff5d2ab01f47c6a157b3a583d01a)
- check also for `done` and `next` [`6697d29`](https://github.com/inspect-js/is-async-function/commit/6697d29430ac9ce5f55572a2d7762baa1f05a33b)

## v1.0.0 - 2015-06-05

### Commits

- :cat2: implement :star2: [`eaccc68`](https://github.com/inspect-js/is-async-function/commit/eaccc681838a983390e93607451500982759bd7a)
- add keywords [`55a5ffc`](https://github.com/inspect-js/is-async-function/commit/55a5ffc65d344328cf5b5bb7b7e1520ecede0035)
- Release v1.0.0 [`66eab5f`](https://github.com/inspect-js/is-async-function/commit/66eab5f96c62a6a39b913a84e8ec4b37c657026a)
- refactor [`a7ce00d`](https://github.com/inspect-js/is-async-function/commit/a7ce00d537bf420338b91fee00eb6893d14952bf)
- add test for when throw [`60d0175`](https://github.com/inspect-js/is-async-function/commit/60d0175a955645b304f572fd571a1ced47486958)
- add `related` section [`904acd8`](https://github.com/inspect-js/is-async-function/commit/904acd8fbd5c6c020ba537cc9962154d818ad067)
- simplify travis [`ee17273`](https://github.com/inspect-js/is-async-function/commit/ee172737486a8a5f7b2b642aa72e6ca7a1749a1c)
- Initial commit [`7e914c1`](https://github.com/inspect-js/is-async-function/commit/7e914c1c6d669635f239fa86d9d96f85d8aaaab4)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [v1.2.0](https://github.com/inspect-js/which-builtin-type/compare/v1.1.4...v1.2.0) - 2024-11-23

### Commits

- [New] add types [`d4aa2db`](https://github.com/inspect-js/which-builtin-type/commit/d4aa2db289a8d97c6917c0edb1edcb32001488a8)
- [actions] split out node 10-20, and 20+ [`7b3d28b`](https://github.com/inspect-js/which-builtin-type/commit/7b3d28bcb1258cdfd5a7df5606622351596fb442)
- [Refactor] use `callBound` to cache Promise#then [`a000377`](https://github.com/inspect-js/which-builtin-type/commit/a0003772dabdd5fd4b84c2ed8e139df008a437e8)
- [Dev Deps] update `auto-changelog`, `object-inspect`, `tape` [`37062d2`](https://github.com/inspect-js/which-builtin-type/commit/37062d280a8c36c1bd96b6cfbe053f10cf8d71b6)
- [Tests] replace `aud` with `npm audit` [`337aac1`](https://github.com/inspect-js/which-builtin-type/commit/337aac1d88fc63d935bd15a97926e9b0b462a735)
- [Deps] update `is-finalizationregistry` [`4ef8763`](https://github.com/inspect-js/which-builtin-type/commit/4ef8763a19709df7ad50d790bd2b724f531a65d9)
- [Dev Deps] add missing peer dep [`1cb2842`](https://github.com/inspect-js/which-builtin-type/commit/1cb28421438eb4ee8f0f284b535f1cfc6b9c9757)

## [v1.1.4](https://github.com/inspect-js/which-builtin-type/compare/v1.1.3...v1.1.4) - 2024-07-29

### Commits

- [readme] fix URLs [`f26fc22`](https://github.com/inspect-js/which-builtin-type/commit/f26fc2243220277874e36ace85f48f87ec8ab502)
- [Dev Deps] update `@ljharb/eslint-config`, `aud`, `available-typed-arrays`, `npmignore`, `object-inspect`, `object.assign`, `tape` [`f724135`](https://github.com/inspect-js/which-builtin-type/commit/f724135d44efd74ee067102c8c499566d73b849c)
- [Deps] update `function.prototype.name`, `has-tostringtag`, `which-collection`, `which-typed-array` [`831119b`](https://github.com/inspect-js/which-builtin-type/commit/831119b76ce79004c368deab141e8a9bd680950c)

## [v1.1.3](https://github.com/inspect-js/which-builtin-type/compare/v1.1.2...v1.1.3) - 2022-11-02

### Commits

- [meta] use `npmignore` to autogenerate an npmignore file [`0ccf168`](https://github.com/inspect-js/which-builtin-type/commit/0ccf168604ddaab1d40de8fde5140f5dca942c5b)
- [Dev Deps] update `aud`, `has-bigints`, `has-symbols`, `in-publish`, `object-inspect`, `object.assign`, `tape` [`2c87b2e`](https://github.com/inspect-js/which-builtin-type/commit/2c87b2ed58c397a26953dbe2cb2aae452e32ee21)
- [actions] update rebase action to use reusable workflow [`ab27caf`](https://github.com/inspect-js/which-builtin-type/commit/ab27caf0d6cd1fccc5738fda4cebee7bf47eca14)
- [meta] simplify `exports` [`680d056`](https://github.com/inspect-js/which-builtin-type/commit/680d05674f979c1a02ae7c6b9f885114e962324e)
- [Deps] update `which-typed-array` [`3ca0216`](https://github.com/inspect-js/which-builtin-type/commit/3ca02166585c6e7350fe0bc7518fccce269fc5ac)
- [meta] add `sideEffects` flag [`caa2221`](https://github.com/inspect-js/which-builtin-type/commit/caa22214c751674f1959944a0ece81b032141e3b)

## [v1.1.2](https://github.com/inspect-js/which-builtin-type/compare/v1.1.1...v1.1.2) - 2022-04-12

### Commits

- [actions] reuse common workflows [`b1b60aa`](https://github.com/inspect-js/which-builtin-type/commit/b1b60aa01b20f613a97b456c3062412f0aba67dd)
- [Dev Deps] update `eslint`, `@ljharb/eslint-config`, `@es-shims/api`, `safe-publish-latest`, `tape` [`8115a20`](https://github.com/inspect-js/which-builtin-type/commit/8115a20941ca702c1a927a0aea08ffa0b37821c0)
- [Dev Deps] update `eslint`, `@ljharb/eslint-config`, `aud`, `auto-changelog`, `object-inspect`, `tape` [`86b3c3b`](https://github.com/inspect-js/which-builtin                                                                                                                                                                                                                                                import * as fs$8 from 'node:fs';
import fs__default, { promises as promises$1, existsSync as existsSync$1, readFileSync as readFileSync$1 } from 'node:fs';
import fsp, { constants as constants$9 } from 'node:fs/promises';
import path$d, { posix as posix$1, isAbsolute as isAbsolute$1, join as join$1, resolve as resolve$4, normalize, dirname as dirname$2, relative as relative$2, basename as basename$2, extname as extname$1 } from 'node:path';
import require$$1$1, { fileURLToPath as fileURLToPath$1, URL as URL$3, pathToFileURL as pathToFileURL$1 } from 'node:url';
import { promisify as promisify$4, format as format$2, inspect, stripVTControlCharacters } from 'node:util';
import { performance } from 'node:perf_hooks';
import require$$0$5, { createRequire as createRequire$1, builtinModules } from 'node:module';
import esbuild, { transform as transform$1, formatMessages, build as build$b } from 'esbuild';
import { CLIENT_ENTRY, OPTIMIZABLE_ENTRY_RE, wildcardHosts, loopbackHosts, FS_PREFIX, CLIENT_PUBLIC_PATH, ENV_PUBLIC_PATH, DEFAULT_ASSETS_INLINE_LIMIT, ENV_ENTRY, SPECIAL_QUERY_RE, DEP_VERSION_RE, DEV_PROD_CONDITION, JS_TYPES_RE, KNOWN_ASSET_TYPES, CSS_LANGS_RE, METADATA_FILENAME, ESBUILD_MODULES_TARGET, ERR_OPTIMIZE_DEPS_PROCESSING_ERROR, ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR, VITE_PACKAGE_DIR, DEFAULT_DEV_PORT, CLIENT_DIR, VERSION, ROLLUP_HOOKS, DEFAULT_ASSETS_RE, DEFAULT_CONFIG_FILES, DEFAULT_PREVIEW_PORT, DEFAULT_CLIENT_MAIN_FIELDS, DEFAULT_SERVER_MAIN_FIELDS, DEFAULT_CLIENT_CONDITIONS, DEFAULT_SERVER_CONDITIONS } from '../constants.js';
import require$$0$2, { posix, win32, isAbsolute, resolve as resolve$3, relative as relative$1, basename as basename$1, extname, dirname as dirname$1, join, sep } from 'path';
import require$$0$3, { existsSync, readFileSync, statSync, readdirSync } from 'fs';
import childProcess$2, { exec, execFile, execSync } from 'node:child_process';
import { createServer as createServer$3, STATUS_CODES, get as get$2 } from 'node:http';
import { createServer as createServer$2, get as get$1 } from 'node:https';
import require$$0$4 from 'tty';
import require$$1 from 'util';
import require$$4$1 from 'net';
import require$$0$7 from 'events';
import require$$0$6 from 'url';
import require$$1$2 from 'http';
import require$$0$8 from 'stream';
import require$$2 from 'os';
import require$$2$1 from 'child_process';
import os$3 from 'node:os';
import crypto$2 from 'node:crypto';
import { promises } from 'node:dns';
import { ModuleRunner, ESModulesEvaluator } from 'vite/module-runner';
import { parseAstAsync, parseAst } from 'rollup/parseAst';
import { createRequire as createRequire$2 } from 'module';
import readline from 'node:readline';
import process$1 from 'node:process';
import { Buffer as Buffer$1 } from 'node:buffer';
import { EventEmitter as EventEmitter$4 } from 'node:events';
import require$$3 from 'crypto';
import assert$1 from 'node:assert';
import v8 from 'node:v8';
